---
eip: 3450
title: BIP-39 助记词的标准化 Shamir 秘密共享方案
author: Daniel Streit (@danielstreit)
discussions-to: https://ethereum-magicians.org/t/erc-3450-standard-for-applying-shamirs-to-bip-39-mnemonics/5844
status: Stagnant
type: Standards Track
category: ERC
created: 2021-03-29
---

## 简要总结

将 Shamir 的秘密共享方案标准化应用于 BIP-39 助记词的算法。

## 摘要

一种将 BIP-39 助记词分割为 _N_ 个 BIP-39 助记词（称为份额）的标准化方法，以便恢复原始助记词需要 _T_ 个份额，并且在少于 _T_ 个份额的情况下不会泄露关于原始助记词的任何信息，除了其大小。

## 动机

我们希望使不太技术的用户更容易安全地存储密钥。

目前，许多用户使用 BIP-39 助记词来存储其密钥的熵值。这些助记词是单点故障。如果丢失，用户可能永远无法重新获得被密钥锁定的资产。如果被盗，恶意行为者可以窃取资产。

Shamir 的秘密共享方案直接解决了这个问题。它创建了秘密的“份额”，使得可以使用一个子集来恢复秘密，但只有在达到最低份额阈值时才能恢复。没有达到最低阈值时，不会泄露关于原始秘密的任何信息。

Shamir 的秘密共享方案的一个问题是没有规范的标准实现。这使得恢复面临风险，因为工具可能会随着时间而变化。

在这里，我们提出了一种专门应用于 BIP-39 助记词的 Shamir 秘密共享方案的标准化实现，以便用户可以轻松创建助记词的份额，销毁原始助记词，适当地存储份额，并在稍后自信地恢复原始助记词。

## 规范

### Shamir 的秘密共享方案

Shamir 的秘密共享方案是一种将秘密分割成 _N_ 个唯一部分的密码学方法，其中任何 _T_ 个部分都可以重建该秘密。

首先，构造一个度数为 _T_ − 1 的多项式 _f_。然后，每个份额是多项式曲线上的一个点：一个整数 _x_ 及其对应的 _y_ 点 _f_(_x_)。

通过任何 _T_ 个份额（或点），可以使用多项式插值恢复初始多项式。

在构造初始多项式时，秘密存储为 x<sup>0</sup> 的系数，其余系数随机生成。

### BIP-39 助记词

BIP-39 是一种将熵存储为单词列表的常见标准。与原始二进制或十六进制表示的熵相比，它更易于人类交互。

BIP-39 助记词编码了两部分数据：原始熵和该熵的校验和。校验和允许验证助记词，确保用户正确输入。

#### 生成助记词

助记词必须以 32 位的倍数编码熵。熵越多，安全性越高，但句子长度也会增加。我们将初始熵长度称为 ENT。ENT 的允许大小为 128-256 位。

首先，生成 ENT 位的初始熵。通过取其 SHA256 哈希的前 `ENT / 32` 位生成校验和。将此校验和附加到初始熵的末尾。接下来，将这些连接的位分成 11 位一组，每组编码一个从 0 到 2047 的数字，作为单词列表的索引。最后，我们将这些数字转换为单词，并将连接的单词用作助记词句子。

下表描述了初始熵长度（ENT）、校验和长度（CS）和生成的助记词句子（MS）长度（以单词计）之间的关系。

```
CS = ENT / 32
MS = (ENT + CS) / 11

|  ENT  | CS | ENT+CS |  MS  |
+-------+----+--------+------+
|  128  |  4 |   132  |  12  |
|  160  |  5 |   165  |  15  |
|  192  |  6 |   198  |  18  |
|  224  |  7 |   231  |  21  |
|  256  |  8 |   264  |  24  |
```

#### 恢复熵

可以通过反转上述过程来恢复初始熵。将助记词转换为位，其中每个单词转换为表示其在单词列表中索引的 11 位。熵部分根据助记词的大小在上表中定义。

#### 单词列表

本规范仅支持 BIP-39 英文单词列表，但未来可能会扩展。

请参见 [单词列表](../assets/eip-3450/wordlist.txt)。

### 将 Shamir 的方案应用于 BIP-39 助记词

为了确保份额是有效的 BIP-39 助记词，我们：

1. 将目标 BIP-39 助记词转换为其底层熵
2. 将 Shamir 的方案应用于熵
3. 将每个结果份额的 _y_ 值转换为 BIP-39 助记词

通过在应用 Shamir 的方案之前转换为熵，我们省略了初始秘密中的校验和，从而在将份额 _y_ 值转换为助记词时为每个份额计算新的校验和，确保它们根据 BIP-39 是有效的。

在将 Shamir 的方案应用于熵时，我们分别对熵的每个字节应用它，并使用 GF(256) 作为底层有限域。字节被解释为 GF(256) 的元素，使用多项式表示法，操作模 Rijndael 不可约多项式 _x_<sup>8</sup> + _x_<sup>4</sup> + _x_<sup>3</sup> + _x_ + 1，遵循 AES。

### 份额格式

一个份额表示用于分割秘密的底层多项式所描述的曲线上的一个点。它包括两部分数据：

- 一个 ID：份额的 _x_ 值
- 一个 BIP-39 助记词：由助记词表示的份额的 _y_ 值

### 创建份额

输入：BIP-39 助记词，份额数量 (_N_)，阈值 (_T_)

输出：N 份额，每个份额包括一个 ID，{ _x_ | 0 &lt; _x_ &lt; 256 }，以及与输入相同长度的 BIP-39 助记词

1. 检查以下条件：
   - 1 < T <= N < 256
   - 助记词根据 [BIP-39](#generating-the-mnemonic) 是有效的
2. [恢复助记词的底层熵](#recovering-the-entropy) 作为字节向量
3. 定义值：
   - 设 _E_ 为助记词熵的字节向量表示
   - 设 _n_ 为 _E_ 的长度
   - 设 _coeff<sub>1</sub>_, ... , _coeff<sub>T - 1</sub>_ 为属于 GF(256)<sup>n</sup> 的字节向量，随机生成，独立且均匀分布于适合生成密码学密钥的源
4. 为每个份额评估多项式
   - 对于每个 _x_ 从 1 到 _N_，评估多项式 _f(x)_ = _E_ + _coeff<sub>1</sub>x<sup>1</sup>_ + ... + _coeff<sub>T - 1</sub>x<sup>T - 1</sup>_，其中 _x_ 是份额 ID，_f(x)_ 是份额值（作为字节向量）
5. 使用 _f(x)_ 作为底层熵，为每个份额 [生成助记词](#generating-the-mnemonic)
6. 返回每个份额的 ID 和助记词

### 恢复助记词

要恢复原始助记词，我们从给定的份额（或多项式上的点）插值一个多项式 _f_ 并评估 _f(0)_。

#### 多项式插值

给定一组 _m_ 个点 (_x<sub>i</sub>_, _y<sub>i</sub>_)，1 &le; _i_ &le; _m_，使得没有两个 _x<sub>i</sub>_ 值相等，存在一个多项式在每个点 _x<sub>i</sub>_ 处取值 _y<sub>i</sub>_。满足这些条件的最低度数的多项式是唯一确定的，可以使用下面给出的拉格朗日插值公式获得。

由于 Shamir 的秘密共享方案是分别应用于共享助记词熵的每个 _n_ 字节，因此我们将 _y<sub>i</sub>_ 视为 _n_ 个值的向量，其中 _y<sub>i</sub>[_k_] = _f<sub>k</sub>_(_x<sub>i</sub>_)，1 &le; _k_ &le; _n_，而 _f<sub>k</sub>_ 是方案中第 _k_ 次的多项式。
#### 插值(*x*, {(*x<sub>i</sub>*, *y<sub>i</sub>*), 1 &le; *i* &le; *m*})

输入：所需的索引 *x*，一组索引/值向量对 {(*x<sub>i</sub>*, *y<sub>_i_*</sub>), 1 &le; *i* &le; *m*} &subseteq; GF(256) &times; GF(256)<sup>*n*</sup>

输出：值向量 (*f<sub>1</sub>(*x*), ... , *f<sub>n</sub>(*x*))

![f_k(x) = \sum_{i=1}^m y_i[k] \prod_{\underset{j \neq i}{j=1}}^m \frac{x - x_j}{x_i - x_j}](../assets/eip-3450/lagrange.gif)

#### 恢复助记词

输入：一组 *m* 份共享

输出：原始助记词

1. [恢复每个共享助记词的基础熵](#recovering-the-entropy)作为字节向量
2. 计算 *E* = 插值(0, [(*x<sub>1</sub>*, *y<sub>1</sub>*),...,(*x<sub>m</sub>*, *y<sub>m</sub>*)]), 其中 *x* 是共享 ID，*y* 是共享助记词熵的字节向量
3. 使用 *E* 作为基础熵， [生成助记词](#generating-the-mnemonic)并返回

## 理由

### 字段选择

选择 GF(256) 是因为该字段的算术在任何编程语言中都易于实现，并且由于它在 AES 加密中使用，许多实现已经可用。尽管使用 GF(256) 需要将助记词转换为其基础熵作为字节向量，但这也易于实现，并且在多种编程语言中存在许多实现。

GF(2048) 也被考虑过。使用 GF(2048)，我们可以直接将 Shamir 的方案应用于助记词，使用单词索引作为值。这将使我们避免将助记词转换为其基础熵。但是，生成的共享将不再是有效的 BIP-39 助记词 - 校验和部分将不是熵的有效校验和。而且，解决这个问题将增加相当大的复杂性。

另一个选项是 GF(2<sup>*n*</sup>)，其中 *n* 是熵的位数。我们仍然会将助记词转换为熵，但随后在整个熵上应用 Shamir 的方案，而不是在值向量上。这个方法的缺点是我们需要为每个助记词强度使用不同的字段以及相关的不可约多项式。此外，这将需要处理非常大的数字，在某些语言中可能会很麻烦。

### 有效共享助记词和共享 ID

规范生成的共享除了 BIP-39 助记词外，还包括一个 ID。

其他选项可以将共享 ID 编码到助记词中，从而简化存储 - 只需存储助记词。

一种可能性是将 ID 存储在助记词中，而不是校验和。这个方法的缺点是共享将不是有效的 BIP-39 助记词，因为助记词的“校验和”部分将与“熵”部分不匹配。具有有效 BIP-39 助记词的共享是有用的，因为它们与其他任何共享都无法区分。用户可以以多种方式存储 ID，从而使其不易被发现。

### 恢复时的验证

我们决定不在恢复原始助记词时包含验证机制。这会向潜在攻击者泄露更少的信息。在他们获得 *T* + 1 份共享之前，没有迹象表明他们已经获得了所需数量的共享。

我们可以通过用原始助记词的校验和替换一个随机系数来提供恢复验证。然后，在恢复原始助记词和多项式时，我们可以验证校验和系数是否是恢复助记词的有效校验和。

## 测试用例

即将推出。

所有实现必须能够：

- 使用给定的 `numShares` 和 `threshold` 拆分和恢复每个 `助记词`。
- 从给定的 `knownShares` 中恢复 `助记词`。

## 安全考虑

规范生成的共享除了 BIP-39 助记词外，还包括一个 ID。这引发了两个安全问题：

用户 **必须** 保留此 ID 以恢复原始助记词。如果 ID 丢失或与共享助记词分离，可能无法恢复原始助记词。（暴力恢复可能或可能不可能，具体取决于已知的共享数量和阈值）

附加数据可能会向攻击者暗示其他密钥的存在及其存储方案。因此，ID 应以模糊其用途的方式存储。

## 版权

版权及相关权利通过 [CC0](../LICENSE.md) 放弃。