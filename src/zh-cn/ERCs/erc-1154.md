---
eip: 1154
title: 预言机接口
author: Alan Lu (@cag)
discussions-to: https://github.com/ethereum/EIPs/issues/1161
status: 撤回
type: 标准跟踪
category: ERC
created: 2018-06-13
---

## 简单总结
预言机的标准接口。

## 摘要
为了使以太坊智能合约能够与链外系统交互，必须使用预言机。这些预言机报告通常是链外的值，使智能合约能够对链外系统的状态做出反应。预言机系统之间区分并选择基于推送和拉取的方式。此外，这里描述了预言机的标准接口，允许不同的预言机实现可以互换。

## 动机
以太坊生态系统目前有许多不同的预言机实现，但它们没有提供统一的接口。智能合约系统将被锁定在一组特定的预言机实现中，或者要求开发者为在特定项目中选择的预言机系统编写适配器/端口。

除了命名差异外，还有一个问题是预言机报告解析交易是否通过调用受影响的合约来*推送*状态变化，或者更改预言机状态以允许依赖合约*拉取*更新的值。这些不同的系统语义可能在适应它们时引入低效。

最终，不同预言机系统的价值来自于其底层解析机制，几乎相同的系统点应当标准化。

这些预言机可用于回答关于“现实世界事件”的问题，其中每个 ID 可以与问题及其答案的规范相关联（因此最有可能用于预测市场，基本上）。

另一个用例可能是决策过程，其中预言机给出的结果代表预言机做出的决策（例如，未来主义）。DAO 可能在决策过程中需要使用它们。

ID 和结果都是故意非结构化的，以便可以表示时间序列数据（通过拆分 ID）和不同类型的结果（如几个中的一个、最多 256 的任何子集，或某个范围内的某个值，具有最多 256 位的粒度）。

## 规范

<dl>
  <dt>预言机</dt>
  <dd>向区块链报告数据的实体。</dd>

  <dt>预言机消费者</dt>
  <dd>从预言机接收数据的智能合约。</dd>

  <dt>ID</dt>
  <dd>索引预言机报告的数据的一种方式。可能源自或与数据提供答案的问题相关联。</dd>

  <dt>结果</dt>
  <dd>与 ID 相关联的数据，由预言机报告。该数据通常是与 ID 相关的问题的答案。其他使用过的等效术语包括：答案、数据、结果。</dd>

  <dt>报告</dt>
  <dd>预言机发送给预言机消费者的一对 (ID, result)。</dd>
</dl>

```solidity
interface OracleConsumer {
    function receiveResult(bytes32 id, bytes result) external;
}
```

`receiveResult` 必须在 `msg.sender` 不是被授权提供该 `id` 的 `result` 的预言机时回退。

`receiveResult` 必须在之前已经用相同的 `id` 调用过时回退。

`receiveResult` 可以在消费者无法处理 `id` 或 `result` 时回退。

消费者必须与预言机协调，以确定如何将结果编码/解码为 `bytes`。例如，可以使用 `abi.encode` 和 `abi.decode` 在 Solidity 中实现结果的编解码器。如果消费者从预言机接收到意外的结果格式，`receiveResult` 应该回退。

预言机可以是任何以太坊账户。

## 理由
当前的规范与 ChainLink（可以使用任何任意命名的回调）和 Oraclize（使用 `__callback`）实现的非常相似。

通过这个规范，预言机*推送*状态到消费者，消费者必须相应地对更新的状态做出反应。可以规定一个替代的*拉取*接口，如下所示：

### 替代拉取接口
以下是基于 Gnosis 预测市场合约 v1 的替代规范。Reality Check 也暴露了类似的端点（`getFinalAnswer`）。

```solidity
interface Oracle {
    function resultFor(bytes32 id) external view returns (bytes result);
}
```

`resultFor` 必须在某个 `id` 的结果尚不可用时回退。

`resultFor` 必须在结果可用后返回相同的结果。

### 推送与拉取
请注意，基于推送的接口可以适应为基于拉取的接口。只需部署一个预言机消费者，存储接收到的结果并相应地实现 `resultFor`。

同样，每个基于拉取的系统都可以适应为基于推送的系统：只需在预言机智能合约上添加一个方法，该方法接受一个预言机消费者地址并调用该地址上的 `receiveResult`。

在这两种情况下，都必须执行额外的交易，因此选择使用推送或拉取应基于这些预言机的主要用例。

在简单的情况下，如果单个账户有权决定预言机问题的结果，则无需部署预言机合约并在该预言机合约上存储结果。同样，在结果取决于投票的情况下，可以使用现有的多签名钱包作为授权的预言机。

#### 多个预言机消费者
如果许多预言机消费者依赖于单个预言机结果，并且所有这些消费者都期望结果被推送给他们，则如果推送的预言机无法被信任为向每个消费者发送相同的结果，则之前提到的推送和拉取适配可以结合使用（在某种意义上，这将信任转发到预言机适配器实现）。

在基于拉取的系统中，每个消费者都必须被调用以从预言机合约中拉取结果，但在提议的基于推送的系统中，适配的预言机必须被调用以将结果推送给每个消费者。

在这种情况下，从交易的角度来看，这两种系统在效率上大致相当，但在基于推送的系统中，预言机消费者需要再次存储结果，而在基于拉取的系统中，消费者可以继续参考预言机以获取结果。尽管这可能效率稍低，但要求消费者存储结果也可以提供安全保证，特别是在结果不可变性方面。

#### 结果不可变性
在提议的规范和替代规范中，结果一旦确定就是不可变的。这是因为典型消费者将要求结果不可变，以便一致地确定结果状态。在提议的基于推送的系统中，消费者强制执行结果不可变性要求，而在替代的基于拉取的系统中，预言机必须被信任以正确实现规范并强制执行不可变性要求，或者消费者也必须处理结果不可变性。

对于随时间变化的数据，`id` 字段可以结构化以指定数据的“什么”和“何时”（使用 128 位来指定“何时”在许多千年内仍然是安全的）。

## 实现

* [Tidbit](https://github.com/levelkdev/tidbit) 跟踪此 EIP。

## 版权
版权及相关权利通过 [CC0](../LICENSE.md) 放弃。