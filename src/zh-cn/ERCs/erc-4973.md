---
eip: 4973
title: 账户绑定代币
description: 一种接口，用于绑定到以太坊账户的不可转让 NFT，就像《魔兽世界》中的传奇物品绑定到角色一样。
author: Tim Daubenschütz (@TimDaub)
discussions-to: https://ethereum-magicians.org/t/eip-4973-non-transferrable-non-fungible-tokens-soulbound-tokens-or-badges/8825
status: 审核中
type: 标准跟踪
category: ERC
created: 2022-04-01
requires: 165, 712, 721, 1271
---

## 摘要

提出了一种在智能合约中用于账户绑定代币（ABT）的标准 API。ABT 是绑定到单个账户的不可替代代币。ABT 不实现转移的规范接口。此 EIP 定义了铸造、分配、撤销和跟踪 ABT 的基本功能。

## 动机

在流行的 MMORPG 《魔兽世界》中，其游戏设计师故意将一些物品移出世界拍卖行市场系统，以防止它们具有公开发现的价格并限制其可获取性。

《魔兽世界》中的“雷霆之怒，风之追寻者的祝福之刃”就是这样一件传奇物品，它需要一个四十人的团队，以及其他子任务，才能击败火焰领主“拉格纳罗斯”以获得“火焰领主的精华”，这是铸造这把剑所需的材料。

在自愿拾取后，这把剑会永久**绑定**到角色的“灵魂”，使其无法在玩家的角色之间交易、出售或甚至交换。

换句话说，“雷霆之怒”的价格是与朋友和公会成员一起完成艰难任务线相关的所有社会成本的总和。其他玩家看到雷霆之怒时，可以确信其拥有者已经击败了“拉格纳罗斯”，这个炽热的火焰领主。

《魔兽世界》的玩家可以**丢弃**像雷霆之怒这样的传奇和灵魂绑定物品，以永久将其从他们的账户中移除。玩家可以选择可见地**装备**或**卸下**物品，从而向所有人展示他们的成就。

以太坊社区表达了对不可转让、不可替代和社会定价代币的需求，类似于《魔兽世界》的灵魂绑定物品。当前，流行的合约隐式实现了账户绑定的交互权。原则性的标准化有助于互操作性并改善链上数据索引。

本文档的目的是通过创建对**最大向后兼容**但其他方面**最小**的接口定义，使 ABT 在以太坊上成为现实。

## 规范

### Solidity 接口

本文档中的关键字“MUST”、“MUST NOT”、“REQUIRED”、“SHALL”、“SHALL NOT”、“SHOULD”、“SHOULD NOT”、“RECOMMENDED”、“MAY”和“OPTIONAL”应按 RFC 2119 中的描述进行解释。

ABT _必须_ 实现以下接口：

- [ERC-165](./eip-165.md) 的 `ERC165` (`0x01ffc9a7`)
- [ERC-721](./eip-721.md) 的 `ERC721Metadata` (`0x5b5e139f`)

ABT _必须不_ 实现以下接口：

- [ERC-721](./eip-721.md) 的 `ERC721` (`0x80ac58cd`)

ABT 接收者必须能够始终调用 `function unequip(address _tokenId)` 将其 ABT 移除链外。

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.6;

/// @title Account-bound tokens
/// @dev See https://eips.ethereum.org/EIPS/eip-4973
/// Note: the ERC-165 identifier for this interface is 0xeb72bb7c
interface IERC4973 {
  /// @dev This emits when ownership of any ABT changes by any mechanism.
  ///  This event emits when ABTs are given or equipped and unequipped
  ///  (`to` == 0).
  event Transfer(
    address indexed from, address indexed to, uint256 indexed tokenId
  );

  /// @notice Count all ABTs assigned to an owner
  /// @dev ABTs assigned to the zero address are considered invalid, and this
  ///  function throws for queries about the zero address.
  /// @param owner An address for whom to query the balance
  /// @return The number of ABTs owned by `address owner`, possibly zero
  function balanceOf(address owner) external view returns (uint256);

  /// @notice Find the address bound to an ERC4973 account-bound token
  /// @dev ABTs assigned to zero address are considered invalid, and queries
  ///  about them do throw.
  /// @param tokenId The identifier for an ABT.
  /// @return The address of the owner bound to the ABT.
  function ownerOf(uint256 tokenId) external view returns (address);

  /// @notice Removes the `uint256 tokenId` from an account. At any time, an
  ///  ABT receiver must be able to disassociate themselves from an ABT
  ///  publicly through calling this function. After successfully executing this
  ///  function, given the parameters for calling `function give` or
  ///  `function take` a token must be re-equipable.
  /// @dev Must emit a `event Transfer` with the `address to` field pointing to
  ///  the zero address.
  /// @param tokenId The identifier for an ABT.
  function unequip(uint256 tokenId) external;

  /// @notice Creates and transfers the ownership of an ABT from the
  ///  transaction's `msg.sender` to `address to`.
  /// @dev Throws unless `bytes signature` represents a signature of the
  //   EIP-712 structured data hash
  ///  `Agreement(address active,address passive,bytes metadata)` expressing
  ///  `address to`'s explicit agreement to be publicly associated with
  ///  `msg.sender` and `bytes metadata`. A unique `uint256 tokenId` must be
  ///  generated by type-casting the `bytes32` EIP-712 structured data hash to a
  ///  `uint256`. If `bytes signature` is empty or `address to` is a contract,
  ///  an EIP-1271-compatible call to `function isValidSignatureNow(...)` must
  ///  be made to `address to`. A successful execution must result in the
  ///  `event Transfer(msg.sender, to, tokenId)`. Once an ABT exists as an
  ///  `uint256 tokenId` in the contract, `function give(...)` must throw.
  /// @param to The receiver of the ABT.
  /// @param metadata The metadata that will be associated to the ABT.
  /// @param signature A signature of the EIP-712 structured data hash
  ///  `Agreement(address active,address passive,bytes metadata)` signed by
  ///  `address to`.
  /// @return A unique `uint256 tokenId` generated by type-casting the `bytes32`
  ///  EIP-712 structured data hash to a `uint256`.
  function give(address to, bytes calldata metadata, bytes calldata signature)
    external
    returns (uint256);

  /// @notice Creates and transfers the ownership of an ABT from an
  /// `address from` to the transaction's `msg.sender`.
  /// @dev Throws unless `bytes signature` represents a signature of the
  ///  EIP-712 structured data hash
  ///  `Agreement(address active,address passive,bytes metadata)` expressing
  ///  `address from`'s explicit agreement to be publicly associated with
  ///  `msg.sender` and `bytes metadata`. A unique `uint256 tokenId` must be
  ///  generated by type-casting the `bytes32` EIP-712 structured data hash to a
  ///  `uint256`. If `bytes signature` is empty or `address from` is a contract,
  ///  an EIP-1271-compatible call to `function isValidSignatureNow(...)` must
  ///  be made to `address from`. A successful execution must result in the
  ///  emission of an `event Transfer(from, msg.sender, tokenId)`. Once an ABT
  ///  exists as an `uint256 tokenId` in the contract, `function take(...)` must
  ///  throw.
  /// @param from The origin of the ABT.
  /// @param metadata The metadata that will be associated to the ABT.
  /// @param signature A signature of the EIP-712 structured data hash
  ///  `Agreement(address active,address passive,bytes metadata)` signed by
  ///  `address from`.

  /// @return A unique `uint256 tokenId` generated by type-casting the `bytes32`
  ///  EIP-712 structured data hash to a `uint256`.
  function take(address from, bytes calldata metadata, bytes calldata signature)
    external
    returns (uint256);

  /// @notice Decodes the opaque metadata bytestring of an ABT into the token
  ///  URI that will be associated with it once it is created on chain.
  /// @param metadata The metadata that will be associated to an ABT.
  /// @return A URI that represents the metadata.
  function decodeURI(bytes calldata metadata) external returns (string memory);
}
```

有关其元数据 JSON Schema 的定义，请参见 [ERC-721](./eip-721.md)。

### [EIP-712](./eip-712.md) 类型结构化数据哈希和字节数组签名创建

要调用 `function give(...)` 和 `function take(...)`，必须使用 [EIP-712](./eip-712.md) 创建字节数组签名。附带的 Node.js 测试参考实现位于 [index.mjs](../assets/eip-4973/sdk/src/index.mjs)、[index_test.mjs](../assets/eip-4973/sdk/test/index_test.mjs) 和 [package.json](../assets/eip-4973/package.json)。在 Solidity 中，可以如下创建此字节数组签名：

```solidity
bytes32 r = 0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90;
bytes32 s = 0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064;
uint8 v   = 27;
bytes memory signature = abi.encodePacked(r, s, v);
```

## 理由

### 接口

ABT 应最大限度地向后兼容，但仍然仅暴露一个最小且易于实现的接口定义。

由于 [ERC-721](./eip-721.md) 代币在钱包提供商和市场中得到了广泛采用，因此使用其 `ERC721Metadata` 接口与 [ERC-165](./eip-165.md) 进行特性检测，可能允许实现者开箱即用地支持 ABT。

如果 [ERC-721](./eip-721.md) 的实现者正确构建了 [ERC-165](./eip-165.md) 的 `function supportsInterface(bytes4 interfaceID)` 函数，已经通过识别 [ERC-721](./eip-721.md) 的跟踪和转移接口组件标识符 `0x80ac58cd` 未被实现，转移代币的用户界面选项不应被建议。

尽管如此，由于 ABT 支持 [ERC-721](./eip-721.md) 的 `ERC721Metadata` 扩展，钱包和市场应显示账户绑定代币，而无需进行任何更改。

尽管其他账户绑定代币的实现是可能的，例如，通过使所有转移函数回退，ABT 是更优的，因为它通过 [ERC-165](./eip-165.md) 支持特性检测。

我们暴露 `function unequip(address _tokenId)` 并要求其在任何时候都可以由 ABT 的拥有者调用，因为这确保了拥有者有权公开与已发放到其账户的内容脱离关系。

### 异常处理

鉴于 ABT 的不可转让性，如果用户的账户或合约的密钥被泄露或更换，用户可能会失去与代币的关联能力。在某些情况下，这可能是期望的效果。因此，ABT 实现者应建立重新发行和撤销流程，以便提供补救措施。我们建议实施严格去中心化、无权限和抗审查的重新发行流程。

但本文档故意不提供在用户密钥被泄露或更换的情况下的标准化异常处理形式。

在实现者希望使账户绑定代币在不同账户之间可共享的情况下，例如，为了避免在密钥被泄露时失去访问权限，我们建议将账户绑定代币发放到实现多签名功能的合约账户。

### 溯源索引

ABT 可以通过跟踪 `event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)` 的发出进行索引。与 [ERC-721](./eip-721.md) 一样，两个账户之间的转移由 `address from` 和 `address to` 作为非零地址表示。卸下代币通过发出转移事件，`address to` 被设置为零地址来表示。铸造操作中 `address from` 被设置为零的情况不存在。为了避免被恶意实现的 `event Transfer` 发出合约欺骗，索引器应确保交易的发送者等于 `event Transfer` 的 `from` 值。

## 向后兼容性

我们故意采用 [ERC-165](./eip-165.md) 和 `ERC721Metadata` 函数，以创建与 [ERC-721](./eip-721.md) 的高度向后兼容性。我们故意使用 [ERC-721](./eip-721.md) 的术语，如 `function ownerOf(...)`、`function balanceOf(...)`，以最小化 ABT 实现者熟悉 [ERC-20](./eip-20.md) 或 [ERC-721](./eip-721.md) 的努力。对于索引器，我们重新使用了广泛实现的 `event Transfer` 事件签名。

## 参考实现

您可以在 [ERC-4973-flat.sol](../assets/eip-4973/ERC4973-flat.sol) 中找到此标准的实现。

## 安全考虑

与此标准的实现直接相关的安全考虑不存在。
## 版权

版权及相关权利通过 [CC0](../LICENSE.md) 放弃。