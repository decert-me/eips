---
eip: 7524
title: PLUME 签名在钱包中的应用
description: 一种新的以太坊密钥对签名方案，允许使用“无效器”实现独特的匿名性和零知识投票。
author: Yush G (@Divide-By-0) <aayushg@mit.edu>, Kobi Gurkan (@kobigurk), Richard Liu (@rrrliu), Vivek Bhupatiraju (@vb7401), Barry Whitehat (@barryWhiteHat)
discussions-to: https://ethereum-magicians.org/t/erc-7524-plume-signature-in-wallets/15902
status: Draft
type: Standards Track
category: ERC
created: 2023-09-24
---

## 摘要

ZK-SNARKs 已经为基于匿名所有权证明的新身份应用提供了构思。实现从现有应用到需要匿名唯一性的系统的主要技术之一是可验证的确定性签名的开发。由于以太坊基于 ECDSA，目前没有办法验证签名是否是确定性生成的，即使是“确定性” ECDSA 签名：ZK-SNARK 证明需要某人的私钥，而一些硬件钱包甚至不允许查看私钥。总体而言，我们不希望将私钥导出/复制粘贴到 SNARK 中作为预期的用户行为，并且大多数硬件钱包无法在安全区内运行现有方案的 SNARK 算术化（而且我们也不希望在钱包中标准化整个证明系统，因为它们几乎每年都在出现和演变）。因此，我们只能选择一种新的算法，提供可验证的、确定性的无效器，可以在安全区外进行 SNARK 处理。

一个具体的例子是，这种签名如何导致独特的伪匿名性：我们证明它是在 ZK-SNARK 中正确生成的，该证明仅公开显示 hash(signature)，并且 SNARK 还证明了公钥具有某些属性（即在某个匿名集合中，已在链上执行某些操作等）。这个证明是其他人看到的唯一内容，因此 hash(signature) 可以用作“无效器”：对特定匿名账户的公共承诺，以禁止双重支出等行为，或允许在匿名操作之间保持一致的身份。我们的目标是标准化一种新的可验证的确定性签名算法，该算法既能唯一标识密钥对，又能保持账户身份的秘密，且验证不需要秘密密钥。我们找到的具体签名函数（并将在接下来的帖子中讨论）是 $hash(message, public\ key) ^ {secret\ key}$。

## 动机

- 现有的 ZK 应用程序的优势在于对证明者没有唯一性约束：即，允许同一个钱包多次证明自己是成员是有意的。然而，许多应用程序要求每个用户最多只能进行一次操作，特别是希望抵御 Sybil 攻击的协议。目前在以太坊上，这些协议在没有将每个地址映射到一个选择性映射的情况下是无法原生实现的，这也将用户的私钥映射到一个新系统，这增加了复杂性，失去了原子性，并且无法利用以太坊账户丰富的链上历史。
- 需要此技术的特定应用包括：
    - zk 投票，其中某个集合中的每个账户只有一票
    - 以伪匿名方式领取像 Stealthdrop 这样的空投
    - 监管一个伪匿名论坛，用户可以证明他们在论坛的其他地方是同一身份
    - zk 证明偿付能力——如果你希望两个交易所证明它们知道一组持有某些余额的私钥，你需要确保两个交易所不会同时声称同一个地址，同时保持其私密性
    
因此，基于以太坊账户的 ECDSA 密钥对的确定性值是确保每个用户一次操作的必要组成部分，并使所有这些应用程序能够在以太坊上运行。

## 规范

我们提出一种新的签名标准，提供以下属性，以便在钱包中为标准 ECDSA 密钥实现：

1. 它生成包含确定性组件和非确定性组件的签名。确定性组件可用作 *无效器*。
2. 签名者可以使用现有的 secp256k1 密钥对，例如那些支持以太坊账户的硬件钱包。因此，如果有一个生成点乘法 API 进入安全区（例如 Ledger 就有），秘密密钥可以保留在安全区内。

### 参数

该方案使用 secp256k1 曲线，定义在 [高效密码学标准 2 (SEC 2) v2](../assets/eip-7524/sec2-v2.pdf) 第 9 页。

我们使用以下符号来表示该曲线的参数：

- $g$: 曲线的基点（也称为生成器）。
- $p$: 曲线的阶。
- $F_p$: 阶为 $p$ 的有限域。

请注意，我们使用指数符号表示椭圆曲线标量乘法。

### 公钥编码函数

### SEC1

该方案使用 [高效密码学标准 1 (SEC 1) v2](../assets/eip-7524/sec1-v2.pdf) 中定义的 SEC1 椭圆曲线点编码方案。使用点压缩。我们使用符号 $\mathsf{sec1}(pk)$ 表示 secp256k1 曲线点 $pk$ 的压缩编码，长度为 33 字节。

### 哈希函数

**SHA256**

该方案使用 [IETF RFC 4634](https://www.rfc-editor.org/rfc/rfc4634) 中定义的 SHA256 哈希函数。

在本文档中，我们使用符号 $\mathsf{sha256}(a_1,.. a_n)$ 表示 $n$ 个值 $a_1, ..., a_n$ 的连接的 sha256 摘要。该摘要应被解释为 secp256k1 标量域中的大端值。

### 哈希到曲线

我们使用符号 $\mathsf{htc}([a_1, ..., a_n])$ 表示 [IETF RFC 9380](https://www.rfc-editor.org/rfc/rfc9380) 附录 J.8.1 中的 `secp256k1_XMD:SHA-256_SSWU_RO_` 的结果。该哈希到曲线算法在 $n$ 个值 $a_1, ..., a_n$ 的连接上操作。

### 密钥生成

一个 *密钥对* 由 $(sk, pk)$ 组成，定义如下：

- $sk$: 用户的私钥，是一个在 $F_p$ 中的密码学安全随机标量。
- $pk$: 用户的公钥，定义为 $g^{sk}$，是 secp256k1 曲线上的一个点。

### 签名生成

该方案基于 Chaum-Pedersen 签名方案 [^1]。给定一个 32 字节的消息 $m$ 和一个密钥对 $(sk, pk)$，用户可以生成签名如下：

[^1]:
    ```csl-json
    {
      "DOI": "10.1007/3-540-48071-4_7",
      "URL": "https://link.springer.com/content/pdf/10.1007/3-540-48071-4_7.pdf",
      "publisher-place": "Berlin, Heidelberg",
      "author": [
        {
          "given": "David",
          "family": "Chaum"
        },
        {
          "given": "Torben Pryds",
          "family": "Pedersen"
        }
      ],
      "container-title": "Advances in Cryptology — CRYPTO' 92",
      "editor": [
        {
          "given": "Ernest F.",
          "family": "Brickell"
        }
      ],
      "type": "paper-conference",
      "id": "10.1007/3-540-48071-4_7",
      "citation-label": "10.1007/3-540-48071-4_7",
      "ISBN": "978-3-540-48071-6",
      "issued": {
        "date-parts": [
          [
            1993
          ]
        ]
      },
      "page": "89-105",
      "publisher": "Springer Berlin Heidelberg",
      "title": "Wallet Databases with Observers"
    }
    ```

1. 从 $F_p$ 中随机选择 $r$。
2. 计算 $h = \mathsf{htc}([m, \mathsf{sec1}(pk)])$。
3. 计算 $z = h ^ r$。
4. 计算无效器 $\mathsf{nul} = h^{sk}$。
5. 计算 $c = \mathsf{sha256}([g, pk, h, \mathsf{nul}, g^r, z]])$。
6. 计算 $s = r + sk \cdot c$。

签名为 $(z, s, g^r, c, \mathsf{nul})$。

输入到 $\mathsf{htc}$ 的长度始终为 65 字节。

请注意，在该方案中，我们计算 $h$ 为消息和 $pk$ 的哈希，而不是消息和 $r$。这是为了使我们的方案具有确定性。

### 签名验证（非 ZK）

> 📝 **注意：** 本节为非规范性内容。
>
> 非 ZK 签名验证不是本提案的一部分，但对于直观理解 ZK 签名验证是相关的。

在验证者知道 $g$、$m$、签名者的公钥 $pk$ 和签名 $(z, s, g^r, c, \mathsf{nul})$ 的情况下，他们可以执行以下检查以确定签名是否有效：

1. 计算 $h = \mathsf{htc}([m, \mathsf{sec1}(pk)])$。
2. 计算 $c' = \mathsf{sha256}([g, pk, h, \mathsf{nul}, g^r, z])$。
3. 如果以下任何条件为假，则拒绝：
a. $g^{s} \cdot pk^{-c} \stackrel{?}{=} g^r$
b. $h^s \cdot \mathsf{nul}^{-c} \stackrel{?}{=} z$
c. $c \stackrel{?}{=} c'$
4. 如果以上所有条件都为真，则接受。

现在我们进入 ZK 签名验证规范。

### 版本 1：验证者优化

在验证者必须 *不* 知道签名者的 $pk$ 的情况下，但签名者必须证明他们知道与给定 $m$ 的签名对应的 $sk$，需要零知识证明。

以下验证函数可以通过电路描述，作为非交互式零知识证明系统的一部分，例如 Groth16。为了创建证明，证明者提供以下输入：

**公共**: $\mathsf{nul}$, $c$
**私有**: $pk$, $r$, $s$, $z$, $g^r$, $hash[m, g^sk]$（包含以节省约束）

电路执行以下计算：

1. 计算 $h = \mathsf{htc}([m, \mathsf{sec1}(pk)])$。
2. 计算 $pk = g^{sk}$。
3. 计算 $c' = \mathsf{sha256}([g, pk, h, \mathsf{nul}, g^r, z]])$。
4. 计算 $g^{s} \cdot pk^{-c}$。
5. 计算 $g^r$。
6. 计算 $h^s \cdot \mathsf{nul}^{-c}$。

它还建立以下约束：

- $g^{s} \cdot pk^{-c} = g^r$
- $h^s \cdot \mathsf{nul}^{-c} = z$
- $c = c'$

### 版本 2：证明者优化

目前，SHA-256 哈希操作在浏览器中的 zk 证明中尤其昂贵。在 PLUME 的上下文中，计算 $c$ 是高效证明时间的瓶颈，因此 Poseidon 团队建议的一个修改是将此哈希计算移到电路外部，进入验证者。

为此，我们将 $z$ 和 $g^r$ 设为电路中的公共信号，并将 $c$ 的定义更新为 $c = \text{sha256}([\text{nul}, g^r, z])$。更新后的协议如下。

**公共:** $\mathsf{nul}$, $c$, $g^r$, $z$
**私有:** $pk$, $r$, $s$, $hash[m, g^sk]$

电路执行以下计算：

1. 计算 $h = \mathsf{htc}([m, \mathsf{sec1}(pk)])$。
2. 计算 $pk = g^{sk}$。
3. 计算 $g^{s} \cdot pk^{-c}$。
4. 计算 $g^r$。
5. 计算 $h^s \cdot \mathsf{nul}^{-c}$。

电路建立以下约束：

- $g^{s} \cdot pk^{-c} = g^r$
- $h^s \cdot \mathsf{nul}^{-c} = z$

除了验证 zk-SNARK，PLUME 验证者还执行以下检查。

$c == \text{hash}(\text{nul}, g^r, h^r)$

由于 SHA-256 是以太坊上的原生预编译，这个操作对于智能合约验证者仍然是高效的。

### 版本 3：

未来可能会有更高效的 V3，或许通过去除哈希到曲线的不可区分性。

## 理由

我们将定义我们在候选算法中寻找的一些特定属性，然后定义一些其他直观算法并解释它们为何实际上不起作用。

- 非交互性
    - ZK 身份系统中非交互性的意义在于它从一开始就能够实现一个大的匿名集合，使其抵御 Sybil 攻击和垃圾邮件，这在存在交互阶段的情况下是可能的。这使得新的用例如 ZK 空投成为可能。
    - 非交互性使得所有符合条件的用户都可以成为匿名集合的一部分，而无需任何交互。如果 zk 证明可以验证 Merkle 树中的集合成员资格、通过签名验证消息以及唯一的无效器，这是可能的。交互式无效器，例如 tornado.cash 的，需要在每个新用户时更新匿名集合 Merkle 树。
- 唯一性
    - 如果我们想禁止双重支出或双重索赔等行为，我们需要它们在每个账户上可验证地唯一。
    - 例如：由于 ECDSA 签名是非确定性的，签名不足以满足要求；我们需要一个新的确定性函数，仅用公钥可验证。我们希望无效器是非交互式的，以唯一标识密钥对，同时保持账户身份的秘密。
    - 关键的见解是，这种无效器可以用作对特定匿名账户的公共承诺，以提供唯一性保证。
- 确定性
    - 我们希望每个账户只生成一个这样的签名，并且在未来的时间里生成的方式完全相同。
- 无需秘密密钥即可验证
    - 在签名是非确定性的情况下（如 ECDSA），仅凭签名不足以进行验证。
    - 我们希望一个新的、仅用公钥可验证的确定性函数。
    - 我们不希望用户在任何地方复制粘贴秘密密钥，并且我们需要选择一个函数，使得安全区的计算对于硬件钱包来说足够简单。
    - 由于无效器是非交互式的，我们能够在不揭示账户身份的情况下唯一标识密钥对。

我们将最终设计基于尽可能简单的原则，并基于 BLS 签名、Chaum-Pederson EQDL 和 Goh-Jarecki 的 EDL 论文，但要在 secp256k1 上工作。

## 安全考虑

关于该特定算法的密码学有正式证明，详见 PLUME 论文 [^2]。理论已经发布，实施经过了一轮内部审计，但尚未进行端到端的正式验证或审计，尽管从经验上看，它们确实符合所列出的规范。

[^2]:
    ```csl-json
    {
        "DOI": "1721.1/147434",
        "author": [
        {
            "given": "Aayush",
            "family": "Gupta"
        },
        {
            "given": "Kobi",
            "family": "Gurkan"
        }
        ],
        "type": "book",
        "id": "Gupta_Gurkan_2022_PLUME",
        "citation-label": "Gupta_Gurkan_2022_PLUME",
        "issued": {
        "date-parts": [
            [
            2022,
            9
            ]
        ]
        },
        "keyword": "zero knowledge,zk proof,nullifier,ddh-vrf,vrf,pseudonymity,ethereum,bitcoin,ecdsa,secp256k1,plume,signature",
        "note": "Cryptology ePrint Archive, Paper 2022/1255",
        "title": "PLUME: An ECDSA Nullifier Scheme for Unique Pseudonymity within Zero Knowledge Proofs",
        "URL": "https://eprint.iacr.org/2022/1255"
    }
    ```
**交互性-量子保密权衡**

请注意，在遥远的未来，一旦量子计算机能够破解 ECDSA 密钥对安全性，大多数以太坊密钥对将会被破解，但提前迁移到量子抗性密钥对将能保护活跃资金的安全。具体来说，人们可以仅仅签署承诺新量子抗性密钥对的消息（或在类似算法上使用更高位的密钥对），而规范链可以分叉以使这些密钥对有效。ZK-SNARKs 变得可伪造，但 zk 证明仍然具有前向保密性。在最佳情况下，链应该能够顺利继续运行。

然而，如果人们依赖于任何类型的确定性无效器，如我们的构造，他们的匿名性将立即被破坏：有人可以仅仅推导出整个匿名集的秘密密钥，计算所有的无效器，并查看哪些匹配。这个问题在 ECDSA 上的任何确定性无效器算法中都会存在，因为揭示秘密密钥会揭示唯一的“随机性”来源，这在确定性协议中保证了匿名性。

如果人们想要保持数据的后量子保密性，他们必须放弃我们属性中的至少一个：最简单的可能是非交互性。例如，对于零知识空投，匿名集中的每个账户公开签署对新信号量 ID 承诺的承诺（有效地地址 pk 发布 $hash[randomness\ |\ external\ nullifier\ |\ pk]$）。然后为了索赔，他们揭示他们的外部无效器并 ZK 证明它来自匿名集中的一个信号量 ID。这大大缩小了匿名集，仅限于在该账户索赔之前选择加入信号量承诺的所有人。因此，可能需要一个单独的注册阶段，让人们承诺无效器以便为匿名集提供种子。这个交互性要求使得 zk 空投或更好的龙卷风现金构造（在用例部分）等应用变得更加困难。然而，由于哈希（就我们目前所知）在量子计算机上仍然很难，因此人们不太可能能够将你去匿名化。

最近的一个近似值显示，解决离散对数所需的 $2n^2$ 量子比特在大于 $n$ = 6 位素数时未能工作，这表明我们可能还需要几十年才能使其成为现实，而解决 RSA 所需的 $n^2$ 量子比特的预测在 10-40 年之间，这表明解决离散对数可能需要更长的时间。

我们希望人们为他们的应用选择适当的算法，以应对交互性-量子保密权衡，并希望包含这些信息能帮助人们为自己做出正确的选择。优先考虑短期保密的人，如 DAO 投票或年轻人的忏悔，他们在年老时可能不再关心，可能会优先考虑本文档的无效器构造，但举报人或记者可能会考虑信号量构造。

## 版权

通过 [CC0](../LICENSE.md) 放弃版权及相关权利。