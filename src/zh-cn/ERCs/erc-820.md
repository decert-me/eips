---
eip: 820
title: 伪自省注册合约
author: Jordi Baylina <jordi@baylina.cat>, Jacques Dafflon <jacques@dafflon.tech>
discussions-to: https://github.com/ethereum/EIPs/issues/820
status: 最终
type: 标准跟踪
category: ERC
requires: 165, 214
created: 2018-01-05
---

> :information_source: **[ERC-1820] 已取代 [ERC-820]。** :information_source:  
> [ERC-1820] 修复了 [ERC-165] 逻辑中的不兼容性，该不兼容性是由 Solidity 0.5 更新引入的。  
> 请查看 [官方公告][erc1820-annoucement]，以及关于 [bug][erc820-bug] 和 [修复][erc820-fix] 的评论。  
> 除此修复外，[ERC-1820] 在功能上等同于 [ERC-820]。
>
> :warning: 必须使用 [ERC-1820] 代替 [ERC-820]。 :warning:


## 简要总结

该标准定义了一个通用的注册智能合约，任何地址（合约或普通账户）都可以注册其支持的接口以及负责其实现的智能合约。

该标准与 [ERC-165] 保持向后兼容。

## 摘要

该标准定义了一个注册表，智能合约和普通账户可以发布它们实现的功能——无论是直接实现还是通过代理合约。

任何人都可以查询该注册表，以询问特定地址是否实现了给定接口，以及哪个智能合约处理其实现。

该注册表可以在任何链上部署，并在所有链上共享相同的地址。

最后 28 字节为零 (`0`) 的接口被视为 [ERC-165] 接口，该注册表将转发调用到合约以查看其是否实现了该接口。

该合约还充当 [ERC-165] 缓存，以减少 gas 消耗。

## 动机

在以太坊中定义伪自省的方式有不同的尝试。第一个是 [ERC-165]，其限制在于普通账户无法使用。第二个尝试是 [ERC-672]，它使用反向 [ENS]。使用反向 [ENS] 存在两个问题。首先，它不必要地复杂，其次，[ENS] 仍然是由多签控制的中心化合约。理论上，这个多签可以修改系统。

该标准比 [ERC-672] 简单得多，并且是 *完全* 去中心化的。

该标准还为所有链提供了 *唯一* 地址。因此解决了不同链上解析正确注册表地址的问题。

## 规范

### [ERC-820] 注册智能合约

> 这是 [ERC820 注册智能合约] 代码的精确副本。

``` solidity
/* ERC820 Pseudo-introspection Registry Contract
 * This standard defines a universal registry smart contract where any address
 * (contract or regular account) can register which interface it supports and
 * which smart contract is responsible for its implementation.
 *
 * Written in 2018 by Jordi Baylina and Jacques Dafflon
 *
 * To the extent possible under law, the author(s) have dedicated all copyright
 * and related and neighboring rights to this software to the public domain
 * worldwide. This software is distributed without any warranty.
 *
 * You should have received a copy of the CC0 Public Domain Dedication along
 * with this software. If not, see
 * <https://creativecommons.org/publicdomain/zero/1.0/>.
 *
 *    ███████╗██████╗  ██████╗ █████╗ ██████╗  ██████╗
 *    ██╔════╝██╔══██╗██╔════╝██╔══██╗╚════██╗██╔═████╗
 *    █████╗  ██████╔╝██║     ╚█████╔╝ █████╔╝██║██╔██║
 *    ██╔══╝  ██╔══██╗██║     ██╔══██╗██╔═══╝ ████╔╝██║
 *    ███████╗██║  ██║╚██████╗╚█████╔╝███████╗╚██████╔╝
 *    ╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚════╝ ╚══════╝ ╚═════╝
 *
 *    ██████╗ ███████╗ ██████╗ ██╗███████╗████████╗██████╗ ██╗   ██╗
 *    ██╔══██╗██╔════╝██╔════╝ ██║██╔════╝╚══██╔══╝██╔══██╗╚██╗ ██╔╝
 *    ██████╔╝█████╗  ██║  ███╗██║███████╗   ██║   ██████╔╝ ╚████╔╝
 *    ██╔══██╗██╔══╝  ██║   ██║██║╚════██║   ██║   ██╔══██╗  ╚██╔╝
 *    ██║  ██║███████╗╚██████╔╝██║███████║   ██║   ██║  ██║   ██║
 *    ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝
 *
 */
pragma solidity 0.4.24;
// IV is value needed to have a vanity address starting with `0x820`.
// IV: 9513

/// @dev The interface a contract MUST implement if it is the implementer of
/// some (other) interface for any address other than itself.
interface ERC820ImplementerInterface {
    /// @notice Indicates whether the contract implements the interface `interfaceHash` for the address `addr` or not.
    /// @param interfaceHash keccak256 hash of the name of the interface
    /// @param addr Address for which the contract will implement the interface
    /// @return ERC820_ACCEPT_MAGIC only if the contract implements `interfaceHash` for the address `addr`.
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);
}


/// @title ERC820 Pseudo-introspection Registry Contract
/// @author Jordi Baylina and Jacques Dafflon
/// @notice This contract is the official implementation of the ERC820 Registry.
/// @notice For more details, see https://eips.ethereum.org/EIPS/eip-820
contract ERC820Registry {
    /// @notice ERC165 Invalid ID.
    bytes4 constant INVALID_ID = 0xffffffff;
    /// @notice Method ID for the ERC165 supportsInterface method (= `bytes4(keccak256('supportsInterface(bytes4)'))`).
    bytes4 constant ERC165ID = 0x01ffc9a7;
    /// @notice Magic value which is returned if a contract implements an interface on behalf of some other address.
    bytes32 constant ERC820_ACCEPT_MAGIC = keccak256(abi.encodePacked("ERC820_ACCEPT_MAGIC"));

    mapping (address => mapping(bytes32 => address)) interfaces;
    mapping (address => address) managers;
    mapping (address => mapping(bytes4 => bool)) erc165Cached;

    /// @notice Indicates a contract is the `implementer` of `interfaceHash` for `addr`.
    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);
    /// @notice Indicates `newManager` is the address of the new manager for `addr`.
    event ManagerChanged(address indexed addr, address indexed newManager);

    /// @notice Query if an address implements an interface and through which contract.
    /// @param _addr Address being queried for the implementer of an interface.
    /// (If `_addr == 0` then `msg.sender` is assumed.)
    /// @param _interfaceHash keccak256 hash of the name of the interface as a string.
    /// E.g., `web3.utils.keccak256('ERC777Token')`.
    /// @return The address of the contract which implements the interface `_interfaceHash` for `_addr`
    /// or `0x0` if `_addr` did not register an implementer for this interface.
    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address) {
        address addr = _addr == 0 ? msg.sender : _addr;
        if (isERC165Interface(_interfaceHash)) {
            bytes4 erc165InterfaceHash = bytes4(_interfaceHash);
            return implementsERC165Interface(addr, erc165InterfaceHash) ? addr : 0;
        }
        return interfaces[addr][_interfaceHash];
    }

    /// @notice Sets the contract which implements a specific interface for an address.
    /// Only the manager defined for that address can set it.
    /// (Each address is the manager for itself until it sets a new manager.)
    /// @param _addr Address to define the interface for. (If `_addr == 0` then `msg.sender` is assumed.)
    /// @param _interfaceHash keccak256 hash of the name of the interface as a string.
    /// For example, `web3.utils.keccak256('ERC777TokensRecipient')` for the `ERC777TokensRecipient` interface.
    /// @param _implementer Contract address implementing _interfaceHash for _addr.
    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {
        address addr = _addr == 0 ? msg.sender : _addr;
        require(getManager(addr) == msg.sender, "Not the manager");

        require(!isERC165Interface(_interfaceHash), "Must not be a ERC165 hash");
        if (_implementer != 0 && _implementer != msg.sender) {
            require(
                ERC820ImplementerInterface(_implementer)
                    .canImplementInterfaceForAddress(_interfaceHash, addr) == ERC820_ACCEPT_MAGIC,
                "Does not implement the interface"
            );
        }
        interfaces[addr][_interfaceHash] = _implementer;
        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);
    }

    /// @notice Sets the `_newManager` as manager for the `_addr` address.
    /// The new manager will be able to call `setInterfaceImplementer` for `_addr`.
    /// @param _addr Address for which to set the new manager.
    /// @param _newManager Address of the new manager for `addr`.
    function setManager(address _addr, address _newManager) external {
        require(getManager(_addr) == msg.sender, "Not the manager");
        managers[_addr] = _newManager == _addr ? 0 : _newManager;
        emit ManagerChanged(_addr, _newManager);
    }

    /// @notice Get the manager of an address.
    /// @param _addr Address for which to return the manager.
    /// @return Address of the manager for a given address.
    function getManager(address _addr) public view returns(address) {
        // By default the manager of an address is the same address
        if (managers[_addr] == 0) {
            return _addr;
        } else {
            return managers[_addr];
        }
    }

    /// @notice Compute the keccak256 hash of an interface given its name.
    /// @param _interfaceName Name of the interface.
    /// @return The keccak256 hash of an interface name.
    function interfaceHash(string _interfaceName) external pure returns(bytes32) {
        return keccak256(abi.encodePacked(_interfaceName));
    }

    /* --- ERC165 Related Functions --- */
    /* --- Developed in collaboration with William Entriken. --- */

    /// @notice Updates the cache with whether the contract implements an ERC165 interface or not.
    /// @param _contract Address of the contract for which to update the cache.
    /// @param _interfaceId ERC165 interface for which to update the cache.
    function updateERC165Cache(address _contract, bytes4 _interfaceId) external {
        interfaces[_contract][_interfaceId] = implementsERC165InterfaceNoCache(_contract, _interfaceId) ? _contract : 0;
        erc165Cached[_contract][_interfaceId] = true;
    }

    /// @notice Checks whether a contract implements an ERC165 interface or not.
    /// The result may be cached, if not a direct lookup is performed.
    /// @param _contract Address of the contract to check.
    /// @param _interfaceId ERC165 interface to check.
    /// @return `true` if `_contract` implements `_interfaceId`, false otherwise.
    function implementsERC165Interface(address _contract, bytes4 _interfaceId) public view returns (bool) {
        if (!erc165Cached[_contract][_interfaceId]) {
            return implementsERC165InterfaceNoCache(_contract, _interfaceId);
        }
        return interfaces[_contract][_interfaceId] == _contract;
    }

    /// @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.
    /// @param _contract Address of the contract to check.
    /// @param _interfaceId ERC165 interface to check.
    /// @return `true` if `_contract` implements `_interfaceId`, false otherwise.
    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {
        uint256 success;
        uint256 result;

        (success, result) = noThrowCall(_contract, ERC165ID);
        if (success == 0 || result == 0) {
            return false;
        }

        (success, result) = noThrowCall(_contract, INVALID_ID);
        if (success == 0 || result != 0) {
            return false;
        }

        (success, result) = noThrowCall(_contract, _interfaceId);
        if (success == 1 && result == 1) {
            return true;
        }
        return false;
    }

    /// @notice Checks whether the hash is a ERC165 interface (ending with 28 zeroes) or not.
    /// @param _interfaceHash The hash to check.
    /// @return `true` if the hash is a ERC165 interface (ending with 28 zeroes), `false` otherwise.
    function isERC165Interface(bytes32 _interfaceHash) internal pure returns (bool) {
        return _interfaceHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0;
    }

    /// @dev Make a call on a contract without throwing if the function does not exist.
    function noThrowCall(address _contract, bytes4 _interfaceId)
        internal view returns (uint256 success, uint256 result)
    {
        bytes4 erc165ID = ERC165ID;

        assembly {
                let x := mload(0x40)               // Find empty storage location using "free memory pointer"
                mstore(x, erc165ID)                // Place signature at beginning of empty storage
                mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature

                success := staticcall(
                    30000,                         // 30k gas
                    _contract,                     // To addr
                    x,                             // Inputs are stored at location x
                    0x08,                          // Inputs are 8 bytes long
                    x,                             // Store output over input (saves space)
                    0x20                           // Outputs are 32 bytes long
                )

                result := mload(x)                 // Load the result
        }
    }
}

```

### 部署交易

以下是必须用于在任何链上部署智能合约的原始交易。

```
0xf90a2a8085174876e800830c35008080b909d7608060405234801561001057600080fd5b506109b7806100206000396000f30060806040526004361061008d5763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166329965a1d81146100925780633d584063146100bf5780635df8122f146100fc57806365ba36c114610123578063a41e7d5114610155578063aabbb8ca14610183578063b7056765146101a7578063f712f3e8146101e9575b600080fd5b34801561009e57600080fd5b506100bd600160a060020a036004358116906024359060443516610217565b005b3480156100cb57600080fd5b506100e0600160a060020a0360043516610512565b60408051600160a060020a039092168252519081900360200190f35b34801561010857600080fd5b506100bd600160a060020a036004358116906024351661055e565b34801561012f57600080fd5b506101436004803560248101910135610655565b60408051918252519081900360200190f35b34801561016157600080fd5b506100bd600160a060020a0360043516600160e060020a0319602435166106e3565b34801561018f57600080fd5b506100e0600160a060020a036004351660243561076d565b3480156101b357600080fd5b506101d5600160a060020a0360043516600160e060020a0319602435166107e7565b604080519115158252519081900360200190f35b3480156101f557600080fd5b506101d5600160a060020a0360043516600160e060020a03196024351661089c565b6000600160a060020a0384161561022e5783610230565b335b90503361023c82610512565b600160a060020a03161461029a576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b6102a38361091c565b156102f8576040805160e560020a62461bcd02815260206004820152601960248201527f4d757374206e6f74206265206120455243313635206861736800000000000000604482015290519081900360640190fd5b600160a060020a038216158015906103195750600160a060020a0382163314155b156104a15760405160200180807f4552433832305f4143434550545f4d414749430000000000000000000000000081525060130190506040516020818303038152906040526040518082805190602001908083835b6020831061038d5780518252601f19909201916020918201910161036e565b51815160209384036101000a6000190180199092169116179052604080519290940182900382207f249cb3fa000000000000000000000000000000000000000000000000000000008352600483018a9052600160a060020a0388811660248501529451909650938816945063249cb3fa936044808401945091929091908290030181600087803b15801561042057600080fd5b505af1158015610434573d6000803e3d6000fd5b505050506040513d602081101561044a57600080fd5b5051146104a1576040805160e560020a62461bcd02815260206004820181905260248201527f446f6573206e6f7420696d706c656d656e742074686520696e74657266616365604482015290519081900360640190fd5b600160a060020a03818116600081815260208181526040808320888452909152808220805473ffffffffffffffffffffffffffffffffffffffff19169487169485179055518692917f93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db15391a450505050565b600160a060020a03808216600090815260016020526040812054909116151561053c575080610559565b50600160a060020a03808216600090815260016020526040902054165b919050565b3361056883610512565b600160a060020a0316146105c6576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b81600160a060020a031681600160a060020a0316146105e557806105e8565b60005b600160a060020a03838116600081815260016020526040808220805473ffffffffffffffffffffffffffffffffffffffff19169585169590951790945592519184169290917f605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a43509190a35050565b60008282604051602001808383808284378201915050925050506040516020818303038152906040526040518082805190602001908083835b602083106106ad5780518252601f19909201916020918201910161068e565b6001836020036101000a038019825116818451168082178552505050505050905001915050604051809103902090505b92915050565b6106ed82826107e7565b6106f85760006106fa565b815b600160a060020a03928316600081815260208181526040808320600160e060020a031996909616808452958252808320805473ffffffffffffffffffffffffffffffffffffffff19169590971694909417909555908152600284528181209281529190925220805460ff19166001179055565b60008080600160a060020a038516156107865784610788565b335b91506107938461091c565b156107b85750826107a4828261089c565b6107af5760006107b1565b815b92506107df565b600160a060020a038083166000908152602081815260408083208884529091529020541692505b505092915050565b60008080610815857f01ffc9a70000000000000000000000000000000000000000000000000000000061093e565b9092509050811580610825575080155b1561083357600092506107df565b61084585600160e060020a031961093e565b909250905081158061085657508015155b1561086457600092506107df565b61086e858561093e565b90925090506001821480156108835750806001145b1561089157600192506107df565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108e4576108dd83836107e7565b90506106dd565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160088189617530fa9051909690955093505050505600a165627a7a723058204fc4461c9d5a247b0eafe0f9c508057bc0ad72bc24668cb2a35ea65850e10d3100291ba08208208208208208208208208208208208208208208208208208208208208200a00820820820820820820820820820820820820820820820820820820820820820
```

交易末尾的 `820` 字符串是签名的 `r` 和 `s`。根据这个确定性模式（由人生成），任何人都可以推断出没有人知道部署账户的私钥。

### 部署方法

该合约将使用无密钥部署方法进行部署——也称为 [Nick] 的方法——该方法依赖于一次性地址。（有关更多详细信息，请参见 [Nick 的文章]）。该方法的工作原理如下：

1. 生成一个从新随机账户部署合约的交易。
  - 此交易必须不使用 [EIP-155] 以便在任何链上工作。
  - 此交易必须具有相对较高的 gas 价格，以便在任何链上部署。在这种情况下，将设置为 100 Gwei。

2. 将交易签名的 `v`、`r`、`s` 设置为以下值：

   ```
   v: 27
   r: 0x8208208208208208208208208208208208208208208208208208208208208200
   s: 0x0820820820820820820820820820820820820820820820820820820820820820
   ```

这些 `r` 和 `s` 值——由重复的 `820` 字符串组成——是由人确定性生成的“随机数”。

   > `r` 和 `s` 的值必须各为 32 字节长——或 64 个十六进制字符。由于 `820` 长度为 3 个字符，而 3 不是 64 的因子，但它是 63 的因子，因此 `r` 和 `s` 值用一个额外字符进行填充。  
   > `s` 值前面加一个零 (`0`)。这个 `0` 前缀还保证 `s < secp256k1n ÷ 2 + 1`。  
   > `r` 值不能以零为前缀，因为交易将变得无效。相反，它以零 (`0`) 为后缀，这仍然符合条件 `s < secp256k1n`。

3. 我们恢复该交易的发送者，即一次性部署账户。

    > 因此我们获得一个可以广播该交易的账户，但我们也有保证，没有人知道该账户的私钥。

4. 向该一次性部署账户发送确切的 0.08 以太。

5. 广播部署交易。

此操作可以在任何链上完成，确保合约地址始终相同，并且没有人可以使用该地址与不同的合约。

### 一次性注册部署账户

```
0xE6C244a1C10Aa0085b0cf92f04cdaD947C2988b8
```

该账户是通过从其交易签名反向工程生成的。这样没有人知道私钥，但已知它是部署交易的有效签名者。

> 要部署注册表，必须首先向该账户发送 0.08 以太。

### 注册合约地址

```
0x820b586C8C28125366C998641B09DCbE7d4cBF06
```

该合约在其部署的每个链上都有上述地址。

<details>
<summary>原始元数据 <code>./contracts/ERC820Registry.sol</code></summary>

```json
{
  "compiler": {
    "version": "0.4.24+commit.e67f0147"
  },
  "language": "Solidity",
  "output": {
    "abi": [
      {
        "constant": false,
        "inputs": [
          {
            "name": "_addr",
            "type": "address"
          },
          {
            "name": "_interfaceHash",
            "type": "bytes32"
          },
          {
            "name": "_implementer",
            "type": "address"
          }
        ],
        "name": "setInterfaceImplementer",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [
          {
            "name": "_addr",
            "type": "address"
          }
        ],
        "name": "getManager",
        "outputs": [
          {
            "name": "",
            "type": "address"
          }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      },
      {
        "constant": false,
        "inputs": [
          {
            "name": "_addr",
            "type": "address"
          },
          {
            "name": "_newManager",
            "type": "address"
          }
        ],
        "name": "setManager",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [
          {
            "name": "_interfaceName",
            "type": "string"
          }
        ],
        "name": "interfaceHash",
        "outputs": [
          {
            "name": "",
            "type": "bytes32"
          }
        ],
        "payable": false,
        "stateMutability": "pure",
        "type": "function"
      },
      {
        "constant": false,
        "inputs": [
          {
            "name": "_contract",
            "type": "address"
          },
          {
            "name": "_interfaceId",
            "type": "bytes4"
          }
        ],
        "name": "updateERC165Cache",
        "outputs": [],
        "payable": false,
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [
          {
            "name": "_addr",
            "type": "address"
          },
          {
            "name": "_interfaceHash",
            "type": "bytes32"
          }
        ],
        "name": "getInterfaceImplementer",
        "outputs": [
          {
            "name": "",
            "type": "address"
          }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [
          {
            "name": "_contract",
            "type": "address"
          },
          {
            "name": "_interfaceId",
            "type": "bytes4"
          }
        ],
        "name": "implementsERC165InterfaceNoCache",
        "outputs": [
          {
            "name": "",
            "type": "bool"
          }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      },
      {
        "constant": true,
        "inputs": [
          {
            "name": "_contract",
            "type": "address"
          },
          {
            "name": "_interfaceId",
            "type": "bytes4"
          }
        ],
        "name": "implementsERC165Interface",
        "outputs": [
          {
            "name": "",
            "type": "bool"
          }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "name": "addr",
            "type": "address"
          },
          {
            "indexed": true,
            "name": "interfaceHash",
            "type": "bytes32"
          },
          {
            "indexed": true,
            "name": "implementer",
            "type": "address"
          }
        ],
        "name": "InterfaceImplementerSet",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "name": "addr",
            "type": "address"
          },
          {
            "indexed": true,
            "name": "newManager",
            "type": "address"
          }
        ],
        "name": "ManagerChanged",
        "type": "event"
      }
    ],
    "devdoc": {
      "author": "Jordi Baylina and Jacques Dafflon",
      "methods": {
        "getInterfaceImplementer(address,bytes32)": {
          "params": {
            "_addr": "Address being queried for the implementer of an interface. (If `_addr == 0` then `msg.sender` is assumed.)",
            "_interfaceHash": "keccak256 hash of the name of the interface as a string. E.g., `web3.utils.keccak256('ERC777Token')`."
          },
          "return": "The address of the contract which implements the interface `_interfaceHash` for `_addr` or `0x0` if `_addr` did not register an implementer for this interface."
        },
        "getManager(address)": {
          "params": {
            "_addr": "Address for which to return the manager."
          },
          "return": "Address of the manager for a given address."
        },
        "implementsERC165Interface(address,bytes4)": {
          "params": {
            "_contract": "Address of the contract to check.",
            "_interfaceId": "ERC165 interface to check."
          },
          "return": "`true` if `_contract` implements `_interfaceId`, false otherwise."
        },
        "implementsERC165InterfaceNoCache(address,bytes4)": {
          "params": {
            "_contract": "Address of the contract to check.",
            "_interfaceId": "ERC165 interface to check."
          },
          "return": "`true` if `_contract` implements `_interfaceId`, false otherwise."
        },
        "interfaceHash(string)": {
          "params": {
            "_interfaceName": "Name of the interface."
          },
          "return": "The keccak256 hash of an interface name."
        },
        "setInterfaceImplementer(address,bytes32,address)": {
          "params": {
            "_addr": "Address to define the interface for. (If `_addr == 0` then `msg.sender` is assumed.)",
            "_implementer": "Contract address implementing _interfaceHash for _addr.",
            "_interfaceHash": "keccak256 hash of the name of the interface as a string. For example, `web3.utils.keccak256('ERC777TokensRecipient')` for the `ERC777TokensRecipient` interface."
          }
        },
        "setManager(address,address)": {
          "params": {
            "_addr": "Address for which to set the new manager.",
            "_newManager": "Address of the new manager for `addr`."
          }
        },
        "updateERC165Cache(address,bytes4)": {
          "params": {
            "_contract": "Address of the contract for which to update the cache.",
            "_interfaceId": "ERC165 interface for which to update the cache."
          }
        }
      },
      "title": "ERC820 Pseudo-introspection Registry Contract"
    },
    "userdoc": {
      "methods": {
        "getInterfaceImplementer(address,bytes32)": {
          "notice": "Query if an address implements an interface and through which contract."
        },
        "getManager(address)": {
          "notice": "Get the manager of an address."
        },
        "implementsERC165Interface(address,bytes4)": {
          "notice": "Checks whether a contract implements an ERC165 interface or not. The result may be cached, if not a direct lookup is performed."
        },
        "implementsERC165InterfaceNoCache(address,bytes4)": {
          "notice": "Checks whether a contract implements an ERC165 interface or not without using nor updating the cache."
        },
        "interfaceHash(string)": {
          "notice": "Compute the keccak256 hash of an interface given its name."
        },
        "setInterfaceImplementer(address,bytes32,address)": {
          "notice": "Sets the contract which implements a specific interface for an address. Only the manager defined for that address can set it. (Each address is the manager for itself until it sets a new manager.)"
        },
        "setManager(address,address)": {
          "notice": "Sets the `_newManager` as manager for the `_addr` address. The new manager will be able to call `setInterfaceImplementer` for `_addr`."
        },
        "updateERC165Cache(address,bytes4)": {
          "notice": "Updates the cache with whether the contract implements an ERC165 interface or not."
        }
      }
    }
  },
  "settings": {
    "compilationTarget": {
      "./contracts/ERC820Registry.sol": "ERC820Registry"
    },
    "evmVersion": "byzantium",
    "libraries": {},
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": []
  },
  "sources": {
    "./contracts/ERC820Registry.sol": {
      "content": "/* ERC820 Pseudo-introspection Registry Contract\n * This standard defines a universal registry smart contract where any address\n * (contract or regular account) can register which interface it supports and\n * which smart contract is responsible for its implementation.\n *\n * Written in 2018 by Jordi Baylina and Jacques Dafflon\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <https://creativecommons.org/publicdomain/zero/1.0/>.\n *\n *    ███████╗██████╗  ██████╗ █████╗ ██████╗  ██████╗\n *    ██╔════╝██╔══██╗██╔════╝██╔══██╗╚════██╗██╔═████╗\n *    █████╗  ██████╔╝██║     ╚█████╔╝ █████╔╝██║██╔██║\n *    ██╔══╝  ██╔══██╗██║     ██╔══██╗██╔═══╝ ████╔╝██║\n *    ███████╗██║  ██║╚██████╗╚█████╔╝███████╗╚██████╔╝\n *    ╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚════╝ ╚══════╝ ╚═════╝\n *\n *    ██████╗ ███████╗ ██████╗ ██╗███████╗████████╗██████╗ ██╗   ██╗\n *    ██╔══██╗██╔════╝██╔════╝ ██║██╔════╝╚══██╔══╝██╔══██╗╚██╗ ██╔╝\n *    ██████╔╝█████╗  ██║  ███╗██║███████╗   ██║   ██████╔╝ ╚████╔╝\n *    ██╔══██╗██╔══╝  ██║   ██║██║╚════██║   ██║   ██╔══██╗  ╚██╔╝\n *    ██║  ██║███████╗╚██████╔╝██║███████║   ██║   ██║  ██║   ██║\n *    ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝\n *\n */\npragma solidity 0.4.24;\n// IV is value needed to have a vanity address starting with `0x820`.\n// IV: 9513\n\n/// @dev The interface a contract MUST implement if it is the implementer of\n/// some (other) interface for any address other than itself.\ninterface ERC820ImplementerInterface {\n    /// @notice Indicates whether the contract implements the interface `interfaceHash` for the address `addr` or not.\n    /// @param interfaceHash keccak256 hash of the name of the interface\n    /// @param addr Address for which the contract will implement the interface\n    /// @return ERC820_ACCEPT_MAGIC only if the contract implements `interfaceHash` for the address `addr`.\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);\n}\n\n\n/// @title ERC820 Pseudo-introspection Registry Contract\n/// @author Jordi Baylina and Jacques Dafflon\n/// @notice This contract is the official implementation of the ERC820 Registry.\n/// @notice For more details, see https://eips.ethereum.org/EIPS/eip-820\ncontract ERC820Registry {\n    /// @notice ERC165 Invalid ID.\n    bytes4 constant INVALID_ID = 0xffffffff;\n    /// @notice Method ID for the ERC165 supportsInterface method (= `bytes4(keccak256('supportsInterface(bytes4)'))`).\n    bytes4 constant ERC165ID = 0x01ffc9a7;\n    /// @notice Magic value which is returned if a contract implements an interface on behalf of some other address.\n    bytes32 constant ERC820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC820_ACCEPT_MAGIC\"));\n\n    mapping (address => mapping(bytes32 => address)) interfaces;\n    mapping (address => address) managers;\n    mapping (address => mapping(bytes4 => bool)) erc165Cached;\n\n    /// @notice Indicates a contract is the `implementer` of `interfaceHash` for `addr`.\n    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);\n    /// @notice Indicates `newManager` is the address of the new manager for `addr`.\n    event ManagerChanged(address indexed addr, address indexed newManager);\n\n    /// @notice Query if an address implements an interface and through which contract.\n    /// @param _addr Address being queried for the implementer of an interface.\n    /// (If `_addr == 0` then `msg.sender` is assumed.)\n    /// @param _interfaceHash keccak256 hash of the name of the interface as a string.\n    /// E.g., `web3.utils.keccak256('ERC777Token')`.\n    /// @return The address of the contract which implements the interface `_interfaceHash` for `_addr`\n    /// or `0x0` if `_addr` did not register an implementer for this interface.\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address) {\n        address addr = _addr == 0 ? msg.sender : _addr;\n        if (isERC165Interface(_interfaceHash)) {\n            bytes4 erc165InterfaceHash = bytes4(_interfaceHash);\n            return implementsERC165Interface(addr, erc165InterfaceHash) ? addr : 0;\n        }\n        return interfaces[addr][_interfaceHash];\n    }\n\n    /// @notice Sets the contract which implements a specific interface for an address.\n    /// Only the manager defined for that address can set it.\n    /// (Each address is the manager for itself until it sets a new manager.)\n    /// @param _addr Address to define the interface for. (If `_addr == 0` then `msg.sender` is assumed.)\n    /// @param _interfaceHash keccak256 hash of the name of the interface as a string.\n    /// For example, `web3.utils.keccak256('ERC777TokensRecipient')` for the `ERC777TokensRecipient` interface.\n    /// @param _implementer Contract address implementing _interfaceHash for _addr.\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {\n        address addr = _addr == 0 ? msg.sender : _addr;\n        require(getManager(addr) == msg.sender, \"Not the manager\");\n\n        require(!isERC165Interface(_interfaceHash), \"Must not be a ERC165 hash\");\n        if (_implementer != 0 && _implementer != msg.sender) {\n            require(\n                ERC820ImplementerInterface(_implementer)\n                    .canImplementInterfaceForAddress(_interfaceHash, addr) == ERC820_ACCEPT_MAGIC,\n                \"Does not implement the interface\"\n            );\n        }\n        interfaces[addr][_interfaceHash] = _implementer;\n        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);\n    }\n\n    /// @notice Sets the `_newManager` as manager for the `_addr` address.\n    /// The new manager will be able to call `setInterfaceImplementer` for `_addr`.\n    /// @param _addr Address for which to set the new manager.\n    /// @param _newManager Address of the new manager for `addr`.\n    function setManager(address _addr, address _newManager) external {\n        require(getManager(_addr) == msg.sender, \"Not the manager\");\n        managers[_addr] = _newManager == _addr ? 0 : _newManager;\n        emit ManagerChanged(_addr, _newManager);\n    }\n\n    /// @notice Get the manager of an address.\n    /// @param _addr Address for which to return the manager.\n    /// @return Address of the manager for a given address.\n    function getManager(address _addr) public view returns(address) {\n        // By default the manager of an address is the same address\n        if (managers[_addr] == 0) {\n            return _addr;\n        } else {\n            return managers[_addr];\n        }\n    }\n\n    /// @notice Compute the keccak256 hash of an interface given its name.\n    /// @param _interfaceName Name of the interface.\n    /// @return The keccak256 hash of an interface name.\n    function interfaceHash(string _interfaceName) external pure returns(bytes32) {\n        return keccak256(abi.encodePacked(_interfaceName));\n    }\n\n    /* --- ERC165 Related Functions --- */\n    /* --- Developed in collaboration with William Entriken. --- */\n\n    /// @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n    /// @param _contract Address of the contract for which to update the cache.\n    /// @param _interfaceId ERC165 interface for which to update the cache.\n    function updateERC165Cache(address _contract, bytes4 _interfaceId) external {\n        interfaces[_contract][_interfaceId] = implementsERC165InterfaceNoCache(_contract, _interfaceId) ? _contract : 0;\n        erc165Cached[_contract][_interfaceId] = true;\n    }\n\n    /// @notice Checks whether a contract implements an ERC165 interface or not.\n    /// The result may be cached, if not a direct lookup is performed.\n    /// @param _contract Address of the contract to check.\n    /// @param _interfaceId ERC165 interface to check.\n    /// @return `true` if `_contract` implements `_interfaceId`, false otherwise.\n    function implementsERC165Interface(address _contract, bytes4 _interfaceId) public view returns (bool) {\n        if (!erc165Cached[_contract][_interfaceId]) {\n            return implementsERC165InterfaceNoCache(_contract, _interfaceId);\n        }\n        return interfaces[_contract][_interfaceId] == _contract;\n    }\n\n    /// @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n    /// @param _contract Address of the contract to check.\n    /// @param _interfaceId ERC165 interface to check.\n    /// @return `true` if `_contract` implements `_interfaceId`, false otherwise.\n    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {\n        uint256 success;\n        uint256 result;\n\n        (success, result) = noThrowCall(_contract, ERC165ID);\n        if (success == 0 || result == 0) {\n            return false;\n        }\n\n        (success, result) = noThrowCall(_contract, INVALID_ID);\n        if (success == 0 || result != 0) {\n            return false;\n        }\n\n        (success, result) = noThrowCall(_contract, _interfaceId);\n        if (success == 1 && result == 1) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice Checks whether the hash is a ERC165 interface (ending with 28 zeroes) or not.\n    /// @param _interfaceHash The hash to check.\n    /// @return `true` if the hash is a ERC165 interface (ending with 28 zeroes), `false` otherwise.\n    function isERC165Interface(bytes32 _interfaceHash) internal pure returns (bool) {\n        return _interfaceHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0;\n    }\n\n    /// @dev Make a call on a contract without throwing if the function does not exist.\n    function noThrowCall(address _contract, bytes4 _interfaceId)\n        internal view returns (uint256 success, uint256 result)\n    {\n        bytes4 erc165ID = ERC165ID;\n\n        assembly {\n                let x := mload(0x40)               // Find empty storage location using \"free memory pointer\"\n                mstore(x, erc165ID)                // Place signature at beginning of empty storage\n                mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature\n\n                success := staticcall(\n                    30000,                         // 30k gas\n                    _contract,                     // To addr\n                    x,                             // Inputs are stored at location x\n                    0x08,                          // Inputs are 8 bytes long\n                    x,                             // Store output over input (saves space)\n                    0x20                           // Outputs are 32 bytes long\n                )\n\n                result := mload(x)                 // Load the result\n        }\n    }\n}\n",
      "keccak256": "0x8eecce3912a15087b3f5845d5a74af7712c93d0a8fcd6f2d40f07ed5032022ab"
    }
  },
  "version": 1
}
```

</details>

### 接口名称

任何接口名称都使用 `keccak256` 哈希并发送到 `getInterfaceImplementer()`。

如果接口是标准的一部分，最佳实践是明确说明接口名称并链接到此发布的 [ERC-820]，以便其他人不必来这里查找这些规则。

为了方便，注册表提供了一个在链上计算哈希的函数：

``` solidity
function interfaceHash(string _interfaceName) public pure returns(bytes32)
```

计算给定名称的接口的 keccak256 哈希。

> <small>**标识符:** `65ba36c1`</small>  
> <small>**参数**</small>  
> <small>`_interfaceName`: 接口的名称。</small>  
> <small>**返回:** 接口名称的 `keccak256` 哈希。</small>

#### **批准的 ERC**

如果接口是批准的 ERC 的一部分，则必须命名为 `ERC###XXXXX`，其中 `###` 是 ERC 的编号，XXXXX 应该是接口的 CamelCase 名称。该接口的含义应在指定的 ERC 中定义。

示例：

- `keccak256("ERC20Token")`
- `keccak256("ERC777Token")`
- `keccak256("ERC777TokensSender")`
- `keccak256("ERC777TokensRecipient")`

#### **[ERC-165] 兼容接口**

> 与 [ERC-165] 的兼容性，包括 [ERC165 缓存]，是与 [William Entriken] 共同设计和开发的。

任何最后 28 字节为零 (`0`) 的接口应被视为 [ERC-165] 接口。

**[ERC-165] 查找**

任何人都可以通过调用以下两个函数之一，明确检查合约是否实现了 [ERC-165] 接口：

``` solidity
function implementsERC165Interface(address _contract, bytes4 _interfaceId) public view returns (bool)
```

检查合约是否实现了 [ERC-165] 接口。

*注意*: 结果是缓存的。如果缓存过期，必须通过调用 `updateERC165Cache` 更新。（有关更多详细信息，请参见 [ERC165 缓存]。）

> <small>**标识符:** `f712f3e8`</small>  
> <small>**参数**</small>  
> <small>`_contract`: 要检查的合约地址。</small>  
> <small>`_interfaceId`: 要检查的 [ERC-165] 接口。</small>  
> <small>**返回:** 如果 `_contract` 实现了 `_interfaceId`，则返回 `true`，否则返回 false。</small>

``` solidity
function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool)
```

检查合约是否实现了 [ERC-165] 接口，而不使用或更新缓存。

> <small>**标识符:** `b7056765`</small>  
> <small>**参数**</small>  
> <small>`_contract`: 要检查的合约地址。</small>  
> <small>`_interfaceId`: 要检查的 [ERC-165] 接口。</small>  
> <small>**返回:** 如果 `_contract` 实现了 `_interfaceId`，则返回 `true`，否则返回 false。</small>

**[ERC-165] 缓存** <a id="erc165-cache"></a>

是否合约实现了 [ERC-165] 接口可以手动缓存以节省 gas。

如果合约动态更改其接口并依赖于 [ERC-820] 注册表的 [ERC-165] 缓存，则必须手动更新缓存——没有自动缓存失效或缓存更新。理想情况下，合约在更改其接口时应自动更新缓存。然而，任何人都可以代表合约更新缓存。

缓存更新必须使用 `updateERC165Cache` 函数完成：

``` solidity
function updateERC165Cache(address _contract, bytes4 _interfaceId) public
```

> <small>**标识符:** `a41e7d51`</small>  
> <small>**参数**</small>  
> <small>`_contract`: 要更新缓存的合约地址。</small>  
> <small>`_interfaceId`: 要更新缓存的 [ERC-165] 接口。</small>

#### **私有用户定义接口**

该方案是可扩展的。您可以自定义接口名称并提高意识，以便让其他人实现它，然后检查这些实现。请尽情享受，但请注意，您不得与上述保留名称冲突。

### 为地址设置接口

任何地址要将合约设置为接口实现，必须调用 [ERC-820] 注册表的以下函数：

``` solidity
function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) public
```

为地址设置实现特定接口的合约。

只有为该地址定义的 `manager` 可以设置它。（每个地址都是其自己的管理者，详见 [manager] 部分以获取更多详细信息。）

*注意*: 如果 `_addr` 和 `_implementer` 是两个不同的地址，则：

- `_implementer` 必须实现 `ERC820ImplementerInterface`（详见下文）。
- 在 `_implementer` 上调用 `canImplementInterfaceForAddress`，使用给定的 `_addr` 和 `_interfaceHash` 必须返回 `ERC820_ACCEPT_MAGIC` 值。

*注意*: `_interfaceHash` 不能是 [ERC-165] 接口——它不能以 28 个零 (`0`) 结尾。

*注意*: `_addr` 可以为 `0`，则假定为 `msg.sender`。此默认值简化了通过多签进行的交互，其中签名的交易数据在多签实例的地址无论如何都是常量。

> <small>**标识符:** `29965a1d`</small>  
> <small>**参数**</small>  
> <small>`_addr`: 要为其定义接口的地址（如果 `_addr == 0` 则假定为 `msg.sender`）</small>  
> <small>`_interfaceHash`: 接口名称的 `keccak256` 哈希，作为字符串，例如 `web3.utils.keccak256('ERC777TokensRecipient')` 用于 ERC777TokensRecipient 接口。</small>  
> <small>`_implementer`: 为 `_addr` 实现 `_interfaceHash` 的合约。</small>

### 获取地址的接口实现

任何人都可以查询 [ERC-820] 注册表，以获取代表某个地址实现接口的合约地址，使用 `getInterfaceImplementer` 函数。

``` solidity
function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) public view returns (address)
```

查询一个地址是否实现了一个接口，以及通过哪个合约。

*注意*: 如果 `_interfaceHash` 的最后 28 字节为零 (`0`)，则前 4 字节被视为 [ERC-165] 接口，注册表将转发调用到 `_addr` 的合约，以查看其是否实现了 [ERC-165] 接口（`_interfaceHash` 的前 4 字节）。注册表还将缓存 [ERC-165] 查询以减少 gas 消耗。任何人都可以调用 `erc165UpdateCache` 函数以更新合约是否实现接口。

*注意*: `_addr` 可以为 `0`，则假定为 `msg.sender`。此默认值与 `setInterfaceImplementer` 函数的行为一致，并简化了通过多签进行的交互，其中签名的交易数据在多签实例的地址无论如何都是常量。

> <small>**标识符:** `aabbb8ca`</small>  
> <small>**参数**</small>  
> <small>`_addr`: 正在查询的接口实现者的地址。（如果 `_addr == 0` 则假定为 `msg.sender`。）</small>  
> <small>`_interfaceHash`: 接口名称的 keccak256 哈希，作为字符串。例如 `web3.utils.keccak256('ERC777Token')`</small>  
> <small>**返回:** 实现接口 `_interfaceHash` 的合约地址，针对 `_addr`，如果 `_addr` 没有为此接口注册实现者，则返回 `0x0`。</small>


### 接口实现 (`ERC820ImplementerInterface`)

``` solidity
interface ERC820ImplementerInterface {
    /// @notice Indicates whether the contract implements the interface `interfaceHash` for the address `addr`.
    /// @param addr Address for which the contract will implement the interface
    /// @param interfaceHash keccak256 hash of the name of the interface
    /// @return ERC820_ACCEPT_MAGIC only if the contract implements `ìnterfaceHash` for the address `addr`.
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) public view returns(bytes32);
}
```

任何被注册为特定地址接口实现的合约必须实现该接口。此外，如果它代表不同地址实现接口，则合约必须实现上述 `ERC820ImplementerInterface`。

``` solidity
function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) view public returns(bytes32);
```

指示合约是否为给定地址 (`addr`) 实现接口 (`interfaceHash`)。

如果合约为给定地址 (`addr`) 实现接口 (`interfaceHash`)，则在使用 `addr` 和 `interfaceHash` 调用时必须返回 `ERC820_ACCEPT_MAGIC`。如果它不为给定地址 (`addr`) 实现接口 (`interfaceHash`)，则不得返回 `ERC820_ACCEPT_MAGIC`。

> <small>**标识符:** `f0083250`</small>  
> <small>**参数**</small>  
> <small>`interfaceHash`: 实现的接口的哈希</small>  
> <small>`addr`: 接口实现的地址</small>  
> <small>**返回:** 仅当合约为地址 `addr` 实现 `interfaceHash` 时返回 `ERC820_ACCEPT_MAGIC`。</small>

特殊值 `ERC820_ACCEPT_MAGIC` 被定义为字符串 `"ERC820_ACCEPT_MAGIC"` 的 `keccka256` 哈希。

``` solidity
bytes32 constant ERC820_ACCEPT_MAGIC = keccak256("ERC820_ACCEPT_MAGIC");
```

> 返回 `ERC820_ACCEPT_MAGIC` 而不是布尔值的原因是为了防止合约未能实现 `canImplementInterfaceForAddress` 但实现了一个不会抛出异常的回退函数。在这种情况下，由于 `canImplementInterfaceForAddress` 不存在，因此调用回退函数时不会抛出异常并返回 `1`。因此看起来好像 `canImplementInterfaceForAddress` 返回了 `true`。

### 管理者

地址（普通账户或合约）的管理者是唯一被允许为该地址注册接口实现的实体。默认情况下，任何地址都是其自己的管理者。

管理者可以通过在注册表合约上调用 `setManager` 将其角色转移给另一个地址，指定要转移管理者的地址和新管理者的地址。

**`setManager` 函数**

``` solidity
function setManager(address _addr, address _newManager) public
```

将 `_newManager` 设置为 `_addr` 地址的管理者。

新管理者将能够调用 `_addr` 的 `setInterfaceImplementer`。

如果 `_newManager` 为 `0x0`，则管理者将重置为 `_addr` 本身作为管理者。

> <small>**标识符:** `5df8122f`</small>  
> <small>**参数**</small>  
> <small>`_addr`: 要为其设置新管理者的地址。</small>  
> <small>`_newManager`: `_addr` 的新管理者地址。（传递 `0x0` 将管理者重置为 `_addr`。）</small>

**`getManager` 函数**

``` solidity
function getManager(address _addr) public view returns(address)
```

获取地址的管理者。

> <small>**标识符:** `3d584063`</small>  
> <small>**参数**</small>  
> <small>`_addr`: 要返回管理者的地址。</small>  
> <small>**返回:** 给定地址的管理者地址。</small>

## 理由

该标准为任何类型的地址（外部拥有和合约）提供了一种实现接口的方式，并可能将接口的实现委托给代理合约。将实现委托给代理合约对于外部拥有账户是必要的，并且有助于避免重新部署现有合约，例如多签和 DAO。

注册表还可以充当 [ERC-165] 缓存，以便在查找合约是否实现特定 [ERC-165] 接口时节省 gas。该缓存故意保持简单，没有自动缓存更新或失效。任何人都可以通过调用 `updateERC165Cache` 函数轻松安全地更新任何接口和任何合约的缓存。

注册表使用无密钥部署方法进行部署，依赖于一次性部署地址，以确保没有人控制注册表，从而确保信任。

## 向后兼容性

该标准与 [ERC-165] 向后兼容，因为两种方法可以在不相互冲突的情况下实现。

## 测试用例

请查看 [jbaylina/ERC820] 仓库以获取完整的测试套件。

## 实现

实现可在仓库中找到：[jbaylina/ERC820]。

## 版权
版权及相关权利通过 [CC0](../LICENSE.md) 放弃。

[EIP-155]: ./eip-155.md
[ERC-165]: ./eip-165.md
[ERC-672]: https://github.com/ethereum/EIPs/issues/672
[ERC-820]: ./eip-820.md
[ERC820 注册智能合约]: https://github.com/jbaylina/ERC820/blob/master/contracts/ERC820Registry.sol
[manager]: #manager
[lookup]: #get-an-implementation-of-an-interface-for-an-address
[ERC165 缓存]: #erc165-cache
[Nick 的文章]: https://medium.com/@weka/how-to-send-ether-to-11-440-people-187e332566b7
[jbaylina/ERC820]: https://github.com/jbaylina/ERC820
[Nick]: https://github.com/Arachnid/
[William Entriken]: https://github.com/fulldecent
[ENS]: https://ens.domains/
[ERC-1820]: ./eip-1820.md
[erc1820-annoucement]: https://github.com/ethereum/EIPs/issues/820#issuecomment-464109166
[erc820-bug]: https://github.com/ethereum/EIPs/issues/820#issuecomment-452465748
[erc820-fix]: https://github.com/ethereum/EIPs/issues/820#issuecomment-454021564