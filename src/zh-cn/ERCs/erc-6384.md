---
eip: 6384
title: 可读的离线签名
description: 一种检索 EIP-712 类型和结构化数据的人类可读描述的方法。
author: Tal Be'ery <tal@zengo.com>, RoiV (@DeVaz1)
discussions-to: https://ethereum-magicians.org/t/eip-6384-readable-eip-712-signatures/12752
status: Stagnant
type: Standards Track
category: ERC
created: 2023-01-08
requires: 712
---

## 摘要

本 EIP 引入了 `evalEIP712Buffer` 函数，该函数接受一个 [EIP-712](./eip-712.md) 缓冲区并返回一个人类可读的文本描述。

## 动机

Web3 离线签名的使用案例正在获得关注，并在多个领先协议（例如 OpenSea）和标准 [EIP-2612](./eip-2612.md) 中得到应用，主要是因为它提供了无费用的体验。
攻击者已知积极且成功地滥用此类离线签名，利用用户盲目签署离线消息的事实，因为这些消息并不人类可读。
虽然 [EIP-712](./eip-712.md) 在其标题中最初声明“人类可读”是其目标之一，但最终并未兑现其承诺，EIP-712 消息对普通用户而言不可理解。

在一个例子中，受害者浏览一个恶意钓鱼网站。它请求受害者签署一条消息，将他们的 NFT 代币在 OpenSea 平台上出售，几乎是免费的。

一些流行钱包实现的用户界面并未传达签署此类交易的实际含义。

在本提案中，我们提供了一种安全且可扩展的方法，通过利用其绑定的智能合约为 EIP-712 消息带来真正的人类可读性。
因此，一旦实施此 EIP，钱包可以将其用户体验从当前状态：

![](../assets/eip-6384/media/MiceyMask-non-compliant.png)

提升到更清晰的用户体验：

![](../assets/eip-6384/media/ZenGo-EIP-compliant-warning.png)

所提议的解决方案通过允许钱包查询 `verifyingContract` 来解决可读性问题。保持 EIP-712 消息描述尽可能准确的激励是对齐的，因为描述的责任现在由合约承担，该合约：

- 确切知道消息的含义（并且可能可以重用处理此消息的代码，当其在链上接收时）
- 本质上有动力提供最佳解释以防止可能的欺诈
- 不涉及需要信任的第三方
- 维持无费用的客户体验，因为添加的功能处于“查看”模式，不需要链上执行和费用。
- 维持 Web3 的可组合性特性

## 规范

本文档中的关键字“必须”、“必须不”、“要求”、“应”、“应不”、“应该”、“应该不”、“推荐”、“可以”和“可选”应按 RFC 2119 中的描述进行解释。

EIP-712 已正式将离线签名绑定到合约，使用 `verifyingContract` 参数。我们建议向此类合约添加一个“查看”函数（`"stateMutability":"view"`），该函数返回此特定离线缓冲区的可读描述。

```solidity
/**
 * @dev Returns the expected result of the offchain message.
*/

     function evalEIP712Buffer(bytes32 domainHash, string memory primaryType, bytes memory typedDataBuffer)
     external
     view
     returns (string[] memory) {
   ...

}
```

**每个合规合约必须实现此函数。**

使用此函数，钱包可以将提议的离线签名提交给合约，并将结果呈现给用户，使他们能够享受与其离线消息等效的“链上模拟”体验。

此函数将具有一个众所周知的名称和签名，因此无需更新 EIP-712 结构。

### 函数的输入

函数的输入：

- `domainHash` 是 EIP-712 的 domainSeparator，一个哈希的 `eip712Domain` 结构。
- `primaryType` 是 EIP-712 的 `primaryType`。
- `typedDataBuffer` 是 EIP-712 完整消息的一部分 ABI 编码消息。

### 函数的输出

函数的输出是一个字符串数组。钱包应将其显示给最终用户。钱包可以选择用附加数据增强返回的字符串（例如，将合约地址解析为其名称）。

字符串不应格式化（例如，不应包含 HTML 代码），钱包应将此字符串视为不受信任的输入并相应处理其渲染。

### 对于不打算在链上使用的 EIP-712 消息的支持

如果 `verifyingContract` 未包含在 EIP-712 domain separator 中，钱包不得使用此 EIP 检索人类可读描述。在这种情况下，钱包应回退到其原始 EIP-712 显示。

## 理由

- 我们选择将 `typeDataBuffer` 参数实现为 ABI 编码，因为这是一种通用的将数据传递给合约的方式。替代方案是传递 `typedData` 结构，这并不通用，因为它要求合约指定消息数据。
- 我们选择返回一个字符串数组而不是单个字符串，因为存在消息由多个部分组成的潜在情况。例如，在同一 `typedDataBuffer` 中进行多资产转移的情况下，建议合约在单独的字符串中描述每次转移，以便钱包可以单独显示每次转移。

### 替代解决方案

#### 第三方服务：

目前，用户的最佳选择是依赖一些第三方解决方案，这些方案将提议的消息作为输入并向用户解释其预期含义。这种方法是：

- 不可扩展：第三方提供者需要学习所有此类专有消息
- 不一定正确：解释基于第三方对原始消息作者的解释
- 引入了对第三方的不必要依赖，这可能具有一些操作、安全和隐私影响。

#### 域名绑定

另外，钱包可以将域名绑定到签名。即，仅接受来自其 `name`（由 EIP-712 定义）包含在 `eip712Domain` 中的 web2 域的 EIP-712 消息。然而，这种方法有以下缺点：

- 它破坏了 Web3 的可组合性，因为现在其他 dapp 无法与此类消息交互
- 不保护来自指定 web2 域的坏消息，例如，当 web2 域被黑客攻击时
- 一些当前的连接器，如 WalletConnect，不允许钱包验证 web2 域的真实性

## 向后兼容性

对于不支持的合约，钱包将默认显示他们今天所显示的内容。
不支持的钱包将不会调用此函数，并将默认显示他们今天所显示的内容。

## 参考实现

参考实现可以在 [这里](../assets/eip-6384/implementation/src/MyToken/MyToken.sol) 找到。
这个玩具示例展示了一个支持此 EIP 的 [EIP-20](./erc-20.md) 合约如何实现 EIP-712 对“transferWithSig”功能的支持（这是对 Permit 的非标准变体，因为此 EIP 的重点是允许非标准 EIP-712 缓冲区的可读性）。
为了说明此 EIP 在某些实际用例中的可用性，实际 OpenSea 的 SeaPort EIP-712 的辅助函数也在 [这里](../assets/eip-6384/implementation/src/SeaPort/SeaPort712ParserHelper.sol) 实现。

## 安全考虑

### 威胁模型：

攻击是由一个恶意的 web2 界面（“dapp”）促进的，该界面为旨在被合法合约消费的 EIP-712 格式消息提供了错误的参数。因此，消息由攻击者控制，无法信任，然而合约由合法方控制，可以信任。
攻击者打算稍后在链上使用该签名的 EIP-712 消息，并通过攻击者构造的交易进行。如果后续的链上交易是由受害者发送的，那么常规的交易模拟就足够了。

流氓合约的情况无关紧要，因为这样的流氓合约已经可以在不需要 EIP-712 格式消息的情况下进行攻击。

话虽如此，流氓合约可能会试图滥用此功能，以发送一些恶意构造的字符串，从而利用钱包在渲染字符串时的漏洞。因此，钱包应将此字符串视为不受信任的输入，并相应地处理其渲染。

### 提议解决方案的分析

解释由相关合约控制，该合约由合法方控制。攻击者必须指定相关合约地址，否则将不被接受。因此，攻击者无法通过此方法创建虚假的解释。
请注意，如果解释是签名消息的一部分，则将由攻击者控制，因此对安全目的无关紧要。

由于添加到合约的功能具有“view”修饰符，它无法更改链上状态，也不会损害合约的现有功能。

## 版权

版权及相关权利通过 [CC0](../LICENSE.md) 放弃。