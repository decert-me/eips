---
eip: 1078
title: 使用 ENS 子域的通用登录/注册
author: Alex Van de Sande <avsa@ethereum.org>
discussions-to: https://ethereum-magicians.org/t/erc1077-and-1078-the-magic-of-executable-signed-messages-to-login-and-do-actions/351
status: Stagnant
type: Standards Track
category: ERC
created: 2018-05-04
requires: 191, 681, 725, 1077
---

## 摘要

本文提出了一种方法，用以用最小的以太坊原生方案替代通常的注册/登录设计模式，该方案不需要密码、备份私钥或输入助记词。从用户的角度来看，这将与他们已经习惯的二次身份验证模式非常相似（不依赖于中央服务器），但对于 dapp 开发者来说，这需要一种新的思维方式来处理以太坊交易。

## 简要总结

用户的唯一标识符是一个同时实现身份和可执行签名消息 ERC 的合约。用户不需要直接提供此地址，只需提供指向它的 ENS 名称。这些类型的合约由可以签署表示意图的私钥间接控制，这些意图随后由第三方（或去中心化的部署网络）部署到合约中。

在这种情况下，设备“登录”到应用程序使用身份，意味着设备将在本地生成一个私钥，然后请求授权将该密钥添加为该身份的签名者之一，并赋予一组特定的权限。由于该私钥仅用于签署消息，因此不需要持有以太、代币或资产，如果丢失，可以简单地用一个新密钥替换——用户的资金保存在身份合约中。

在这种情况下，以太坊账户的使用方式更类似于身份验证令牌，而不是唯一密钥。

登录过程如下：

#### 1) 请求用户提供名称

该过程的第一步是请求用户提供指向其身份的 ENS 名称。如果用户尚未设置登录，应用程序应——如果他们有集成的身份管理器——提供一个选项以提供子域或他们拥有的名称。

**用户体验提示：** 提供此界面的方式有很多，应用程序可以提前询问他们是否想要注册/登录，或者直接要求他们输入名称。请注意，由于验证用户名是否存在是微不足道的，因此您的应用程序应优雅地适应这一点，而不要求用户输入两次他们的名称。如果他们请求注册并提供一个已存在的名称，则询问他们是否想要使用该名称登录，或者如果他们请求连接到一个现有名称但输入了一个不存在的名称，则显示一个友好的警报并询问他们是否想要现在创建该名称。不要强迫他们在两个不同的字段中输入相同的名称两次。

#### 2.a) 创建新身份

如果用户没有身份，应用程序应提供为他们创建一个身份的选项。每个应用程序必须拥有一个或多个他们控制的域，以便可以按需创建即时子域。因此，应用程序将在后台执行以下操作：

1. 生成一个私钥，并将其保存在设备或浏览器上，尽可能安全。
2. 创建（或设置）一个支持 ERC720 和 ERC1077 的身份合约
3. 将步骤 1 中创建的私钥注册为合约的*唯一*管理员密钥（应用程序不得添加任何应用程序控制的密钥，除非作为恢复选项 - 见第 5 点）
4. 注册请求的子域并将其所有权转移给合约（虽然应用程序控制主域并可能保留随意重新分配的选项，但子域的所有权应属于身份，从而允许他们转移它）
5. （可选）在合约上注册一种恢复方法，以便用户在主密钥丢失的情况下重新获得对合约的访问。

所有这些步骤可以设计为在单个以太坊交易中设置。由于此步骤不是免费的，应用程序保留向用户收取注册费用的权利，或要求用户以应用程序选择的抗 Sybil 的方式进行验证（验证码、设备 ID 注册、工作证明等）

用户不应被迫等待交易确认时间。相反，在应用程序的某处有一个指示器显示进度，然后允许用户正常与应用程序交互。在最初的几分钟内，他们不太可能需要身份，如果出现问题（用户名同时被注册），您可以询问用户采取行动。

**实现说明：** 为了节省 gas，一些步骤可以提前完成。应用程序可以在 gas 价格低时自动部署少量合约，并将其所有主要变量设置为 0xFFFFFF...FFFFF。这些应被视为“空闲”，当用户注册一个时，他们将获得释放链上空间的 gas 折扣。这还具有允许用户选择合约地址/图标的附加好处。

#### 2.b) 连接到现有身份

如果用户想要连接到现有身份，则应用程序首先需要了解它将请求的权限级别：

**管理者** 最高级别，允许密钥发起或签署更改身份本身的交易，例如添加或删除密钥。只有在集成身份管理器的情况下，应用程序才应要求此级别。根据身份的设置，可能需要更多密钥的签名才能部署这些交易。

**操作** 此级别允许密钥发起或签署其他地址的交易。它可以移动资金、以太、资产等。只有在它是一个通用钱包或用于发送以太坊交易的浏览器时，应用程序才应要求此级别的权限。根据身份的设置，可能需要更多密钥的签名才能部署这些交易。

**加密** 较低级别没有权利发起任何交易，但可以用于在特定实例或链下签名消息中代表用户。对于游戏、聊天或社交媒体应用程序，这是理想的权限级别，因为它们可以用于签署移动、发送消息等。如果游戏需要实际资金（例如，以资金作为赌注开始游戏），则仍应使用加密级别，然后要求用户的主钱包/浏览器使用以太坊 URI 标准签署消息。

一旦确定所需的级别，应用程序必须采取以下步骤：

1. **生成一个私钥**，并将其保存在设备或浏览器上，尽可能安全。
2. **查询 ens** 以确定身份的现有地址
3. **生成字节码** 用于调用函数 `addKey(PUBLICKEY,LEVEL)` 的交易。
4. **在 whisper 通道上广播交易请求** 或其他去中心化的对等网络。此步骤的详细信息需要进一步讨论
1. **如果可用 web3**，则尝试调用 web3.eth.sendTransaction。这可以是自动的或由用户操作提示。
1. **尝试调用 URI** 如果应用程序支持 [EIP 的交易请求 URL 格式](./eip-681.md)，则尝试调用此 URI。这可以是自动的或由用户操作提示。
1. **显示二维码**：带有 EIP681 格式的 URL。该二维码可以点击以尝试重试其他选项，但应最后进行：如果步骤 1 成功，用户应在其兼容设备上收到通知，而无需使用二维码。
这是一个 EIP681 兼容地址的示例，用于在应用中添加本地生成的公钥：

`ethereum:bob.example.eth?function=addKey(address='0xdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef',uint=1)`

如果添加新密钥需要多个签名，或者接收该请求的应用专门处理可执行的签名消息且自身没有以太币，则应遵循下一节关于如何请求交易的步骤。

如前所述，用户不应被迫等待交易确认时间。相反，应在应用中某处提供一个指示器，显示进度，然后允许用户正常与您的应用互动。



#### 3) 请求交易

在步骤 2 之后，最终结果应是您的应用应拥有用户的身份地址、他们的主要 ENS 名称和一个私钥，其公账户在身份中列为他们的密钥之一，角色为管理者、操作或加密。现在可以开始使用该信息来签名和执行交易。

**并非所有交易都需要在链上**，实际上，签名消息的最常见用途应为链下。如果您有一个聊天应用，例如，可以使用本地密钥签名消息并将其发送给其他方，他们可以查询身份合约以查看该密钥是否确实来自用户。如果您有一个涉及资金的游戏，则只有第一次移动资金和设置初始游戏的交易需要由身份执行：在每个回合，玩家可以签名当前棋盘状态的哈希，最后两个回合可以用来确定赢家。请注意，密钥可以随时被撤销，因此您的应用应考虑到这一点，例如在游戏开始时保存所有密钥。仅需要这种较低权限级别的密钥，应设置为级别 4（加密）。

一旦您决定确实需要链上交易，请遵循以下步骤：

1. **确定 TO、FROM、VALUE 和 DATA**。这些是任何以太坊交易的基本要素。`from` 是您希望交易从中部署的兼容合约。
2. **检查所需的权限级别**：如果 `to` 和 `from` 字段是同一合约，即如果交易需要身份对自身进行操作（例如，添加或移除密钥），则需要级别 1（管理），否则为 2（操作）。验证您的应用拥有的密钥是否对应所需级别。
3. **通过调用 `requiredSignatures(uint level)` 验证所需的密钥数量**。
4. **确定 gasLimit**：估算所需交易的 gas 成本，并添加一个余量（推荐：添加 100k gas）。
5. **确定 gasToken 和 gasPrice**：考虑网络拥堵和用户将要支付的代币的市场价格，检查当前 gas 价格。对于以太币，将 gasToken 留为 0。如果您自己部署并在其他地方补贴费用，则将 gasPrice 留为 0。
6. **通过遵循该标准签署可执行的签名交易**。

在拥有所有签名的可执行消息后，我们需要将其部署到链上。如果交易只需要单个签名，则应用提供者可以自行部署。将交易发送到 `from` 地址，并尝试调用 `executeSigned` 函数，使用您刚刚收集的参数和签名。

如果交易需要收集更多签名或应用没有可部署的服务器，则应用应遵循以下步骤：

1. **在 whisper 通道或其他去中心化的对等网络上广播交易**。此步骤的详细信息需要进一步讨论。
2. **如果可用 web3**，则尝试调用 web3.eth.personal_sign。这可以是自动的，也可以由用户操作提示。
3. **显示二维码**：包含签名交易和新数据以供签名。该二维码可以点击以尝试重试其他选项，但应最后进行：如果步骤 1 成功，用户应在其兼容设备上收到通知，而无需使用二维码。

目标是通过 whisper 持续广播签名，直到能够收集所有消息的节点愿意部署它们。

一旦您遵循上述步骤，监视交易池中对该地址的任何交易，然后将用户带到您的应用中。一旦您看到所需的交易，可以停止显示二维码并继续使用应用，同时保持某种指示，表明交易正在进行中。订阅所需合约的 `ExecutedSigned` 事件：一旦您看到带有 nonce 的交易，可以称其为成功。如果您看到具有相同或更高 nonce（或时间戳）的不同交易，则认为交易永久失败并重新启动该过程。


### 实现

目前没有此实现的工作示例，但许多开发者已表示有兴趣采用它。本节将在未来进行编辑以反映这一点。

### 结论和未来改进

该方案将允许更轻量的应用，不需要持有以太币，并且可以在设备上保持解锁的私钥，以便能够发送消息和玩游戏，而无需每次都请求用户提示。需要更多工作来标准化常见的去中心化消息传递协议以及用于部署节点的开源工具，以创建一个去中心化和可靠的消息部署层。

### 参考文献

* [Universal Logins talk at UX Unconf, Toronto](https://www.youtube.com/watch?v=qF2lhJzngto)

## 版权
版权及相关权利通过 [CC0](../LICENSE.md) 放弃。