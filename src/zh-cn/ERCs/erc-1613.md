---
eip: 1613
title: 燃气站网络
author: Yoav Weiss <yoav@tabookey.com>, Dror Tirosh <dror@tabookey.com>, Alex Forshtat <alex@tabookey.com>
discussions-to: https://github.com/yoav-tabookey/EIPs/issues/1
status: 停滞
type: 标准跟踪
category: ERC
created: 2018-11-18
requires: 1077
---

## 简单总结
通过允许合约接受“ [收费电话](https://en.wikipedia.org/wiki/Collect_call) ”，使智能合约（例如去中心化应用）对非以太用户可访问，支付来电费用。 
让合约在公开可访问的频道（例如网页 URL 或 whisper 地址）上“监听”。 
激励节点运行“燃气站”以促进此过程。 
不需要网络更改，且合约更改最小。

## 摘要
与去中心化应用的通信目前需要支付 ETH 作为燃气费，这限制了去中心化应用的采用仅限于以太用户。 
因此，合约所有者可能希望支付燃气费以增加用户获取，或让用户通过法币支付燃气费。 
或者，第三方可能希望补贴某些合约的燃气费用。 
如 [EIP-1077](./eip-1077.md) 中所述的解决方案可以允许来自没有 ETH 的地址的交易。

燃气站网络是一个符合 [EIP-1077](./eip-1077.md) 的努力，通过创建激励机制让节点运行燃气站，在这里无燃气交易可以“加油”。 
它将实现细节从去中心化应用维护者和用户中抽象出来，使现有去中心化应用易于接受“收费电话”。

该网络由一个所有参与的去中心化应用合约信任的公共合约和一个去中心化的中继节点（燃气站）网络组成，激励它们在非以太接口（如网页或 whisper）上监听， 
支付交易费用并由该合约进行补偿。 该信任合约可以被任何人验证，系统在其他方面是无信任的。 
只要至少有一个诚实的燃气站，燃气站就无法审查交易。 试图破坏系统的行为可以在链上证明，违规者可以受到惩罚。

## 动机

* 通过以下方式增加智能合约的用户采用：
    * 消除用户获取 ETH 的麻烦。交易仍然由 ETH 支付，但费用可以由去中心化应用承担或通过其他方式由用户支付。
    * 消除直接与区块链交互的需要，同时保持去中心化和抗审查性。 
      合约可以在多个公共频道上“监听”，用户可以通过一般允许的常用协议与合约交互，即使在限制环境中也是如此。
* 以太坊节点获得收入来源，而无需采矿设备。 整个网络从更多节点中受益。
* 不需要协议更改。燃气站网络通过智能合约自组织，去中心化应用通过实现接口与网络交互。

## 规范

该系统由一个 `RelayHub` 单例合约、继承 `RelayRecipient` 合约的参与合约、去中心化的 `Relay` 节点网络（即燃气站）和用户应用（例如移动或网页）组成，通过中继与合约交互。

`RelayHub` 的角色：

* 维护活动中继的列表。发送者为每个交易从此列表中选择一个 `Relay`。选择过程在下面讨论。
* 调解所有中继与合约之间的通信。
* 为合约提供真实的 msg.sender 和 msg.data 的可信版本。
* 持有中继放置的 ETH 抵押金。强制执行最低抵押金大小。 中继注销后，抵押金可以在冷却期后提取。
* 持有合约支付的 ETH 预付款，并用它们来补偿中继。
* 通过将可证明的违规中继的抵押金给予提供证明的地址来惩罚违规中继，从而保持中继的诚实。
* 为中继提供一种免费的方式，以了解它们是否会因未来的交易而获得补偿。

`Relay` 节点的角色：

* 维护一个小额 ETH 热钱包，以支付燃气费。
* 为用户应用提供公共接口，以通过 https 或 whisper 等渠道发送无燃气交易。
* 在 `RelayHub` 中发布其公共接口及其价格（作为实际交易燃气费用的乘数）。
* 可选地通过 RelayHub 监控其他中继的回滚交易，捕捉违规中继并索取其抵押金。 这可以由任何人完成，而不仅仅是中继。

实现 `RelayRecipient` 合约：

* 知道 `RelayHub` 的地址，并信任它提供有关交易的信息。
* 在 `RelayHub` 中维护少量 ETH 燃气预付款存款。可以由 `RelayRecipient` 合约直接支付，或由去中心化应用的所有者代表 `RelayRecipient` 地址支付。 
  去中心化应用所有者负责确保下一笔交易的余额充足，如果出现问题可以停止存款，从而限制系统漏洞的潜在滥用。在 DAO 用例中，保持足够存款将由 DAO 逻辑负责。
* 在所有地方使用 `getSender()` 和 `getMessageData()` 而不是 `msg.sender` 和 `msg.data`。 `RelayRecipient` 提供这些函数，并从 `RelayHub` 获取信息。
* 实现一个 `acceptRelayedCall(address relay, address from, bytes memory encodedFunction, uint gasPrice, uint transactionFee, bytes memory approval)` 视图函数，仅在愿意接受交易并为其支付时返回 **零**。 
  `acceptRelayedCall` 由 `RelayHub` 作为视图函数调用，当 `Relay` 查询时，以及在实际交易期间。 如果 **非零**，则交易会回滚，且 `Relay` 仅在 `acceptRelayedCall` 返回 **零** 时获得交易补偿（无论成功与否）。 `acceptRelayedCall()` 实现的一些示例：
    * 受信任的去中心化应用成员的白名单。
    * 由去中心化应用所有者维护的注册用户的资产负债表。用户通过信用卡或其他非 ETH 方式支付去中心化应用，并在 `RelayRecipient` 资产负债表中获得信用。 
      用户的费用永远不会超过他们获得的信用。
    * 去中心化应用可以向交易发送者提供一条称为 `approval` 的签名消息并进行验证。
    * 用于新用户入驻的已知交易的白名单。这允许某些匿名调用，并且容易受到 Sybil 攻击。 
      因此，它应与限制的 gasPrice 和受信任的中继白名单结合使用，以减少中继创建虚假交易并窃取去中心化应用预付燃气存款的激励。 
      允许匿名入驻交易的去中心化应用可能会受益于注册自己的 `Relay` 并仅接受来自该 `Relay` 的匿名交易，而其他交易可以从任何中继接受。 
      或者，去中心化应用也可以通过应用下面攻击/缓解部分中建议的方法来使用资产负债表方法进行入驻。   
* 实现 `preRelayedCall(address relay, address from, bytes memory encodedFunction, uint transactionFee) returns (bytes32)`。此方法在交易被中继之前调用。默认情况下，它不执行任何操作。
  
* 实现 `postRelayedCall(address relay, address from, bytes memory encodedFunction, bool success, uint usedGas, uint transactionFee, bytes32 preRetVal)`。此方法在交易被中继后调用。默认情况下，它不执行任何操作。
这两种方法可以以特定于 dapp 的方式向用户收费。

以下是流程中使用的术语的词汇表：

* `RelayHub` - RelayHub 单例合约，供所有人使用。
* `Recipient` - 实现 `RelayRecipient` 的合约，接受来自 RelayHub 合约的中继交易并支付传入交易的费用。
* `Sender` - 一个具有有效密钥对但没有 ETH 来支付 gas 的外部地址。
* `Relay` - 持有 ETH 的外部地址的节点，列在 RelayHub 中，并为费用将交易从 Senders 中继到 RelayHub。

![序列图](../assets/eip-1613/sequence.png)

注册/刷新 `Relay` 的过程：

* Relay 开始作为 web 应用（或在其他通信渠道上）监听。
* 如果是第一次启动（尚未生成密钥），为 Relay 的地址生成一对密钥。
* 如果 Relay 的地址没有足够的资金支付 gas（例如，因为刚刚生成），Relay 将保持不活动状态，直到其拥有者为其提供资金。
* Relay 的拥有者为其提供资金。
* Relay 的拥有者通过调用 `RelayHub.stake(address relay, uint unstakeDelay)` 将所需的抵押金发送到 `RelayHub`。
* `RelayHub` 将 `owner` 和 `unstake delay` 放入以 `relay` 地址为索引的中继映射中。
* Relay 调用 `RelayHub.registerRelay(uint transactionFee, string memory url)`，传入中继的 `transaction fee`（作为交易 gas 成本的乘数）和传入交易的 URL。
* `RelayHub` 确保 Relay 有足够的抵押金。
* `RelayHub` 将 `transaction fee` 放入中继映射中。
* `RelayHub` 触发事件 `RelayAdded(Relay, owner, transactionFee, relayStake, unstakeDelay, url)`。
* Relay 启动一个计时器，每 6000 个区块执行一次 `keepalive` 交易。
* `Relay` 进入休眠状态，等待签名请求。

发送中继交易的过程：

* `Sender` 从 RelayHub 的列表中选择一个活跃的 `Relay`，通过查看 `RelayHub` 的 `RelayAdded` 事件，并根据自己的标准进行排序。选择可能基于以下因素的组合：
    * Relay 发布的交易费用。
    * Relay 的抵押金大小和锁定时间。
    * 最近的中继交易（通过 `RelayHub` 的 `TransactionRelayed` 事件可见）。
    * 可选地，发送者应用程序本身或其后端持有的声誉/黑名单/白名单，按每个应用程序的基础（不属于 gas 站网络的一部分）。
* Sender 准备交易，包含 Sender 的地址、接收者地址、实际交易数据、Relay 的交易费用、gas 价格、gas 限制、来自 `RelayHub.nonces` 的当前 nonce、RelayHub 的地址和 Relay 的地址，然后进行签名。
* Sender 验证 `RelayHub.balances[recipient]` 是否持有足够的 ETH 来支付 Relay 的费用。
* Sender 验证 `Relay.balance` 是否有足够的 ETH 来发送交易。
* Sender 读取 Relay 的当前 `nonce` 值并决定 `max_nonce` 参数。
* Sender 将签名的交易和元数据发送到 Relay 的 Web 界面。
* `Relay` 用零 ETH 值的交易包装该交易到 `RelayHub`。
* `Relay` 用其密钥签署包装交易以支付 gas。
* `Relay` 验证：
    * 交易的接收者合约在提交时会接受此交易，通过调用 `RelayHub.canRelay()`，这是一个视图函数，检查接收者的 `acceptRelayedCall`，也是一个视图函数，说明它是否愿意接受费用。
    * 交易的 nonce 与 `RelayHub.nonces[sender]` 匹配。
    * 交易中的中继地址与 Relay 的地址匹配。
    * 交易的接收者在 `RelayHub` 中存入足够的 ETH 来支付交易费用。
    * Relay 有足够的 ETH 来支付交易所需的 gas。
    * `max_nonce` 的值高于当前 Relay 的 `nonce`。
* 如果 Relay 的任何检查失败，它将向发送者返回错误，并且不继续。
* Relay 将签名的包装交易提交到区块链。
* Relay 立即将签名的包装交易返回给发送者。此步骤在攻击/缓解部分中讨论。
* `Sender` 接收包装交易并验证：
    * 这是一个有效的对 `RelayHub` 的中继调用，来自 Relay 的地址。
    * 交易的以太坊 nonce 与 Relay 的当前 nonce 匹配。
    * 交易的以太坊 nonce 小于或等于 `max_nonce`。
    * `Relay` 有足够的资金来支付。
    * 包装交易是有效的，并由 `sender` 签名。
    * 接收者合约在 `RelayHub.balances` 中有足够的资金来支付交易中声明的 Relay 费用。
* 如果发送者的任何检查失败，它将返回选择新的 Relay。发送者也可以向其后端提交对无响应中继的报告，或将其保存在本地，以便在未来交易中降低该中继的优先级。
* `Sender` 还可以通过任何以太坊节点将原始包装交易提交到区块链，而无需支付 gas。
  由于网络的待处理交易中已经存在相同的交易，因此此提交可能会被忽略，但重复提交没有坏处，以确保其发生。
  此步骤并非严格必要，原因在攻击/缓解部分中讨论，但可能会加快速度。
* `Sender` 监控区块链，等待交易被挖掘。
  交易已被验证，具有 Relay 的当前 nonce，因此挖掘必须成功，除非 Relay 提交了另一笔（不同的）交易，具有相同的 nonce。
  如果由于这种攻击而挖掘失败，发送者可以通过另一个中继调用 `RelayHub.penalizeRepeatedNonce`，以收回奖励并销毁违规中继的剩余抵押金，然后返回选择新的 Relay 进行交易。
  请参见下面的攻击/缓解部分的讨论。
* `RelayHub` 接收交易：
    * 记录 `gasleft()` 作为 `initialGas` 以便后续支付。
    * 验证交易是从注册的中继发送的。
    * 验证内部交易的签名与其声明的来源（发送者的密钥）匹配。
    * 验证交易中写入的中继地址与 msg.sender 匹配。
    * 验证交易的 `nonce` 与 `RelayHub.nonces` 中声明的来源的 nonce 匹配。
    * 调用接收者的 `acceptRelayedCall` 函数，询问它是否会接受交易。如果不接受，将发出状态为 `CanRelayFailed` 的 `TransactionRelayed`，并且 `chargeOrCanRelayStatus` 将包含 `acceptRelayedCall` 的返回值。在这种情况下，Relay 不会获得报酬，因为它有责任在释放交易之前检查 `RelayHub.canRelay`。
    * 调用接收者的 `preRelayedCall` 函数。如果此调用回滚，将发出状态为 `PreRelayedFailed` 的 `TransactionRelayed`。
    * 将交易发送到接收者。如果此调用回滚，将发出状态为 `RelayedCallFailed` 的 `TransactionRelayed`。
      在调用 `call()` 时，`RelayHub` 保留足够的 gas 以便进行后续处理。接收者可能会耗尽 gas，但 `RelayHub` 永远不会耗尽。
      `RelayHub` 还在 `msg.data` 的末尾发送发送者的地址，以便 `RelayRecipient.getSender()` 能够提取真实的发送者，并信任它，因为交易来自已知的 `RelayHub` 地址。
* 接收者合约处理交易。
* `RelayHub` 调用接收者的 `postRelayedCall`。
* `RelayHub` 检查调用的返回值，并发出 `TransactionRelayed(address relay, address from, address to, bytes4 selector, uint256 status, uint256 chargeOrCanRelayStatus)`。
* `RelayHub` 增加 `RelayHub.nonces[sender]`。
* `RelayHub` 将 ETH 余额从接收者转移到 `Relay.owner`，以支付交易费用，基于测量的交易成本。
  关于中继支付的说明：中继根据实际使用的 gas 获得报酬，无论接收者是否回滚。
  中继遭受损失的唯一情况是 `canRelay` 返回非零值，因为中继有责任在提交之前验证此视图函数。
  任何其他回滚都会被捕获并支付。请参见下面的攻击/缓解部分。
* `Relay` 跟踪它发送的交易，并等待 `TransactionRelayed` 事件以查看费用。
  如果交易回滚并未支付，这意味着接收者的 `acceptRelayedCall()` 函数不一致，`Relay` 将拒绝对该接收者的服务一段时间（如果经常发生，则无限期列入黑名单）。
  请参见下面的攻击/缓解部分。
将 `Relay` 关闭的过程：

* Relay 的所有者（最初为其提供资金的地址）调用 `RelayHub.removeRelayByOwner(Relay)`。
* `RelayHub` 确保发送者确实是 Relay 的所有者，然后移除 `Relay`，并发出 `RelayRemoved(Relay)` 事件。
* `RelayHub` 开始倒计时以释放所有者的质押。
* `Relay` 收到其 `RelayRemoved` 事件。
* `Relay` 将其所有剩余的 ETH 发送给其所有者。
* `Relay` 关闭。
* 一旦所有者的撤回延迟结束，所有者调用 `RelayHub.unstake()`，并提取质押。

## 理由
气体站网络设计的理由是两个需求集合的组合：易于采用和稳健性。

为了易于采用，设计目标是：

* 无需网络更改。
* 对合约、应用程序和框架的最小更改。

稳健性要求转化为去中心化和抗攻击能力。气体站网络是去中心化的，我们必须假设任何实体都可能攻击系统中的其他实体。

具体来说，我们考虑了以下类型的攻击：

* 针对单个发送者的拒绝服务攻击，即交易审查。
* 针对单个中继的拒绝服务和财务攻击。
* 针对单个合约的拒绝服务和财务攻击。
* 针对整个网络的拒绝服务攻击，无论是通过攻击现有实体，还是通过引入任意数量的恶意实体。

#### 攻击与缓解措施

##### 攻击：中继尝试通过不签署交易或以其他方式忽略用户请求来审查交易。
中继预计会立即将签名的交易返回给发送者。
发送者不需要等待交易被挖掘，并立即知道其请求是否已被处理。
如果中继在几秒钟内未返回签名交易，发送者将取消操作，断开连接，并切换到另一个中继。
它还会在其私有存储中将中继标记为无响应，以避免在不久的将来使用它。

因此，中继通过这种攻击造成的最大损害是一次性延迟几秒钟。过一段时间后，发送者将完全避免使用它。

##### 攻击：中继尝试通过签署交易、将其返回给发送者，但从未将其放入区块链来审查交易。
此攻击将适得其反，并不会审查交易。
发送者可以通过任何节点将中继签名的交易作为原始交易提交到区块链，因此交易确实发生，
但中继可能并不知情，因此会陷入一个坏的 nonce，这将破坏其下一个交易。

##### 攻击：中继尝试通过签署交易，但发布具有相同 nonce 的不同交易来审查交易。
重用 nonce 是中继执行的唯一无法在 http 请求期间几秒钟内检测到的拒绝服务攻击。
它只会在具有相同 nonce 的恶意交易被挖掘并触发 `RelayHub.TransactionRelayed` 事件时被检测到。
然而，攻击将适得其反，并使中继失去其全部质押。

发送者拥有来自中继的签名交易，nonce 为 N，并且还获得了来自区块链的 nonce 为 N 的已挖掘交易，也由中继签名。
这证明中继对发送者进行了拒绝服务攻击。
发送者调用 `RelayHub.penalizeRepeatedNonce(bytes transaction1, bytes transaction2)`，验证攻击，没收中继的质押，
并将一半发送给发出 `penalizeRepeatedNonce` 调用的发送者。另一半质押通过发送到 `address(0)` 被销毁。销毁是为了防止作弊的中继有效地惩罚自己并逃避损失。
然后，发送者继续选择一个新的中继并发送原始交易。

这种攻击的结果是在发送交易时延迟几个区块（直到攻击被检测到），但中继被移除并失去其全部质押。
扩大这种攻击将是极其昂贵的，实际上对发送者和诚实的中继来说是相当有利可图的。

##### 攻击：中继尝试通过签署交易，但使用高于其当前 nonce 的 nonce。
在此攻击中，中继确实创建并返回了一个完全有效的交易，但在中继填补 nonce 中的“缺失”交易之前，该交易将不会被挖掘。
这可能会无限期延迟某些交易的中继。为了缓解这一点，发送者在其签名请求中包含一个 `max_nonce` 参数。
建议比当前 nonce 高 2-3，以允许中继处理几笔交易。

当发送者收到中继签署的交易时，他验证所使用的 nonce 是否有效，如果无效，客户端将忽略该中继并使用其他中继来中继给定交易。因此，这种攻击不会引入实际延迟。

##### 攻击：Dapp 试图通过实现不一致的 acceptRelayedCall() 并使用多个发送者地址生成昂贵的交易，从而烧毁中继资金，进而对中继进行拒绝服务攻击并降低其盈利能力。
在此攻击中，合约设置了不一致的 acceptRelayedCall（例如，对偶数区块返回零，对奇数区块返回非零），并利用它通过未支付的交易耗尽中继资源。
中继可以在事后轻松检测到这一点。
如果交易未支付，中继知道接收合约的 acceptRelayedCall 行为不一致，因为中继在发送交易之前已验证其视图函数。
这可能是由于视图调用和交易之间合约状态发生变化的罕见竞争条件的结果，但如果发生得太频繁，中继将列入黑名单并拒绝为其提供交易服务。
每个违规合约只能对中继造成小损害（例如 2-3 笔交易的成本），然后被列入黑名单。

中继还可以查看接收者在区块链上的历史，寻找过去未支付的交易（被 RelayHub 撤回而未支付），并拒绝对高失败率合约提供服务。
如果一个合约对几个中继造成了这种小损失，所有中继将停止为其服务，因此它无法造成进一步的损害。

这种攻击无法扩展，因为创建恶意合约的成本与其对网络造成的损害在同一数量级。
造成足够的损害以耗尽所有中继的资源将是极其昂贵的。

通过要求 Dapp 在被服务之前提供质押，并强制执行撤回延迟，可以使攻击变得更加不切实际，
因此攻击者必须筹集大量 ETH，以便同时创建足够的恶意合约并攻击中继。
这种保护可能是过度的，因为无论如何攻击都无法扩展。

##### 攻击：用户试图通过注册自己的中继并向 Dapp 发送昂贵的交易来抢劫 Dapp。
如果恶意发送者通过发送无意义/撤回的交易反复滥用接收者，并导致接收者为无所获的中继支付费用，
则接收者有责任将该发送者列入黑名单，并使其 acceptRelayedCall 函数对该发送者返回非零。
收集调用通常不适用于接收者未知的匿名发送者。
利用气体站网络的 Dapp 应该有办法在其系统中列入恶意用户的黑名单，以防止 Sybil 攻击。
一种简单的方法来缓解这种 Sybil 攻击是，dapp 允许用户使用信用卡购买信用，并在 dapp 合约中为其账户充值，因此 acceptRelayedCall() 仅对拥有足够信用的用户返回零，并在为用户中继交易时从用户的余额中扣除支付给中继的金额。通过这种方法，攻击者只能消耗自己的资源，而不是 dapp 的资源。

这种方法的一个变体，适用于免费 dapp（不向用户收费，并希望为用户的交易支付费用），是在其网页界面用户创建过程中要求输入验证码，或使用 Google/Facebook 账户登录，这限制了攻击者开设多个 Google/Facebook 账户的能力。只有通过该过程的用户才能在 RelayRecipient 中获得信用。这种 Sybil 攻击的发生率将太低，无法造成任何实际损害。

##### 攻击：攻击者试图通过注册许多不可靠的中继来降低网络可用性。
注册中继需要在 RelayHub 中放置抵押金，并且只有在中继注销并经过较长的冷却期（例如一个月）后，才能提取抵押金。

每个不可靠的中继只能对发送者造成几秒钟的延迟，然后它会被发送者列入黑名单，如上面的第一个攻击所述。在造成这种小延迟并被列入黑名单后，攻击者必须等待一个月才能重新使用资金发起另一个不可靠的中继。与此同时，启动足够多的不可靠中继以造成明显的网络延迟将因所需的抵押金而变得极其昂贵，即使如此，所有这些中继也将在短时间内被列入黑名单。

##### 攻击：攻击者试图重放一个中继的交易。
交易包括一个随机数。RelayHub 为每个发送者维护一个随机数（计数器）。具有错误随机数的交易会被 RelayHub 撤销。每个交易只能被中继一次。

##### 攻击：用户不执行从中继者接收到的原始交易，从而阻止所有由该中继者签名的后续交易的执行
用户实际上并不需要执行原始交易。用户能够执行就足够了。中继和发送者之间的关系是相互不信任的。上述过程激励中继执行交易，因此用户不需要等待实际的挖矿来确认交易已被执行。

一旦中继返回签名交易，这应该立即发生，中继也会被激励在链上执行它，以便推进其随机数并处理下一个交易。用户可以（但不必）也执行该交易。要理解为什么这种攻击不可行，请考虑签名交易返回给发送者后可能出现的四种情况：

1. 中继执行交易，而用户不执行。在这种情况下，交易被执行，因此没有问题。这就是本攻击中描述的情况。
2. 中继不执行交易，但用户执行。与情况 1 类似，交易被执行，因此没有问题。
3. 两者都执行交易。交易在待处理交易池中是相同的，因此交易只会被执行一次。没有问题。
4. 两者都不执行交易。在这种情况下，交易没有被执行，但中继被卡住。它无法使用下一个随机数处理下一个交易，因为其随机数在链上没有被推进。它也无法使用当前随机数处理下一个交易，因为用户可以证明有两个不同的交易由同一个中继签名，且随机数相同。用户可以利用这一点来获取中继的随机数。因此，除非中继执行交易，否则它将被卡住。

正如这个矩阵所示，中继在将交易返回给用户后，*始终* 被激励去执行交易，以便最终处于情况 #1 或 #3，并避免风险 #4。这只是一个承诺中继完成其工作的方式，而不需要用户等待链上确认。

## 向后兼容性

燃气站网络作为智能合约和外部实体实现，不需要任何网络更改。

添加燃气站网络支持的 dapp 与其现有应用/用户保持向后兼容。新增的方法在现有方法之上应用，因此现有应用无需进行更改。

## 实现

一个可工作的 [**燃气站网络**](https://github.com/tabookey-dev/tabookey-gasless) 实现正在 **TabooKey** 开发中。它由 `RelayHub`、`RelayRecipient`、`web3 hooks`、在 `geth` 中的燃气站实现以及使用燃气站网络的示例 dapp 组成。

## 版权
版权及相关权利通过 [CC0](../LICENSE.md) 放弃。