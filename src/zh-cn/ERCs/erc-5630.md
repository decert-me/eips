---
eip: 5630
title: 加密/解密的新方法
description: 定义了使用以太坊钱包进行加密和解密的规范。
author: Firn Protocol (@firnprotocol), Fried L. Trout, Weiji Guo (@weijiguo)
discussions-to: https://ethereum-magicians.org/t/eip-5630-encryption-and-decryption/10761
status: 草案
type: 标准跟踪
category: ERC
created: 2022-09-07
---


## 摘要

本 EIP 提出了使用以太坊密钥进行加密和解密的新方法。该 EIP 仅使用 `secp256k1` 曲线，并提出了两个新的 RPC 方法：`eth_getEncryptionPublicKey` 和 `eth_performECDH`。这两个方法结合起来，允许用户接收加密和执行解密（分别）。我们要求钱包仅执行核心 ECDH 操作，将 ECIES 操作留给实现者（不过我们确实建议一个标准化的 ECIES 版本）。相比之下，之前的 EIP 在两个不同的曲线（即 `secp256k1` 和 `ec25519`）上使用相同的密钥进行签名和加密，并硬编码了特定版本的 ECIES。

## 动机

我们讨论了一些激励示例。一个主要动机是在以太坊上进行直接地址加密。使用我们的 EIP，可以直接向某个目标接收者发送加密消息，而无需与该接收者建立先前的直接通道。（请注意，在此 EIP 中，我们仅标准化加密过程——即密文的生成——而不标准化如何确切地发送链上消息。在实践中，理想情况下，将为此目的设置智能合约基础设施；如果没有，加密者可以利用每个标准转账中可用的原始 `data` 字段。）

我们讨论第二种示例。在某种常见的设计模式中，dApp 代表用户生成一个新的密钥。值得关注的是，如果 dApp 可以将此密钥加密为用户控制的公钥，而该公钥的私钥恰好位于用户的 HD 钱包层次结构中，而不是强迫用户独立存储、保护和备份该密钥，然后将生成的密文发布到安全存储（例如链上）。这种设计模式允许 dApp/用户将新密钥的安全性建立在用户现有 HD 钱包种子短语的安全性之上，而用户已经为保护和存储该短语付出了努力。这比强迫用户直接存储和管理新密钥的用户体验负担要小得多（这可能会导致资金丢失）。我们注意到，上述设计模式今天被各种 dApp（例如 Tornado Cash）使用。

## 规范

我们在此描述我们的方法；我们在下面的 **理由** 部分将我们的方法与之前的 EIP 进行比较。在整个过程中，我们参考了 Daniel R. L. Brown 的 SEC 1：椭圆曲线密码学。

我们对签名和加密都使用 `secp256k1` 曲线。
对于加密，我们使用 ECIES。我们指定钱包仅执行敏感的 ECDH 操作。这使得实现者可以随意选择自己的 ECIES 变体。

我们建议所有二进制数据都序列化为以 `0x` 为前缀的十六进制字符串。此外，我们使用以 `0x` 为前缀的十六进制字符串来指定私钥和公钥，并以压缩形式表示公钥。我们以通常的方式表示以太坊账户（以 `0x` 为前缀，20 字节的十六进制字符串）。具体来说，为了序列化和反序列化椭圆曲线点，实现者必须使用以下标准：

- 序列化一个点：使用 [SEC 1, §2.3.3]，并进行点压缩。
- 反序列化一个点：使用 [SEC 1, §2.3.3]，同时要求点压缩；即：

  - 输入字节字符串的长度必须为 ⌈log₂q / 8⌉ + 1 = `33`。
  - 第一个字节必须为 `0x02` 或 `0x03`。
  - 剩余 32 字节表示的整数（如 [SEC 1, §2.3.8] 所示）必须位于 {0, ..., _p_ - 1} 中，并且必须在 Weierstrass 表达式 X^3 + 7 (modulo _p_) 下产生二次剩余。

对于实际实现 ECIES 的应用级实现者，我们建议以下变体。除非有其他理由，否则实现者应使用以下标准化选择：

- KDF `ANSI-X9.63-KDF`，其中使用哈希函数 `SHA-512`，
- HMAC `HMAC–SHA-256–256，使用 32 字节或 256 位密钥`，
- 对称加密方案 `AES–256 在 CBC 模式下`。

我们建议在加密和解密时使用 ECIES 密文的二进制、_连接_ 序列化模式，其中椭圆曲线点是_压缩_的。

因此，在请求中：

```javascript
request({
  method: 'eth_getEncryptionPublicKey',
  params: [account]
})
```

其中 `account` 是标准的 20 字节、以 `0x` 为前缀的十六进制编码以太坊账户，客户端应按如下方式操作：

- 找到与以太坊账户 `account` 对应的秘密签名密钥 `sk`，如果不存在则返回错误。
- 计算与 `sk` 对应的 `secp256k1` 公钥。
- 以压缩的、以 `0x` 为前缀的十六进制编码形式返回该公钥，遵循 [SEC 1, §2.3.3]。

在请求中

```javascript
request({
  method: 'eth_performECDH',
  params: [account, ephemeralKey]
})
```

其中 `account` 如上所述，`ephemeralKey` 是如上所述编码的椭圆曲线点：

- 找到与以太坊账户 `account` 对应的秘密密钥 `sk`，如果不存在则返回错误。
- 使用 [SEC 1, §2.3.3] 反序列化 `ephemeralKey` 为椭圆曲线点（要求进行压缩），如果反序列化失败则抛出错误。
- 计算椭圆曲线 Diffie–Hellman 密钥，遵循 [SEC 1, §3.3.1]。
- 使用 [SEC 1, §2.3.5] 返回结果字段元素，格式为以 `0x` 为前缀的、十六进制编码的 32 字节字符串。

测试向量如下所示。

### 加密到智能合约

鉴于账户抽象，[EIP-4337](eip-4337.md) 和智能合约钱包的出现，我们还指定了一种加密到合约的方法。
更确切地说，我们指定了一种合约如何_广告_ 它希望如何构建加密的方式。这应被视为 [EIP-1271](eip-1271.md) 的类比，但用于加密，而不是签名。

我们的规范如下。

```solidity
pragma solidity ^0.8.0;

contract ERC5630 {
  /**
   * @dev Should return an encryption of the provided plaintext, using the provided randomness.
   * @param plaintext      Plaintext to be encrypted
   * @param randomness     Entropy to be used during encryption
   */
  function encryptTo(bytes memory plaintext, bytes32 randomness)
    public
    view
    returns (bytes memory ciphertext);
}
```

每个合约可以根据需要实现 `encryptTo`。除非有充分理由，否则它应使用我们上述提出的 ECIES 变体。

## 理由

对于同时在 `secp256k1` 曲线上调用签名和在 `ec25519` 曲线上调用加密的方案，_没有安全证明_，并且_在这两种情况下使用相同的密钥_。虽然没有已知的攻击，但使用这种缺乏证明的方案并不理想。
我们则建议在签名和加密中重用相同的密钥，但_在两者中使用相同的曲线_。这种设置在之前的工作中得到了研究；例如，Degabriele、Lehmann、Paterson、Smart 和 Strefler 的 _On the Joint Security of Encryption and Signature in EMV_，2011。该工作发现这种联合方案在通用群模型中是安全的。
我们注意到，这种联合方案（即在同一曲线上使用 ECDSA 和 ECIES）在 EMV 支付中实际投入生产使用。

我们现在讨论我们方法的几个进一步方面。

**链上公钥发现。** 我们的提案具有一个重要特性，即可以在某个账户至少签署了一笔交易时构造对该账户的加密。实际上，可以直接从该账户的任何签名中恢复账户的 `secp256k1` 公钥。
**ECDH 与 ECIES。** 我们指定钱包 *仅* 执行敏感的 ECDH 操作，并让应用层实现者执行 ECIES 的其余步骤。这有两个明显的优势：

- **灵活性。** 它允许实现者选择任意变体的 ECIES，而无需更新钱包的操作。
- **带宽。** 我们的方法要求客户端和钱包之间仅交换小消息（大约 32 字节）。在明文和密文较大的情况下，以及客户端和钱包通过互联网连接分隔时，这可能是重要的。

**扭曲攻击。** Christian Lundkvist 在某个 GitHub 帖子中警告了对 `secp256k1` 曲线的“扭曲攻击”。这些攻击不适用于此 EIP，原因有多个 *不同* 的方面，我们列举如下：

- **仅适用于经典 ECDH，而不适用于 ECIES。** 该攻击仅适用于经典 ECDH（即双方使用持久的、经过认证的公钥），而不适用于 ECIES（其中一方，即加密者，使用临时密钥）。实际上，它仅适用于攻击者能够诱使受害者用敏感标量对攻击者提供的点进行指数运算的场景，然后将结果发送回攻击者。但这种模式仅发生在经典的 Diffie–Hellman 中，而在 ECIES 中则不会。实际上，在 ECIES 中，我们回顾到唯一的敏感 Diffie–Hellman 操作发生在解密过程中，但在这种情况下，受害者（即解密者）从未将结果 DH 点发送回攻击者（相反，受害者仅在本地使用它尝试 AES 解密）。在 *加密* 过程中，指数运算由加密者完成，而加密者根本没有秘密（确实，指数运算是由临时标量完成的），因此在这里攻击者没有任何可以学习的内容。
- **仅适用于未压缩点。** 实际上，我们在此 EIP 中使用压缩点。当使用压缩点时，每个 33 字节的字符串 *必然* 要么解析为正确曲线上的一个点，要么没有合理的解释。不存在“一个不在曲线上的点”（特别是，这种情况可以不被察觉地通过）。
- **仅在未检查点是否在曲线上的情况下适用。** 但这对我们来说无关紧要，因为我们使用压缩点（见上文）。我们还要求执行所有验证。

## 向后兼容性

我们的 `eth_performECDH` 方法是新的，因此不会引发任何向后兼容性问题。

之前的提案提出了一个 `eth_getEncryptionPublicKey` 方法（以及一个与此 EIP 无关的 `eth_decrypt` 方法）。我们的提案覆盖了 `eth_getEncryptionPublicKey` 的先前行为。
这不太可能成为问题，因为加密密钥仅在加密时需要重新获取；另一方面，*新* 密文将使用我们的新方法生成。
（特别是，我们的修改不会影响使用旧 EIP 生成的密文被 `eth_decrypt` 的能力。）

无论如何，之前的 EIP 从未标准化，并且在我们所知的任何生产代码中都 *没有* 以非弃用的方式实现。

### 测试用例

秘密 *签名密钥*

```
    0x439047a312c8502d7dd276540e89fe6639d39da1d8466f79be390579d7eaa3b2
```

与以太坊地址 `0x72682F2A3c160947696ac3c9CC48d290aa89549c` 相关，具有 `secp256k1` 公钥

```
    0x03ff5763a2d3113229f2eda8305fae5cc1729e89037532a42df357437532770010
```

因此，请求：

```javascript
request({
  method: 'eth_getEncryptionPublicKey',
  params: ["0x72682F2A3c160947696ac3c9CC48d290aa89549c"]
})
```

应返回：

```javascript
"0x03ff5763a2d3113229f2eda8305fae5cc1729e89037532a42df357437532770010"
```

如果加密者要加密一条消息——例如，`我使用 Firn 协议在以太坊上获得隐私。`——在上述公钥下，使用上述 ECIES 变体，他可以获得，例如：

```javascript
"0x036f06f9355b0e3f7d2971da61834513d5870413d28a16d7d68ce05dc78744daf850e6c2af8fb38e3e31d679deac82bd12148332fa0e34aecb31981bd4fe8f7ac1b74866ce65cbe848ee7a9d39093e0de0bd8523a615af8d6a83bbd8541bf174f47b1ea2bd57396b4a950a0a2eb77af09e36bd5832b8841848a8b302bd816c41ce"
```

在获得此密文后，解密者将提取相关的临时公钥，即：

```javascript
"0x036f06f9355b0e3f7d2971da61834513d5870413d28a16d7d68ce05dc78744daf8"
```

并提交请求：

```javascript
request({
  method: 'eth_performECDH',
  params: [
    "0x72682F2A3c160947696ac3c9CC48d290aa89549c",
    "0x036f06f9355b0e3f7d2971da61834513d5870413d28a16d7d68ce05dc78744daf8"
  ]
})
```

这将返回 Diffie–Hellman 密钥：

```javascript
"0x4ad782e7409702101abe6d0279f242a2c545c46dd50a6704a4b9e3ae2730522e"
```

在继续使用上述 ECIES 变体后，解密者将获得字符串 `我使用 Firn 协议在以太坊上获得隐私。`。

## 安全考虑

我们的提案使用了高度标准化的算法，并遵循所有最佳实践。

## 版权

版权及相关权利通过 [CC0](../LICENSE.md) 放弃。