---
eip: 7546
title: 可升级克隆用于可扩展合约
description: 一种可升级、可克隆、横向可扩展的代理模式。
author: Shogo Ochiai (@shogochiai) <shogo.ochiai@pm.me>, Kai Hiroi (@KaiHiroi) <kai.hiroi@pm.me>
discussions-to: https://ethereum-magicians.org/t/eip-7546-upgradeable-clone/16256
status: 草案
type: 标准跟踪
category: ERC
created: 2023-10-25
requires: 165, 1967, 7201
---

## 摘要
在以太坊虚拟机（EVM）上创建可克隆和可升级合约一直是开发者面临的重大挑战。虽然 [ERC-2535](./eip-2535.md) 钻石和其他现有的代理标准提供了部分解决方案，但一个全面的答案仍然难以实现。我们的提案通过引入两个主要特性来填补这一空白。

### 函数级别的可升级性
与 [ERC-2535](./eip-2535.md) 一致，该功能允许对单个函数调用的实现合约进行选择性重定向。这种对升级的细粒度控制允许按函数进行修改。此外，通过函数对实现合约进行分段，有助于缓解合约大小限制（截至 EVM 上海版本或更早版本为 24.576kB）所带来的限制。

### 工厂/克隆友好与同时可升级性
借鉴 [ERC-1967](./eip-1967.md) 的信标模型，我们的方法旨在简化同时克隆和更新代理合约的过程。这种方法旨在保持不同实例之间的一致功能，每个实例都有其自己的状态。通常，代理仅限于基本的可升级性特性或遵循 [ERC-1167](./eip-1167.md) 标准。然而，我们的解决方案将这两种功能结合成一个紧凑的代理。

## 动机
智能合约开发常常因以太坊虚拟机（EVM）的固有限制而遇到障碍，例如合约大小限制和栈深度。此外，解决智能合约逻辑及其编译器中的漏洞也是持续存在的问题。虽然希望减少对可信第三方的依赖以实现可升级性，但引入复杂的治理结构来管理升级可能会显著增加加密 DevOps 的工作量，从而加剧开发者在推进项目时可能感到的顾虑。这种顾虑可能限制智能合约开发中的复杂性和创新性。我们的方法旨在简化智能合约编程，使其更易于访问和更具乐趣。它通过清晰地划分 DevOps 问题与业务逻辑，从而增强代码库的清晰度，促进审计，并通过针对特定基础设施和领域需求的语言模型（LM）技术进行更有针对性的分析。

### 用例
随着时间的推移，提出并使用了各种智能合约设计模式。此 *可升级克隆标准 (UCS)* 旨在用于这些现有模式可能不足的场景。为澄清这一点，我们定义了一些关键术语：

- **合约级别的可升级性**：一个代理合约对应一个实现合约，负责代理的所有逻辑。
- **函数级别的可升级性**：一个代理合约对应多个实现合约，基本上每个合约负责一个特定的函数。
- **工厂**：一个克隆具有共同实现的代理的合约。在可升级性的上下文中，它允许同时升级这些克隆的代理。

以下是用例：

1. 对于没有可升级性或工厂的基本需求，*常规智能合约部署* 足够。
2. 当需要工厂而没有可升级性时，[ERC-1167](./eip-1167.md) 是合适的选择。
3. 对于没有工厂的合约级别可升级性，可以使用 [ERC-1822](./eip-1822.md)。
4. 对于具有工厂的合约级别可升级性，可以应用 [ERC-1967](./eip-1967.md) 的信标。
5. 对于没有工厂的函数级别可升级性，可以使用 [ERC-2535](./eip-2535.md)。
6. 对于具有工厂的函数级别可升级性，此 ***可升级克隆标准*** 是理想选择。

![图. 用例](../assets/eip-7546/images/usecases.svg)

## 规范
> 本文档中的关键字 "MUST"、"MUST NOT"、"REQUIRED"、"SHALL"、"SHALL NOT"、"SHOULD"、"SHOULD NOT"、"RECOMMENDED"、"NOT RECOMMENDED"、"MAY" 和 "OPTIONAL" 应按 RFC 2119 和 RFC 8174 中的描述进行解释。

在 EVM 中，合约账户的特征由四个主要字段组成：*nonce*、*balance*、*code* 和 *storage*。该 ERC 的架构将这些功能模块化为三种不同类型的合约，每种合约在组合时代表一个单一账户：

1. **代理合约**：维护合约账户的状态，如 nonce、balance 和 storage。该合约通过 delegatecall 调用在 _字典合约_ 中注册的 _函数合约_，确保状态和逻辑分离但有效集成。
2. **字典合约**：充当调度器，根据函数选择器将函数调用路由到适当的 _函数合约_。它管理合约行为的动态方面，促进函数升级和动态寻址。通过将此合约从 _代理合约_ 中外部化，它变得工厂/克隆友好，并支持同时可升级性。
3. **函数（实现）合约**：实现函数调用的可执行逻辑。当被 _代理合约_ delegatecall 时，它执行合约代码中定义的实际计算或逻辑。

这种架构不仅与 EVM 合约账户的核心属性一致，而且通过明确账户状态、函数调度和逻辑实现，显著增强了智能合约的模块化、可升级性和可扩展性。

### 代理合约
该合约请求 _字典合约_ 根据其函数选择器检索相关的 _函数合约_ 地址，然后进行 delegatecall。

#### 存储与事件
该合约 SHOULD 在存储槽 `0x267691be3525af8a813d30db0c9e2bad08f63baecf6dceb85e2cf3676cff56f4` 中存储 _字典合约_ 地址，该地址通过 `bytes32(uint256(keccak256('erc7546.proxy.dictionary')) - 1)` 获取，符合 [ERC-1967](./eip-1967.md) 中定义的方法。这确保了地址存储在一个安全且可预测的槽中。

对字典地址的更改 SHOULD 触发事件。当此类事件被触发时，必须使用以下签名：
```solidity
event DictionaryUpgraded(address dictionary);
```

#### 函数
对于通过 `CALL` 或 `STATICCALL` 进行的每次调用，该合约 MUST 执行对从 _字典合约_ 中检索到的相应 _函数合约_ 地址的 delegatecall，使用 `getImplementation(bytes4 functionSelector)` 函数。该合约还 MUST 处理来自此 delegatecall 的返回值，以确保正确执行预期功能。此外，为了避免与在 _字典合约_ 中注册的函数选择器发生潜在冲突，代理 SHOULD 不定义任何外部函数。

### 字典合约
该合约管理函数选择器与相应 _函数合约_ 地址的映射。它使用此映射来处理来自 _代理合约_ 的请求。
#### 存储与事件
字典必须维护函数选择器与*函数合约*地址的映射。

对此映射的更改应通过事件（或日志）进行通信。

```solidity
event ImplementationUpgraded(bytes4 functionSelector, address implementation);
```

#### 函数
##### `getImplementation`
此合约必须实现此函数以返回*函数实现合约*地址。

```solidity
function getImplementation(bytes4 functionSelector) external view returns(address implementation);
```

##### `setImplementation`
此合约应实现此函数以更新或添加新的函数选择器及其对应的*函数实现合约*地址到映射中。

```solidity
function setImplementation(bytes4 functionSelector, address implementation) external;
```

##### `supportsInterface`
建议此合约实现`supportsInterface(bytes4 interfaceID)`函数，该函数在 [ERC-165](./eip-165.md) 中定义，以指示映射中引用的合约支持哪些接口。

##### `supportsInterfaces`
建议此合约实现`supportsInterfaces()`以返回注册的 interfaceIDs 列表。
```solidity
function supportsInterfaces() public view returns (bytes4[] memory);
```

### 函数（实现）合约
此合约充当逻辑实现合约，*代理合约*进行委托调用，其地址在*字典合约*中与函数选择器注册。

#### 存储与事件
此合约不应使用其存储，而应通过委托调用存储到*代理合约*中。

*代理合约*与多个*函数合约*共享存储布局。例如，从槽 0 开始使用顺序槽分配（这是默认编译器选项）可能会导致存储冲突。

为了防止存储冲突，此合约必须妥善管理存储布局。存储管理技术的问题多年来一直是争论的主题，无论是在 ERC 层面还是语言层面。然而，仍然没有明确的标准。因此，此 ERC 不深入探讨存储管理技术的细节。

建议选择在当时被认为最合适的存储管理方法。

例如，存储可以根据有用的存储布局模式进行安排，如***[ERC-7201](./eip-7201.md)***。

#### 函数
此合约必须在*字典合约*中注册相同的函数选择器。如果没有，代理的委托调用将失败。因此，建议每个*函数合约*实现 ERC-165 的`supportsInterface(bytes4 interfaceID)`以确保在添加到字典时正确实现被注册的函数选择器。

## 理由
### 与 [ERC-2535](./eip-2535.md) 的比较
虽然此 ERC 和 ERC-2535 都提供了[函数级可升级性](#function-level-upgradeability) ，但它们的方法存在关键区别。ERC-2535 在代理内部维护实现合约的映射（在 ERC-2535 中称为 Facet）。相比之下，此 ERC 将映射存储在外部*字典合约*中。这种映射的外部化促进了此标准的另一个重要特性： [工厂/克隆友好与同时可升级性](#factoryclone-friendly--simultaneous-upgradeability) 。通过将映射与代理分离，这种设计允许更容易地克隆合约及其同时升级，这在 ERC-2535 框架中并不那么简单。

![图. 与钻石的比较](../assets/eip-7546/images/comparison-with-diamond.svg)

### 分离字典和代理合约：
字典与代理的分离是为了与[工厂/克隆友好与同时可升级性](#factoryclone-friendly--simultaneous-upgradeability)保持一致。

为此，*函数实现合约*地址的管理功能被外部化为*字典合约*，而不是将其包含在*代理合约*中，这一概念类似于信标代理方法。

如果功能在*代理合约*内，则每个代理都需要升级其实现。
通过外部化这一点，可以克隆并同时升级一个通用实现。

![图. 与信标的比较](../assets/eip-7546/images/comparison-with-beacon.svg)

### 利用函数选择器和实现地址的映射：
*代理合约*利用*字典合约*中函数选择器与相应*函数实现合约*地址的映射，然后委托调用返回的实现地址，这与[函数级可升级性](#function-level-upgradeability)一致。

通过采用这种方法，代理模拟了在*字典合约*中注册的一组*函数实现合约*的行为。此规范与钻石标准中概述的模式非常相似。

## 参考实现
有作为一个 foundry 项目的参考实现和测试。

它包括以下内容：
- 参考实现
  - [代理合约](../assets/eip-7546/src/Proxy.sol)
  - [字典合约](../assets/eip-7546/src/Dictionary.sol)
- 测试
  - [代理规范测试](../assets/eip-7546/test/Proxy.spec.t.sol)
  - [字典规范测试](../assets/eip-7546/test/Dictionary.spec.t.sol)
  - [UCS 用例测试](../assets/eip-7546/test/UCS.usecase.t.sol)

## 安全考虑
### 实现管理的委托
这种将所有实现委托给*字典合约*的模式依赖于*字典合约*的管理员以诚信行事，并且不通过疏忽引入漏洞。

您不应将代理与不受信任的管理员提供的*字典合约*连接。此外，建议提供切换到由不同（或可能更可信）管理员管理的另一个*字典合约*的选项。

虽然可以将*字典合约*地址存储在代码区域（例如，使用 Solidity 的 immutable 或 constant），但应谨慎设计，考虑到如果*字典合约*的管理员与*代理合约*的管理员不同，则可能会永久失去操控实现的能力。

### 存储冲突
如上文[存储部分](#storage--events-2)所述。这种设计模式涉及多个*函数实现合约*共享单个*代理合约*存储。因此，重要的是要小心防止存储冲突，使用被认为在当时最合适的存储管理方法。

### 函数选择器不匹配
*字典合约*根据*代理合约*调用的函数选择器返回*函数实现合约*地址。

如果在*字典合约*中注册的函数选择器与在*函数实现合约*中实现的选择器不匹配，则执行将失败。为了防止意外行为，建议在将实现地址设置到*字典合约*的过程中检查*函数实现合约*是否包含被注册的函数选择器（接口）。

### 处理 CALL 和 STATICCALL
*代理合约*主要设计为响应`CALL`和`STATICCALL`操作码。如果对该*代理合约*进行`DELEGATECALL`，它将尝试通过`getImplementation(bytes4 functionSelector)`函数请求*字典合约*获取相应的实现，使用存储在其自身存储中的*字典合约*地址。尽管如果调用合约的存储布局与预期不符，这一行为可能不会导致预期的结果，但这并不构成对*代理合约*本身的直接威胁。开发者应注意，通过`DELEGATECALL`调用此*代理合约*可能导致意外和潜在的非功能性结果，因此这不是一种适合的交互方式。
## 版权
版权及相关权利通过 [CC0](../LICENSE.md) 放弃。