---
eip: 7562
title: 账户抽象验证范围规则
description: 一组对验证 EVM 代码的限制，以保护账户抽象节点免受未支付计算的拒绝服务攻击。
author: Yoav Weiss (@yoavw), Dror Tirosh (@drortirosh), Alex Forshtat (@forshtat), Shahaf Nacson (@shahafn)
discussions-to: https://ethereum-magicians.org/t/erc-7562-account-abstraction-validation-scope-rules/16683
status: 草案
type: 标准跟踪
category: ERC
created: 2023-09-01
---

## 摘要

本文档描述了我们对账户抽象交易的验证上下文施加的规则，
例如 [ERC-4337](./eip-4337) `UserOperation` 或 RIP-7560（原生账户抽象），这些规则由区块构建者或独立的捆绑器在链外强制执行，以及每条规则背后的理由。

## 动机

通过账户抽象，处理交易（验证、支付 gas 和执行）的逻辑不再是硬编码的，而是由 EVM 代码执行。
对账户的好处是无穷无尽的 -
- 抽象验证允许合约使用不同的签名方案、多重签名配置、自定义恢复等。
- 抽象 gas 支付允许通过第三方支付轻松入门、使用代币支付、跨链 gas 支付
- 抽象执行允许批量交易

以上所有内容在 EOA 账户模型中都是缺失的。

然而，交易必须遵循一条规则以维护去中心化网络：一旦提交到网络（内存池），交易就保证会支付。这是为了防止对网络的拒绝服务攻击。

EOA 模型隐含地遵循这一规则：有效交易在账户未支付的情况下不能变为无效：例如，账户余额不能减少（除非是更高支付的交易）

这一简单规则使网络可持续并受到 DoS 保护：网络不能通过大量交易被廉价攻击。攻击（发送大量交易）是昂贵的，并且随着网络拥堵而变得更加昂贵。合法用户支付更多，并可以延迟操作以避免成本，但攻击者支付的费用巨大（并且不断增加），以保持网络拥堵。

对于账户抽象系统，我们希望保持相同的规则，以便对网络进行 DoS 攻击的尝试同样昂贵。
为此，我们添加了以下验证规则。

有关这些基于合约的账户的实际接口，请参见 ERC-4337 和 RIP-7560 中的定义。

本文档使用术语“UserOperation”来指代由智能合约账户创建的交易，并紧密遵循 [ERC-4337](./eip-4337) 的术语。
然而，这些规则适用于任何使用 EVM 代码进行交易验证并区分验证与执行的账户抽象框架。

## 规范

### 规则类型

有两种类型的规则：

- **网络范围规则**：必须在接受每个 UserOperation 进入本地内存池并传播之前应用的规则。
  这些规则包括操作码和存储规则。
    - 未通过这些验证规则的 UserOperation 应被丢弃
    - 在第二次验证阶段（提交捆绑之前）未通过这些验证的，应降低违规实体的声誉
    - 捆绑器不得传播未通过验证规则的 UserOperations，否则将被其他捆绑器视为“垃圾邮件发送者”，并被断开连接。

- **本地规则**
  这些是基于实体声誉的“软”规则。
  这些规则旨在保护捆绑器自身免受垃圾邮件攻击。
    - 捆绑器应在不执行验证的情况下丢弃此类 UserOperations。
    - 捆绑器不应将此类 UserOperations 传播给其他捆绑器。
    - 如果其他捆绑器这样做，捆绑器不应将其视为“垃圾邮件发送者”。

### 常量

| 标题                                | 值                           | 注释                                                                         |
|--------------------------------------|-----------------------------|---------------------------------------------------------------------------------|
| `MIN_UNSTAKE_DELAY`                  | 86400                       | 1 天                                                                           |
| `MIN_STAKE_VALUE`                    | 可根据链值调整              | 相当于 ~$1000 的原生代币                                                      |
| `SAME_SENDER_MEMPOOL_COUNT`          | 4                           |                                                                                 |
| `SAME_UNSTAKED_ENTITY_MEMPOOL_COUNT` | 10                          |                                                                                 |
| `THROTTLED_ENTITY_MEMPOOL_COUNT`     | 4                           | 可以在内存池中停留的带有限速实体的 `UserOperations` 数量                     |
| `THROTTLED_ENTITY_LIVE_BLOCKS`       | 10                          | 带有限速实体的 `UserOperations` 可以在内存池中停留的区块数量                 |
| `THROTTLED_ENTITY_BUNDLE_COUNT`      | 4                           |                                                                                 |
| `MIN_INCLUSION_RATE_DENOMINATOR`     | 100 (客户端) \ 10 (捆绑器) |                                                                                 |
| `THROTTLING_SLACK`                   | 10                          |                                                                                 |
| `BAN_SLACK`                          | 50                          |                                                                                 |
| `BAN_OPS_SEEN_PENALTY`               | 10000                       |                                                                                 |
| `MAX_OPS_ALLOWED_UNSTAKED_ENTITY`    | 10000                       |

### 验证规则

### **定义**：
1. **验证阶段**：最多有 3 个验证阶段
    1. 智能账户部署
    2. 智能账户验证
    3. 支付者验证。
2. **实体**：由 `UserOperation` 明确指定的合约。
   包括 `factory`、`paymaster`、`aggregator` 和质押的 `account`，如下所述。 \
   每个“验证阶段”归属于单个实体。 \
   实体合约必须在链上具有非空代码。
3. **规范内存池**：本文档中定义的规则适用于网络上所有捆绑器共享的主内存池。
4. **质押实体**：具有至少 `MIN_STAKE_VALUE` 的锁定质押和至少 `MIN_UNSTAKE_DELAY` 的解除质押延迟的实体。
5. **关联存储**：任何智能合约的存储槽被视为与地址 `A` “关联”，如果：
    1. 槽值为 `A`
    2. 槽值计算为 `keccak(A||x)+n`，其中 `x` 是一个 `bytes32` 值，`n` 是范围在 0..128 的值
6. **使用地址**：以任何方式访问给定地址的代码。
   这可以通过执行 `*CALL` 或 `EXTCODE*` 操作码来完成。

### 声誉定义
1. **opsSeen**：每个实体的计数器，记录该捆绑器接收到的引用此实体的唯一有效 `UserOperation` 的次数。
   这包括通过传入 RPC 调用或通过 P2P 内存池协议接收到的 `UserOperation`。
2. **opsIncluded**：每个实体的计数器，表示引用该实体的唯一有效 `UserOperation` 在实际包含的 `UserOperation` 中出现的次数。\
   该值的计算基于 UserOperationEvents，仅对之前被该打包者计为 `opsSeen` 的 `UserOperations` 进行计数。
3. 两个值每小时更新一次，计算方式为 `value = value * 23 // 24`。\
   实际上，该值在 4 天后减少到 1%。
4. **inclusionRate**：`opsIncluded` 与 `opsSeen` 的关系


### 声誉计算

我们定义一个值 `max_seen = opsSeen // MIN_INCLUSION_RATE_DENOMINATOR`。

每个实体的声誉状态如下确定：

1. **BANNED**：`max_seen > opsIncluded + BAN_SLACK`
2. **THROTTLED**：`max_seen > opsIncluded + THROTTLING_SLACK`
3. **OK**：否则

请注意，新实体的声誉初始为 `OK`。

为了帮助理解这些参数，请注意，恶意的支付者最多可以导致网络（仅限 p2p 网络，而不是区块链）每小时处理 `BAN_SLACK * MIN_INCLUSION_RATE_DENOMINATOR / 24` 个不付费的操作。

### 运行验证规则

1. 区块构建者或打包者在接受 `UserOperation` 进入其内存池之前应执行完整验证。
2. 在验证阶段，打包者应跟踪执行并应用本文件中定义的所有规则。
3. 打包者在提交之前还应对整个包进行完整验证。
4. 验证规则防止未质押实体检测包验证。\
   但是，恶意质押实体可以检测到它正在进行包验证并导致回滚。
5. 失败的 `UserOperation` 应从包中删除。
6. 导致回滚的质押实体违反了账户抽象规则，应标记为 `THROTTLED`。

### 内存池验证规则

1. `UserOperation` 通过 P2P 协议广播，包含以下信息：
    1. `UserOperation` 本身
    2. 此 `UserOperation` 最初验证的区块哈希。
2. 一旦从另一个打包者接收到 `UserOperation`，接收的打包者应在本地进行验证。
3. 接收到的 `UserOperation` 可能会失败任何合理的静态检查，例如：\
   格式无效、值低于最小值、提交的区块哈希不够新等。\
   在这种情况下，打包者应丢弃该特定 `UserOperation`，但保持连接。
4. 打包者应检查 `UserOperation` 与最后包含的包的 nonce。\
   默默丢弃最近包含的 `nonce` 的 `UserOperations`。\
   此无效化可能归因于网络竞争条件，不应导致声誉变化。
5. 如果接收到的 `UserOperation` 在当前区块中失败：
    1. 在最初验证的区块上重试验证。
    2. 如果成功，默默丢弃 `UserOperation` 并保持连接。
    3. 如果失败，标记发送者为“垃圾邮件发送者”。

### 操作码规则
* 阻止访问访问存储和代码之外信息的操作码（即“环境”）。
    * **[OP-011]** 被阻止的操作码：
        * `ORIGIN` (`0x32`)
        * `GASPRICE` (`0x3A`)
        * `BLOCKHASH` (`0x40`)
        * `COINBASE` (`0x41`)
        * `TIMESTAMP` (`0x42`)
        * `NUMBER` (`0x43`)
        * `PREVRANDAO`/`DIFFICULTY` (`0x44`)
        * `GASLIMIT` (`0x45`)
        * `BASEFEE` (`0x48`)
        * `CREATE` (`0xF0`)
        * `INVALID` (`0xFE`)
        * `SELFDESTRUCT` (`0xFF`)
    * **[OP-012]** `GAS` (`0x5A`) 操作码是允许的，但仅在后面紧跟 `*CALL` 指令时，否则被阻止。\
      这是将所有剩余 gas 传递给外部调用的常见方式，这意味着实际值立即从堆栈中消耗，无法被其他操作码访问。
    * **[OP-013]** 任何“未分配”的操作码。
* **[OP-020]** 禁止在“耗尽 gas”时回滚，因为它可能“泄漏” gas 限制或当前调用堆栈深度。
* 合约创建：
    * **[OP-031]** `CREATE2` 在部署阶段仅允许一次，并且必须为“发送者”地址部署代码。
* 禁止访问没有部署代码的地址：
    * **[OP-041]** 对于 `EXTCODE*` 和 `*CALL` 操作码。
    * **[OP-042]** 例外：允许访问“发送者”地址。\
      这仅在部署阶段的 `factory` 代码中可能。
* 允许访问 `EntryPoint` 地址：
    * **[OP-051]** 可以调用 `EXTCODESIZE ISZERO`。\
      此模式用于在调用 `depositTo` 函数之前检查目标是否有代码。
    * **[OP-052]** 可以调用 `depositTo(sender)`，值可以来自“发送者”或“工厂”。
    * **[OP-053]** 可以从“发送者”调用回调函数，值可以是任意值。
    * **[OP-054]** 任何其他对 `EntryPoint` 的访问都是禁止的。
* `*CALL` 操作码：
    * **[OP-061]** 带有 `value` 的 `CALL` 被禁止。唯一的例外是对上述 `EntryPoint` 的调用。
    * **[OP-062]** 预编译：
        * 仅允许网络上已知的接受的预编译，不访问区块链状态或环境中的任何内容。
        * 核心预编译 0x1 .. 0x9
        * 在接受的网络上，RIP-7212 sec256r1 预编译。
* **[OP-070]** 在 [EIP-1153](./eip-1153) 中定义的瞬态存储槽，使用 `TLOAD` (`0x5c`) 和 `TSTORE` (`0x5d`) 操作码访问，\
  被视为与持久存储（SLOAD/SSTORE）完全相同。
* **[OP-080]** `BALANCE` (`0x31`) 和 `SELFBALANCE` (`0x47`) 仅允许来自质押实体，否则被阻止。


### 代码规则

* **[COD-010]** 在第一次和第二次验证之间，任何访问的地址、实体或引用库的 `EXTCODEHASH` 值不得更改。\
  如果代码被修改，则该 UserOperation 被视为无效。

### 存储规则

在每个阶段中，使用 `SLOAD` 和 `SSTORE`（以及 `TLOAD`、`TSTORE`）指令的存储访问限制如下：

* **[STO-010]** 始终允许访问“账户”存储。
* 如果满足以下任一条件，则允许访问外部（非实体）合约的账户相关存储：
    * **[STO-021]** 账户已存在。
    * **[STO-022]** 存在 `initCode`，并且 `factory` 合约已质押。
* 如果实体（`paymaster`、`factory`）已质押，则也允许：
    * **[STO-031]** 访问实体自己的存储。
    * **[STO-032]** 在任何非实体合约中对与实体相关的存储槽进行读/写访问。
    * **[STO-033]** 对非实体合约中的任何存储进行只读访问。

### 本地规则

本地存储规则保护打包者在打包时免受拒绝服务攻击。它们不影响内存池传播，也不会导致打包者被标记为“垃圾邮件发送者”。
* **[STO-040]** `UserOperation` 不得使用在内存池中作为“账户”的实体地址（`factory`/`paymaster`/`aggregator`）。\
  这意味着 `Paymaster` 和 `Factory` 合约实际上不能作为“账户”合约。
* **[STO-041]** `UserOperation` 不得在作为内存池中另一个 UserOperation 的“发送者”的合约中使用相关存储（无论是其账户还是质押实体的存储）。 

### 一般声誉规则
以下声誉规则适用于所有质押实体和未质押的支付主。除非另有说明，否则所有规则适用于所有这些实体。

* **[GREP-010]** `BANNED` 地址不允许进入内存池。\
  此外，所有引用此地址的现有 `UserOperations` 将从内存池中移除。
* **[GREP-020]** `THROTTLED` 地址的限制为：
    * 内存池中的 `THROTTLED_ENTITY_MEMPOOL_COUNT` 条目。
    * 一个捆绑中的 `THROTTLED_ENTITY_BUNDLE_COUNT` `UserOperations`。
    * 只能在内存池中保留 `THROTTLED_ENTITY_LIVE_BLOCKS`。
* **[GREP-040]** 如果一个实体在通过第二次验证后未能创建捆绑，其 `opsSeen` 设置为 `BAN_OPS_SEEN_PENALTY`，并且 `opsIncluded` 设置为零，从而导致其被 `BANNED`。

### 质押实体声誉规则

* **[SREP-010]** “规范内存池”定义一个质押实体，如果它具有 `MIN_STAKE_VALUE` 和未质押延迟 `MIN_UNSTAKE_DELAY`
* **[SREP-020]** 移动到 GREP-010
* **[SREP-030]** 移动到 GREP-020
* **[SREP-040]** 一个 `OK` 质押实体不受声誉规则的限制。
    * 在内存池中允许无限数量。
    * 在捆绑中允许无限数量。
* **[SREP-050]** 移动到 GREP-040

### 实体特定规则

* **[EREP-010]** 对于每个 `paymaster`，内存池必须维护使用此 `paymaster` 可能消耗的总 gas `UserOperations`。
    * 如果包括新的 `UserOperation` 的最大总 gas 成本超过当前 gas 价格下 `paymaster` 的存款，则不将 `UserOperation` 添加到内存池。
* **[EREP-011]** 已删除
* **[EREP-015]** 在工厂或账户失败时，`paymaster` 不应增加其 opsSeen
    * 在进行第二次验证时（在捆绑中包含之前），如果 `UserOperation` 因工厂或账户错误（无论是 FailOp 回滚还是验证规则）而失败，则 `paymaster` 的 opsSeen 有效值减少 1。
* **[EREP-020]** 质押工厂对违反规则的账户负有“责任”。 \
  也就是说，如果在具有 `initCode` 的 `UserOperation` 中，`validateUserOp()` 因任何原因被拒绝，则视为工厂导致此失败，因此这会影响其声誉。
* **[EREP-030]** 质押账户对其他实体（`paymaster`、`aggregator`）的失败负责，即使它们是质押的。
* **[EREP-040]** `aggregator` 必须质押，无论存储使用情况如何。
* **[EREP-050]** 已删除

### 未质押支付主声誉规则

* 定义：
    * **`opsSeen`、`opsIncluded` 和声誉计算** 在上面定义。
    * 实体的 `UnstakedReputation` 决定允许在内存池中使用此实体的最大条目数。
    * `opsAllowed` 是针对未质押实体的基于声誉的计算，表示它在内存池中允许拥有多少 `UserOperations`。
    * 规则：
        * **[UREP-010]** 未质押发送者仅允许在内存池中拥有 `SAME_SENDER_MEMPOOL_COUNT` 个 `UserOperation`。
        * **[UREP-011]** 质押发送者仅受 [质押实体声誉规则](#staked-entities-reputation-rules) 的限制。
        * **[UREP-020]** 对于未质押的支付主，仅在未被限制/禁止的情况下： \
          `opsAllowed = SAME_UNSTAKED_ENTITY_MEMPOOL_COUNT + inclusionRate * min(opsIncluded, MAX_OPS_ALLOWED_UNSTAKED_ENTITY)`。
        * 对于新实体，这是 `SAME_UNSTAKED_ENTITY_MEMPOOL_COUNT` 的默认值
        * **[UREP-030]** 已删除

### 备用内存池规则

备用内存池是一个约定规则，捆绑者可以选择加入，除了规范内存池之外
备用内存池的“主题”是一个唯一标识符。根据惯例，这是描述此备用内存池细节的文档的 IPFS 哈希（以清晰文本和 YAML 文件形式）

* **[ALT-010]** 捆绑者通过 P2P 协议监听备用内存池的“主题”
* **[ALT-020]** 仅在违反规范规则时必须检查备用内存池规则
    * 也就是说，如果验证遵循上述规范规则，则不视为备用内存池的一部分。
* **[ALT-021]** 这样的 `UserOperation`（违反规范规则）会检查所有“备用内存池”，并被视为所有这些备用内存池的一部分
* **[ALT-030]** 捆绑者应仅将 `UserOperations` 转发给其他捆绑者一次，无论他们有多少（共享）备用内存池。 \
  接收捆绑者验证 `UserOperations`，并根据上述规则（和订阅的备用内存池）决定将其传播到哪些备用内存池。
* **[ALT-040]** 实体的 opsInclude 和 opsSeen 按备用内存池保留。也就是说，一个实体可以在一个内存池中被视为受限（或禁止），而在另一个内存池中仍然活跃。

### 备用内存池声誉

备用内存池由参与规范内存池的相同捆绑者提供，但更改规则并可能引入拒绝服务攻击向量。为了防止它们与规范内存池或其他备用内存池一起崩溃，为每个备用内存池管理声誉。导致过多无效的备用内存池会被限制。这限制了攻击的范围，并让捆绑者继续为其他内存池工作。

* **[AREP-010]** 每个备用内存池管理“opsSeen”和“opsIncluded”，类似于实体。opsSeen 在 `UserOperation` 初始验证后递增，此时它被视为此内存池的一部分。
  “opsIncluded” 在此 `UserOperation` 被链上包含后递增（无论是由此捆绑者还是其他捆绑者）
* **[AREP-020]** 备用内存池根据 [声誉计算](#reputation-calculation) 变为 THROTTLED
* **[AREP-030]** 已删除

## 理由

所有由 EOA 发起的交易都有一个隐式验证阶段，在该阶段检查余额、nonce 和签名是否对以太坊区块链的当前状态有效。
一旦节点检查交易有效，只有同一 EOA 的另一个交易可以以使第一个交易无效的方式修改以太坊状态。

然而，使用账户抽象，验证还可以包括任意 EVM 代码并依赖于存储，这意味着不相关的 `UserOperations` 或交易可能会相互使无效。

如果不加以解决，这将使维护有效 `UserOperations` 的内存池和生成有效捆绑的工作在计算上不可行，并容易受到 DoS 攻击。

本文档描述了一组验证规则，如果捆绑者在接受 `UserOperation` 进入内存池之前应用这些规则，可以防止此类攻击。

### 高级目标

本规范的目的是在处理来自外部源的传入 `UserOperations` 时定义节点（捆绑者或区块构建者）之间的共识。
此外部源可以是终端用户节点（通过 RPC）或 p2p 网络中的另一个节点。

该协议试图检测“垃圾邮件”——即无法在链上包含的大量 `UserOperations`（因此无法支付）。
网络通过限制来自此类垃圾邮件节点的请求来保护。

网络中的所有节点必须对“垃圾邮件”有相同的定义：否则，如果某些节点接受某种类型的 `UserOperations` 并传播它们，而其他节点将其视为垃圾邮件，则这些“宽容”的节点将被其余节点视为“垃圾邮件发送者”，网络实际上会被分裂。
### 用户操作的处理流程

- 首先，接收到一个用户操作 - 通过 RPC（代表单个应用提交）或通过 p2p 协议，从内存池中的另一个节点。
- 节点对用户操作进行验证，然后将其添加到内存中的内存池，并提交给其对等节点。
- 最后，在构建区块时，节点从内存池中收集用户操作，进行第二次验证以确保它们作为一个整体仍然有效，并将其提交到下一个区块中。

### 提交区块前需要进行第二次验证

如果接收到另一个具有相同 nonce 的交易，内存池中的正常以太坊交易可能会失效。那笔交易必须提高 gas 价格以替换第一笔交易，因此满足“必须支付才能被包含在内存池中”的规则。
对于基于合约的账户，由于用户操作的有效性可能依赖于可变状态，其他交易可能会使先前有效的用户操作失效，因此我们必须在包含之前进行检查。

### 限制操作码的理由：

- 验证是在链下进行的，在创建区块之前。一些操作码访问的信息只有在创建区块时才知道。
- 在验证交易时使用这些操作码可能会轻易创建一个在链下成功但在链上总是回滚的验证规则，从而导致拒绝服务攻击。
- 一个简单的例子是 `require block.number==12345`。在验证用户操作并将其添加到内存池时，它可能是有效的，但在稍后的区块中尝试将其包含在链上时将是无效的。

### 限制存储访问的理由

- 我们需要用户操作的验证不重叠，以便单个存储更改不会轻易使内存池中的大量用户操作失效。通过限制用户操作访问与账户本身相关的存储，我们知道可以确保在一个包中为每个账户包含一个用户操作。
- （一个打包者可以在一个包中包含多个同一账户的用户操作，但必须首先一起验证它们）

### 要求质押的理由

我们希望能够允许全球使用的合约（支付者、工厂）使用与账户无关的存储，但仍然防止它们在内存池中进行垃圾邮件攻击。
如果一个合约导致太多用户操作在第一次验证成功后在第二次验证中失败，我们可以限制其在内存池中的使用。
通过要求这样的合约有质押，我们防止了“Sybil 攻击”，使得创建大量这样的支付者以继续垃圾邮件攻击变得昂贵。

通过遵循验证规则，我们可以检测导致垃圾邮件用户操作的合约，并限制它们。
质押是为了防止恶意实体的快速重建。
质押永远不会被削减（因为它仅用于链下检测），但会被锁定一段时间，这使得这种攻击变得更加昂贵。

### `大规模失效攻击` 的定义

如果大量通过初始验证并被节点接受、进一步传播到网络中其他打包者的 `UserOperations` 变得无效且不符合包含在区块中的条件，则被视为对网络的 `大规模失效攻击`。

执行此类攻击有三种方式：

1. 提交通过初始验证的 `UserOperation`，但在打包创建期间后续失败的重新验证。
2. 提交在验证期间独立有效的 `UserOperation`，但在打包在一起时变得无效。
3. 提交有效的 `UserOperation`，但通过在网络上执行状态更改“抢先执行”使其变得无效。所涉及的“抢先执行”必须在经济上可行。

为了防止此类攻击，我们尝试“沙箱化”验证代码。
我们将验证代码与其他 `UserOperations`、与存储的外部更改以及与环境信息（如当前区块时间戳）隔离。

### 什么不被视为 `大规模失效攻击`

一个在接收节点通过初始验证失败而未进入其内存池的 `UserOperation` 不被视为攻击。节点应采取 web2 安全措施，并根据 API 密钥、源 IP 地址等限制请求。
RPC 节点已经这样做，以防止被无效交易的垃圾邮件轰炸，这些交易也有验证成本。
P2P 节点已经有（并应应用）评分机制来确定垃圾邮件节点。

此外，如果从内存池中失效的 `N` 个用户操作的成本为 `N*X`，且 `X` 足够大，则不被视为经济上可行的攻击。

- 导致失效的最小更改是存储更改（5k gas）
- 假设一个节点每个区块可以处理 2000 个无效用户操作，则 DoS 攻击的成本为每个区块 10M gas。
- 上述值很高，但我们采取进一步措施使这种攻击更加昂贵。

## 安全考虑

本文档描述了打包者必须采取的安全考虑，以保护自己（以及整个内存池网络）免受拒绝服务攻击。

## 版权

版权及相关权利通过 [CC0](../LICENSE.md) 放弃。