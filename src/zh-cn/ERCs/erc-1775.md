---
eip: 1775
title: 应用密钥，特定于应用的钱包账户
author: Vincent Eli (@Bunjin), Dan Finlay (@DanFinlay)
discussions-to: https://ethereum-magicians.org/t/eip-erc-app-keys-application-specific-wallet-accounts/2742
status: Stagnant
type: Standards Track
category: ERC
created: 2019-02-20
---

## 简要总结

在众多加密应用中，以太坊区块链的可扩展性和隐私解决方案要求用户执行大量签名操作。它还可能要求用户监视某些状态并准备自动签署数据（例如，签署状态或争议提款）。目前钱包实现账户的方式在用户体验、安全性和隐私方面对完整的 web3.0 体验的发展构成了若干障碍。

本提案描述了一种新类型的钱包账户的标准和 API，这些账户是专门为每个特定应用派生的。我们建议称之为 `app keys`。它们允许隔离每个应用使用的账户，从而可能提高隐私。它们还允许应用开发者对账户管理和签名委托拥有更多控制权。对于这些应用密钥，钱包可以具有更宽松的安全级别（例如，不请求用户确认），同时保持主账户的安全。最后，钱包还可以实现不同的行为，例如允许签署交易而不广播它们。

这种新账户类型可以显著改善用户体验，并允许加密许可网络应用的新设计。

## 摘要
在钱包中，用户通常将大部分资金保存在主账户中。这些账户需要较高的安全级别，并且不应以任何方式被委托，这显著影响了加密应用的设计，因为用户必须手动确认每个操作。此外，用户通常在应用之间使用相同的账户，这在隐私和潜在安全性方面都是一个问题。

我们在这里引入了一种新账户类型，应用密钥，它允许在应用之间进行签名委托和账户隔离，以提高隐私和安全性。

在此 EIP 中，我们提供了一种如何唯一识别和验证每个应用的提案，如何从用户私钥（她的根私钥或任何其他派生或未派生自她根私钥的账户私钥）派生出唯一的主账户（或应用密钥）。该 EIP 旨在成为一种标准，说明如何派生特定于每个应用的密钥，这些密钥可以在用户恢复钱包并再次使用为其派生该密钥的应用时，从头开始重新生成。
这些应用密钥可以赋予不同的权限集（通过在 [EIP-2255](./eip-2255.md) 中引入的 requestPermission 模型）。这将可能允许用户部分信任某些应用在不妨碍其主账户安全性的情况下代表他们执行某些加密操作。

## 动机
钱包开发者已就使用 BIP32、BIP44、SLIP44 的以太坊账户 HD 派生路径达成一致，[(请参见此处讨论)](https://github.com/ethereum/EIPs/issues/84)。Web3 钱包以大致相似的方式实现了 rpc eth API。[EIP-1102](./eip-1102.md) 通过非自动选择钱包账户进入应用来引入隐私，从而提高隐私性。

然而，为了允许加密许可应用的适当设计和用户体验，仍然存在若干限制。

大多数基于 GUI 的当前钱包不允许：
* 能够自动且轻松地为每个应用使用不同的密钥/账户，
* 能够在不提示用户的情况下以与从主账户发送资金相同的安全级别签署某些应用的操作，
* 能够使用可抛弃的密钥来提高匿名性，
* 在不广播这些交易的情况下轻松为应用签署交易，同时仍然能够像往常一样从主账户执行其他交易签署，
* 所有这些都可以通过用户的助记词或硬件钱包以及由应用的 ens 名称唯一确定的 HD 路径完全恢复。

我们试图通过引入一种新账户类型，应用密钥，来克服这些限制，以便与现有主账户一起使用。

这些新的应用密钥可以赋予加密应用开发者更多的权力和灵活性。这可以大大改善加密去中心化应用的用户体验，并创造出以前无法实现的新设计，利用创建和处理多个账户、预签名消息并稍后广播的能力。这些功能与我们对持有用户大部分资金的主账户所要求的安全级别不兼容。

## 规范

### 应用程序

应用程序是一个网站（或其他）希望请求钱包访问专门为此用途派生的加密密钥。它可以是任何形式的依赖于加密/身份的应用程序，基于以太坊但不限于此。

一旦连接到钱包，应用程序可以请求访问专门为该应用程序派生的账户，使用以下算法。

### 私有应用密钥生成算法

我们现在提出一种生成应用密钥的算法：
- 在用户选择生成这些密钥的账户的情况下，唯一定义，
- 因此在更改用户账户时可以隔离，允许个人管理（见下一节），
- 特定于每个应用程序，
- 可以从用户主种子助记词和应用程序名称完全恢复。

#### 使用不同账户作为个人

我们允许用户通过更改选择生成每个密钥的账户来扩展不同的应用密钥集。因此，从同一主种子助记词，用户可以使用她的每个账户索引生成一组替代的应用密钥。这可以描述为使用不同的个人。
这将允许用户完全隔离她与特定应用的交互。用户可以例如为特定域创建个人和商业档案，两个档案都使用相同的助记词备份，使用两个不同的账户生成这些。应用程序或域将不会意识到这两个档案背后是同一个人和助记词。
如果一个应用程序与用户的多个主账户交互，其中一个账户可以作为主账户，其他账户作为辅助账户。

该 EIP 对生成用于扩展不同应用密钥空间的私钥的方式持中立态度。然而，为了兼容性和清晰区分个人与加密货币账户，将很快提出一个新的 EIP，与此 EIP 一起使用，介绍清晰的个人生成和管理。

#### 应用程序的唯一标识符

每个应用程序通过其来源（域字符串）唯一定义和验证。它可以是域名服务（DNS）名称，或者在未来是以太坊名称服务（ENS）名称或 IPFS 哈希。

对于 Ipfs 或 swarm 来源，但我们可能可以使用 ipfs 或 swarm 地址作为来源，或者我们可以要求这些通过 ENS 条目指向，并使用 ENS 地址作为来源，尽管这意味着它所指向的内容可能会更改。这将允许不同的安全性和可更新性模型。
我们可能需要在使用 ENS 域名指向 IPFS 地址时添加协议前缀：
`ens://ipfs.snap.eth`


#### 私有应用密钥生成算法

使用应用程序的域名，我们为每个应用程序（以及每个主账户）生成一个私钥：

`const appKeyPrivKey = keccak256(privKey + originString)`

其中 `+` 是连接，`privKey` 是用户账户的私钥，该账户被选中以扩展应用程序密钥，`originString` 表示发起访问应用程序密钥的权限调用的源 URL。

这作为 RPC 方法公开，以允许任何域请求与当前请求的账户（如果可用）关联的自己的应用密钥：

```
const appKey = await provider.send({
  method: 'wallet_getAppKeyForAccount',
  params: [address1]
});
```

请参见此处的实现：
https://github.com/MetaMask/eth-simple-keyring/blob/master/index.js#L169

#### 应用密钥和分层确定性密钥

使用前面部分描述的算法生成的应用密钥将不符合 BIP32 标准。因此，应用程序将无法直接创建多个应用密钥或使用非硬化和扩展公钥技术。它们获得一个私钥（每个源，每个角色）。
然而，它们可以将此作为初始熵来扩展新的 HD 树并生成可以是硬化或非硬化的地址。因此，我们不应该失去使用案例。

## 理由

### 在域之间共享应用密钥：
虽然这并没有明确涵盖在其自身之间共享这些应用密钥的情况，但可以通过组合来满足这一需求：

由于一个域将为每个角色获得一个唯一的密钥，并且由于域可以相互通信，一个域（应用）可以请求另一个域（签名者）对某些数据执行其加密操作，使用其 appKey 作为种子，可能允许像新网站一样轻松添加新的签名策略。

这也可以传递给加载特定签名策略的域。这听起来可能一开始很危险，但如果一个域代表一个受信任的加密函数实现的静态哈希，它可能和调用任何经过审计的内部依赖一样安全。

### 隐私和资金轨迹

如果一个应用程序只需要用其密钥签名消息，并且不需要资金，那么这个 EIP 允许通过为每个应用程序使用不同的密钥来实现隐私，且具有简单的确定性标准，兼容各种钱包。

然而，如果这些应用密钥需要资金，则可能会有轨迹，使用应用密钥并不能完全解决隐私问题。

混合器或匿名方式为以太坊地址提供资金（环签名）与此提案结合将保证隐私。

即使没有这种匿名资金方法，隐私问题没有完全解决，我们仍然需要一种简单的方法来为每个应用程序轻松创建和恢复不同的账户/地址。

## 向后兼容性
从钱包的角度来看，似乎没有兼容性问题，因为这些是与之前钱包使用的账户分开的账户，并且它们应该能够协同使用。

然而，对于以某种方式将其用户与其主账户关联的应用程序，可能需要考虑它们希望如何利用 `app keys` 提供的能力来迁移到它们并利用它们允许的新应用设计。

## 实现

这是标准（非硬件）MetaMask 账户的应用密钥的早期实现。
https://github.com/MetaMask/eth-simple-keyring/blob/6d12bd9d73adcccbe0b0c7e32a99d279085e2934/index.js#L139-L152

请参见此处的 MetaMask 分支，它实现了与插件一起的应用密钥：
https://github.com/MetaMask/metamask-snaps-beta
https://github.com/MetaMask/metamask-snaps-beta/wiki/Plugin-API

## 示例用例

* 签名交易而不广播它们
https://github.com/MetaMask/metamask-extension/issues/3475

* 代币合约
https://github.com/ethereum/EIPs/issues/85

* dapps 的默认账户
https://ethereum-magicians.org/t/default-accounts-for-dapps/904

* 非钱包/加密账户
[EIP1581: 从 BIP32 树派生的密钥的非钱包使用](./eip-1581.md)

* 状态通道应用

* 隐私解决方案

* 非托管跨加密货币交易所...

## 致谢
MetaMask 团队，Christian Lundkvist，Counterfactual 团队，Liam Horne，Erik Bryn，Richard Moore，Jeff Coleman。


## 参考文献

### HD 和助记词
#### BIPs
* [BIP32: 分层确定性钱包：](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)

* [BIP39: 生成确定性密钥的助记码：](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)

* [SLIP44: BIP44 注册币种类型](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)


#### 以太坊的派生路径
* [问题 84](https://github.com/ethereum/EIPs/issues/84)

* [问题 85](https://github.com/ethereum/EIPs/issues/85)

* [EIP600 以太坊目的分配给确定性钱包](./eip-600.md)


* [EIP601 以太坊确定性钱包的层次结构](./eip-601.md)


### 与应用密钥相关的先前提案和讨论
* [Meta: 我们应该更重视隐私](https://ethereum-magicians.org/t/meta-we-should-value-privacy-more/2475)

* [EIP1102: 自愿账户曝光](./eip-1102.md)

* [EIP1581: 从 BIP-32 树派生的密钥的非钱包使用](./eip-1581.md)

* [EIP1581: 讨论](https://ethereum-magicians.org/t/non-wallet-usage-of-keys-derived-from-bip-32-trees/1817/4)

* [SLIP13: 使用确定性层次进行身份验证](https://github.com/satoshilabs/slips/blob/master/slip-0013.md)


## 版权
版权及相关权利通过 [CC0](../LICENSE.md) 放弃。