---
eip: 1820
title: 伪自省注册合约
author: Jordi Baylina <jordi@baylina.cat>, Jacques Dafflon <mail@0xjac.com>
discussions-to: https://github.com/ethereum/EIPs/pull/1820
status: 最终
type: 标准跟踪
category: ERC
requires: 165, 214
created: 2019-03-04
---

> :information_source: **[ERC-1820] 已取代 [ERC-820]。** :information_source:  
> [ERC-1820] 修复了 [ERC-165] 逻辑中的不兼容性，该不兼容性是由 Solidity 0.5 更新引入的。  
> 请查看 [官方公告][erc1820-annoucement]，以及关于 [bug][erc820-bug] 和 [修复][erc820-fix] 的评论。  
> 除了这个修复，[ERC-1820] 在功能上等同于 [ERC-820]。
>
> :warning: [ERC-1820] 必须替代 [ERC-820] 使用。 :warning:

## 简单总结

该标准定义了一个通用注册智能合约，任何地址（合约或普通账户）都可以注册其支持的接口以及负责其实现的智能合约。

该标准与 [ERC-165] 保持向后兼容。

## 摘要

该标准定义了一个注册表，智能合约和普通账户可以发布它们实现的功能——无论是直接实现还是通过代理合约。

任何人都可以查询该注册表，以询问特定地址是否实现了给定接口，以及哪个智能合约处理其实现。

该注册表可以在任何链上部署，并在所有链上共享相同的地址。

最后 28 字节为零 (`0`) 的接口被视为 [ERC-165] 接口，
该注册表将调用转发到合约，以查看其是否实现了该接口。

该合约还充当 [ERC-165] 缓存，以减少 gas 消耗。

## 动机

在以太坊中定义伪自省的方式有多种不同的方法。
第一个是 [ERC-165]，其限制在于普通账户无法使用。
第二个尝试是 [ERC-672]，它使用反向 [ENS]。使用反向 [ENS] 存在两个问题。
首先，它不必要地复杂，其次，[ENS] 仍然是由多签控制的中心化合约。
这个多签理论上可以修改系统。

该标准比 [ERC-672] 简单得多，并且是 *完全* 去中心化的。

该标准还为所有链提供了 *唯一* 地址。
从而解决了为不同链解析正确注册表地址的问题。

## 规范

### [ERC-1820] 注册智能合约

> 这是 [ERC1820 注册智能合约] 代码的精确副本。

``` solidity
/* ERC1820 Pseudo-introspection Registry Contract
 * This standard defines a universal registry smart contract where any address (contract or regular account) can
 * register which interface it supports and which smart contract is responsible for its implementation.
 *
 * Written in 2019 by Jordi Baylina and Jacques Dafflon
 *
 * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to
 * this software to the public domain worldwide. This software is distributed without any warranty.
 *
 * You should have received a copy of the CC0 Public Domain Dedication along with this software. If not, see
 * <http://creativecommons.org/publicdomain/zero/1.0/>.
 *
 *    ███████╗██████╗  ██████╗ ██╗ █████╗ ██████╗  ██████╗
 *    ██╔════╝██╔══██╗██╔════╝███║██╔══██╗╚════██╗██╔═████╗
 *    █████╗  ██████╔╝██║     ╚██║╚█████╔╝ █████╔╝██║██╔██║
 *    ██╔══╝  ██╔══██╗██║      ██║██╔══██╗██╔═══╝ ████╔╝██║
 *    ███████╗██║  ██║╚██████╗ ██║╚█████╔╝███████╗╚██████╔╝
 *    ╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═╝ ╚════╝ ╚══════╝ ╚═════╝
 *
 *    ██████╗ ███████╗ ██████╗ ██╗███████╗████████╗██████╗ ██╗   ██╗
 *    ██╔══██╗██╔════╝██╔════╝ ██║██╔════╝╚══██╔══╝██╔══██╗╚██╗ ██╔╝
 *    ██████╔╝█████╗  ██║  ███╗██║███████╗   ██║   ██████╔╝ ╚████╔╝
 *    ██╔══██╗██╔══╝  ██║   ██║██║╚════██║   ██║   ██╔══██╗  ╚██╔╝
 *    ██║  ██║███████╗╚██████╔╝██║███████║   ██║   ██║  ██║   ██║
 *    ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝
 *
 */
pragma solidity 0.5.3;
// IV is value needed to have a vanity address starting with '0x1820'.
// IV: 53759

/// @dev The interface a contract MUST implement if it is the implementer of
/// some (other) interface for any address other than itself.
interface ERC1820ImplementerInterface {
    /// @notice Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.
    /// @param interfaceHash keccak256 hash of the name of the interface
    /// @param addr Address for which the contract will implement the interface
    /// @return ERC1820_ACCEPT_MAGIC only if the contract implements 'interfaceHash' for the address 'addr'.
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);
}


/// @title ERC1820 Pseudo-introspection Registry Contract
/// @author Jordi Baylina and Jacques Dafflon
/// @notice This contract is the official implementation of the ERC1820 Registry.
/// @notice For more details, see https://eips.ethereum.org/EIPS/eip-1820
contract ERC1820Registry {
    /// @notice ERC165 Invalid ID.
    bytes4 constant internal INVALID_ID = 0xffffffff;
    /// @notice Method ID for the ERC165 supportsInterface method (= `bytes4(keccak256('supportsInterface(bytes4)'))`).
    bytes4 constant internal ERC165ID = 0x01ffc9a7;
    /// @notice Magic value which is returned if a contract implements an interface on behalf of some other address.
    bytes32 constant internal ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked("ERC1820_ACCEPT_MAGIC"));

    /// @notice mapping from addresses and interface hashes to their implementers.
    mapping(address => mapping(bytes32 => address)) internal interfaces;
    /// @notice mapping from addresses to their manager.
    mapping(address => address) internal managers;
    /// @notice flag for each address and erc165 interface to indicate if it is cached.
    mapping(address => mapping(bytes4 => bool)) internal erc165Cached;

    /// @notice Indicates a contract is the 'implementer' of 'interfaceHash' for 'addr'.
    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);
    /// @notice Indicates 'newManager' is the address of the new manager for 'addr'.
    event ManagerChanged(address indexed addr, address indexed newManager);

    /// @notice Query if an address implements an interface and through which contract.
    /// @param _addr Address being queried for the implementer of an interface.
    /// (If '_addr' is the zero address then 'msg.sender' is assumed.)
    /// @param _interfaceHash Keccak256 hash of the name of the interface as a string.
    /// E.g., 'web3.utils.keccak256("ERC777TokensRecipient")' for the 'ERC777TokensRecipient' interface.
    /// @return The address of the contract which implements the interface '_interfaceHash' for '_addr'
    /// or '0' if '_addr' did not register an implementer for this interface.
    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address) {
        address addr = _addr == address(0) ? msg.sender : _addr;
        if (isERC165Interface(_interfaceHash)) {
            bytes4 erc165InterfaceHash = bytes4(_interfaceHash);
            return implementsERC165Interface(addr, erc165InterfaceHash) ? addr : address(0);
        }
        return interfaces[addr][_interfaceHash];
    }

    /// @notice Sets the contract which implements a specific interface for an address.
    /// Only the manager defined for that address can set it.
    /// (Each address is the manager for itself until it sets a new manager.)
    /// @param _addr Address for which to set the interface.
    /// (If '_addr' is the zero address then 'msg.sender' is assumed.)
    /// @param _interfaceHash Keccak256 hash of the name of the interface as a string.
    /// E.g., 'web3.utils.keccak256("ERC777TokensRecipient")' for the 'ERC777TokensRecipient' interface.
    /// @param _implementer Contract address implementing '_interfaceHash' for '_addr'.
    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {
        address addr = _addr == address(0) ? msg.sender : _addr;
        require(getManager(addr) == msg.sender, "Not the manager");

        require(!isERC165Interface(_interfaceHash), "Must not be an ERC165 hash");
        if (_implementer != address(0) && _implementer != msg.sender) {
            require(
                ERC1820ImplementerInterface(_implementer)
                    .canImplementInterfaceForAddress(_interfaceHash, addr) == ERC1820_ACCEPT_MAGIC,
                "Does not implement the interface"
            );
        }
        interfaces[addr][_interfaceHash] = _implementer;
        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);
    }

    /// @notice Sets '_newManager' as manager for '_addr'.
    /// The new manager will be able to call 'setInterfaceImplementer' for '_addr'.
    /// @param _addr Address for which to set the new manager.
    /// @param _newManager Address of the new manager for 'addr'. (Pass '0x0' to reset the manager to '_addr'.)
    function setManager(address _addr, address _newManager) external {
        require(getManager(_addr) == msg.sender, "Not the manager");
        managers[_addr] = _newManager == _addr ? address(0) : _newManager;
        emit ManagerChanged(_addr, _newManager);
    }

    /// @notice Get the manager of an address.
    /// @param _addr Address for which to return the manager.
    /// @return Address of the manager for a given address.
    function getManager(address _addr) public view returns(address) {
        // By default the manager of an address is the same address
        if (managers[_addr] == address(0)) {
            return _addr;
        } else {
            return managers[_addr];
        }
    }

    /// @notice Compute the keccak256 hash of an interface given its name.
    /// @param _interfaceName Name of the interface.
    /// @return The keccak256 hash of an interface name.
    function interfaceHash(string calldata _interfaceName) external pure returns(bytes32) {
        return keccak256(abi.encodePacked(_interfaceName));
    }

    /* --- ERC165 Related Functions --- */
    /* --- Developed in collaboration with William Entriken. --- */

    /// @notice Updates the cache with whether the contract implements an ERC165 interface or not.
    /// @param _contract Address of the contract for which to update the cache.
    /// @param _interfaceId ERC165 interface for which to update the cache.
    function updateERC165Cache(address _contract, bytes4 _interfaceId) external {
        interfaces[_contract][_interfaceId] = implementsERC165InterfaceNoCache(
            _contract, _interfaceId) ? _contract : address(0);
        erc165Cached[_contract][_interfaceId] = true;
    }

    /// @notice Checks whether a contract implements an ERC165 interface or not.
    //  If the result is not cached a direct lookup on the contract address is performed.
    //  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling
    //  'updateERC165Cache' with the contract address.
    /// @param _contract Address of the contract to check.
    /// @param _interfaceId ERC165 interface to check.
    /// @return True if '_contract' implements '_interfaceId', false otherwise.
    function implementsERC165Interface(address _contract, bytes4 _interfaceId) public view returns (bool) {
        if (!erc165Cached[_contract][_interfaceId]) {
            return implementsERC165InterfaceNoCache(_contract, _interfaceId);
        }
        return interfaces[_contract][_interfaceId] == _contract;
    }

    /// @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.
    /// @param _contract Address of the contract to check.
    /// @param _interfaceId ERC165 interface to check.
    /// @return True if '_contract' implements '_interfaceId', false otherwise.
    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {
        uint256 success;
        uint256 result;

        (success, result) = noThrowCall(_contract, ERC165ID);
        if (success == 0 || result == 0) {
            return false;
        }

        (success, result) = noThrowCall(_contract, INVALID_ID);
        if (success == 0 || result != 0) {
            return false;
        }

        (success, result) = noThrowCall(_contract, _interfaceId);
        if (success == 1 && result == 1) {
            return true;
        }
        return false;
    }

    /// @notice Checks whether the hash is a ERC165 interface (ending with 28 zeroes) or not.
    /// @param _interfaceHash The hash to check.
    /// @return True if '_interfaceHash' is an ERC165 interface (ending with 28 zeroes), false otherwise.
    function isERC165Interface(bytes32 _interfaceHash) internal pure returns (bool) {
        return _interfaceHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0;
    }

    /// @dev Make a call on a contract without throwing if the function does not exist.
    function noThrowCall(address _contract, bytes4 _interfaceId)
        internal view returns (uint256 success, uint256 result)
    {
        bytes4 erc165ID = ERC165ID;

        assembly {
            let x := mload(0x40)               // Find empty storage location using "free memory pointer"
            mstore(x, erc165ID)                // Place signature at beginning of empty storage
            mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature

            success := staticcall(
                30000,                         // 30k gas
                _contract,                     // To addr
                x,                             // Inputs are stored at location x
                0x24,                          // Inputs are 36 (4 + 32) bytes long
                x,                             // Store output over input (saves space)
                0x20                           // Outputs are 32 bytes long
            )

            result := mload(x)                 // Load the result
        }
    }
}

```

### 部署交易

以下是必须用于在任何链上部署智能合约的原始交易。

```
0xf90a388085174876e800830c35008080b909e5608060405234801561001057600080fd5b506109c5806100206000396000f3fe608060405234801561001057600080fd5b50600436106100a5576000357c010000000000000000000000000000000000000000000000000000000090048063a41e7d5111610078578063a41e7d51146101d4578063aabbb8ca1461020a578063b705676514610236578063f712f3e814610280576100a5565b806329965a1d146100aa5780633d584063146100e25780635df8122f1461012457806365ba36c114610152575b600080fd5b6100e0600480360360608110156100c057600080fd5b50600160a060020a038135811691602081013591604090910135166102b6565b005b610108600480360360208110156100f857600080fd5b5035600160a060020a0316610570565b60408051600160a060020a039092168252519081900360200190f35b6100e06004803603604081101561013a57600080fd5b50600160a060020a03813581169160200135166105bc565b6101c26004803603602081101561016857600080fd5b81019060208101813564010000000081111561018357600080fd5b82018360208201111561019557600080fd5b803590602001918460018302840111640100000000831117156101b757600080fd5b5090925090506106b3565b60408051918252519081900360200190f35b6100e0600480360360408110156101ea57600080fd5b508035600160a060020a03169060200135600160e060020a0319166106ee565b6101086004803603604081101561022057600080fd5b50600160a060020a038135169060200135610778565b61026c6004803603604081101561024c57600080fd5b508035600160a060020a03169060200135600160e060020a0319166107ef565b604080519115158252519081900360200190f35b61026c6004803603604081101561029657600080fd5b508035600160a060020a03169060200135600160e060020a0319166108aa565b6000600160a060020a038416156102cd57836102cf565b335b9050336102db82610570565b600160a060020a031614610339576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b6103428361092a565b15610397576040805160e560020a62461bcd02815260206004820152601a60248201527f4d757374206e6f7420626520616e204552433136352068617368000000000000604482015290519081900360640190fd5b600160a060020a038216158015906103b85750600160a060020a0382163314155b156104ff5760405160200180807f455243313832305f4143434550545f4d4147494300000000000000000000000081525060140190506040516020818303038152906040528051906020012082600160a060020a031663249cb3fa85846040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083815260200182600160a060020a0316600160a060020a031681526020019250505060206040518083038186803b15801561047e57600080fd5b505afa158015610492573d6000803e3d6000fd5b505050506040513d60208110156104a857600080fd5b5051146104ff576040805160e560020a62461bcd02815260206004820181905260248201527f446f6573206e6f7420696d706c656d656e742074686520696e74657266616365604482015290519081900360640190fd5b600160a060020a03818116600081815260208181526040808320888452909152808220805473ffffffffffffffffffffffffffffffffffffffff19169487169485179055518692917f93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db15391a450505050565b600160a060020a03818116600090815260016020526040812054909116151561059a5750806105b7565b50600160a060020a03808216600090815260016020526040902054165b919050565b336105c683610570565b600160a060020a031614610624576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b81600160a060020a031681600160a060020a0316146106435780610646565b60005b600160a060020a03838116600081815260016020526040808220805473ffffffffffffffffffffffffffffffffffffffff19169585169590951790945592519184169290917f605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a43509190a35050565b600082826040516020018083838082843780830192505050925050506040516020818303038152906040528051906020012090505b92915050565b6106f882826107ef565b610703576000610705565b815b600160a060020a03928316600081815260208181526040808320600160e060020a031996909616808452958252808320805473ffffffffffffffffffffffffffffffffffffffff19169590971694909417909555908152600284528181209281529190925220805460ff19166001179055565b600080600160a060020a038416156107905783610792565b335b905061079d8361092a565b156107c357826107ad82826108aa565b6107b85760006107ba565b815b925050506106e8565b600160a060020a0390811660009081526020818152604080832086845290915290205416905092915050565b6000808061081d857f01ffc9a70000000000000000000000000000000000000000000000000000000061094c565b909250905081158061082d575080155b1561083d576000925050506106e8565b61084f85600160e060020a031961094c565b909250905081158061086057508015155b15610870576000925050506106e8565b61087a858561094c565b909250905060018214801561088f5750806001145b1561089f576001925050506106e8565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108f2576108eb83836107ef565b90506106e8565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160248189617530fa90519096909550935050505056fea165627a7a72305820377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c00291ba01820182018201820182018201820182018201820182018201820182018201820a01820182018201820182018201820182018201820182018201820182018201820
```

交易末尾的 `1820` 字符串是签名的 `r` 和 `s`。
根据这个确定性模式（由人生成），任何人都可以推断出没有人知道部署账户的私钥。

### 部署方法

该合约将使用无密钥部署方法进行部署——也称为 [Nick] 的方法——该方法依赖于一次性地址。
（有关更多详细信息，请参见 [Nick's article]）。该方法的工作方式如下：

1. 生成一个从新随机账户部署合约的交易。
  - 此交易必须不使用 [EIP-155] 以便在任何链上工作。
  - 此交易必须具有相对较高的 gas 价格，以便在任何链上部署。在这种情况下，将为 100 Gwei。

2. 将交易签名的 `v`、`r`、`s` 设置为以下值：

   ```
   v: 27,
   r: 0x1820182018201820182018201820182018201820182018201820182018201820'
   s: 0x1820182018201820182018201820182018201820182018201820182018201820'
   ```

   这些 `r` 和 `s` 值——由重复的 `1820` 字符串组成——是由人确定性生成的“随机数”。

3. 我们恢复该交易的发送者，即一次性部署账户。

    > 因此，我们获得了一个可以广播该交易的账户，但我们也有保证，没有人知道该账户的私钥。

4. 向该一次性部署账户发送确切的 0.08 以太。

5. 广播部署交易。

此操作可以在任何链上完成，确保合约地址始终相同，并且没有人可以使用该地址与不同的合约。

### 一次性注册部署账户

```
0xa990077c3205cbDf861e17Fa532eeB069cE9fF96
```

该账户是通过从其交易签名反向工程生成的。
这样没有人知道私钥，但已知它是部署交易的有效签名者。

> 要部署注册表，必须 *首先* 向该账户发送 0.08 以太。

### 注册合约地址

```
0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24
```

该合约在其部署的每个链上都有上述地址。

<details>
<summary>原始元数据 <code>./contracts/ERC1820Registry.sol</code></summary>

```json
{
        "compiler": {
          "version": "0.5.3+commit.10d17f24"
        },
        "language": "Solidity",
        "output": {
          "abi": [
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                },
                {
                  "name": "_interfaceHash",
                  "type": "bytes32"
                },
                {
                  "name": "_implementer",
                  "type": "address"
                }
              ],
              "name": "setInterfaceImplementer",
              "outputs": [],
              "payable": false,
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                }
              ],
              "name": "getManager",
              "outputs": [
                {
                  "name": "",
                  "type": "address"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                },
                {
                  "name": "_newManager",
                  "type": "address"
                }
              ],
              "name": "setManager",
              "outputs": [],
              "payable": false,
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_interfaceName",
                  "type": "string"
                }
              ],
              "name": "interfaceHash",
              "outputs": [
                {
                  "name": "",
                  "type": "bytes32"
                }
              ],
              "payable": false,
              "stateMutability": "pure",
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_contract",
                  "type": "address"
                },
                {
                  "name": "_interfaceId",
                  "type": "bytes4"
                }
              ],
              "name": "updateERC165Cache",
              "outputs": [],
              "payable": false,
              "stateMutability": "nonpayable",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_addr",
                  "type": "address"
                },
                {
                  "name": "_interfaceHash",
                  "type": "bytes32"
                }
              ],
              "name": "getInterfaceImplementer",
              "outputs": [
                {
                  "name": "",
                  "type": "address"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_contract",
                  "type": "address"
                },
                {
                  "name": "_interfaceId",
                  "type": "bytes4"
                }
              ],
              "name": "implementsERC165InterfaceNoCache",
              "outputs": [
                {
                  "name": "",
                  "type": "bool"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_contract",
                  "type": "address"
                },
                {
                  "name": "_interfaceId",
                  "type": "bytes4"
                }
              ],
              "name": "implementsERC165Interface",
              "outputs": [
                {
                  "name": "",
                  "type": "bool"
                }
              ],
              "payable": false,
              "stateMutability": "view",
              "type": "function"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "name": "addr",
                  "type": "address"
                },
                {
                  "indexed": true,
                  "name": "interfaceHash",
                  "type": "bytes32"
                },
                {
                  "indexed": true,
                  "name": "implementer",
                  "type": "address"
                }
              ],
              "name": "InterfaceImplementerSet",
              "type": "event"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "name": "addr",
                  "type": "address"
                },
                {
                  "indexed": true,
                  "name": "newManager",
                  "type": "address"
                }
              ],
              "name": "ManagerChanged",
              "type": "event"
            }
          ],
          "devdoc": {
            "author": "Jordi Baylina and Jacques Dafflon",
            "methods": {
              "getInterfaceImplementer(address,bytes32)": {
                "params": {
                  "_addr": "Address being queried for the implementer of an interface. (If '_addr' is the zero address then 'msg.sender' is assumed.)",
                  "_interfaceHash": "Keccak256 hash of the name of the interface as a string. E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface."
                },
                "return": "The address of the contract which implements the interface '_interfaceHash' for '_addr' or '0' if '_addr' did not register an implementer for this interface."
              },
              "getManager(address)": {
                "params": {
                  "_addr": "Address for which to return the manager."
                },
                "return": "Address of the manager for a given address."
              },
              "implementsERC165Interface(address,bytes4)": {
                "params": {
                  "_contract": "Address of the contract to check.",
                  "_interfaceId": "ERC165 interface to check."
                },
                "return": "True if '_contract' implements '_interfaceId', false otherwise."
              },
              "implementsERC165InterfaceNoCache(address,bytes4)": {
                "params": {
                  "_contract": "Address of the contract to check.",
                  "_interfaceId": "ERC165 interface to check."
                },
                "return": "True if '_contract' implements '_interfaceId', false otherwise."
              },
              "interfaceHash(string)": {
                "params": {
                  "_interfaceName": "Name of the interface."
                },
                "return": "The keccak256 hash of an interface name."
              },
              "setInterfaceImplementer(address,bytes32,address)": {
                "params": {
                  "_addr": "Address for which to set the interface. (If '_addr' is the zero address then 'msg.sender' is assumed.)",
                  "_implementer": "Contract address implementing '_interfaceHash' for '_addr'.",
                  "_interfaceHash": "Keccak256 hash of the name of the interface as a string. E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface."
                }
              },
              "setManager(address,address)": {
                "params": {
                  "_addr": "Address for which to set the new manager.",
                  "_newManager": "Address of the new manager for 'addr'. (Pass '0x0' to reset the manager to '_addr'.)"
                }
              },
              "updateERC165Cache(address,bytes4)": {
                "params": {
                  "_contract": "Address of the contract for which to update the cache.",
                  "_interfaceId": "ERC165 interface for which to update the cache."
                }
              }
            },
            "title": "ERC1820 Pseudo-introspection Registry Contract"
          },
          "userdoc": {
            "methods": {
              "getInterfaceImplementer(address,bytes32)": {
                "notice": "Query if an address implements an interface and through which contract."
              },
              "getManager(address)": {
                "notice": "Get the manager of an address."
              },
              "implementsERC165InterfaceNoCache(address,bytes4)": {
                "notice": "Checks whether a contract implements an ERC165 interface or not without using nor updating the cache."
              },
              "interfaceHash(string)": {
                "notice": "Compute the keccak256 hash of an interface given its name."
              },
              "setInterfaceImplementer(address,bytes32,address)": {
                "notice": "Sets the contract which implements a specific interface for an address. Only the manager defined for that address can set it. (Each address is the manager for itself until it sets a new manager.)"
              },
              "setManager(address,address)": {
                "notice": "Sets '_newManager' as manager for '_addr'. The new manager will be able to call 'setInterfaceImplementer' for '_addr'."
              },
              "updateERC165Cache(address,bytes4)": {
                "notice": "Updates the cache with whether the contract implements an ERC165 interface or not."
              }
            },
            "notice": "This contract is the official implementation of the ERC1820 Registry.For more details, see https://eips.ethereum.org/EIPS/eip-1820"
          }
        },
        "settings": {
          "compilationTarget": {
            "./contracts/ERC1820Registry.sol": "ERC1820Registry"
          },
          "evmVersion": "byzantium",
          "libraries": {},
          "optimizer": {
            "enabled": true,
            "runs": 200
          },
          "remappings": []
        },
        "sources": {
          "./contracts/ERC1820Registry.sol": {
            "content": "/* ERC1820 Pseudo-introspection Registry Contract\n * This standard defines a universal registry smart contract where any address (contract or regular account) can\n * register which interface it supports and which smart contract is responsible for its implementation.\n *\n * Written in 2019 by Jordi Baylina and Jacques Dafflon\n *\n * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to\n * this software to the public domain worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n *\n *    ███████╗██████╗  ██████╗ ██╗ █████╗ ██████╗  ██████╗\n *    ██╔════╝██╔══██╗██╔════╝███║██╔══██╗╚════██╗██╔═████╗\n *    █████╗  ██████╔╝██║     ╚██║╚█████╔╝ █████╔╝██║██╔██║\n *    ██╔══╝  ██╔══██╗██║      ██║██╔══██╗██╔═══╝ ████╔╝██║\n *    ███████╗██║  ██║╚██████╗ ██║╚█████╔╝███████╗╚██████╔╝\n *    ╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═╝ ╚════╝ ╚══════╝ ╚═════╝\n *\n *    ██████╗ ███████╗ ██████╗ ██╗███████╗████████╗██████╗ ██╗   ██╗\n *    ██╔══██╗██╔════╝██╔════╝ ██║██╔════╝╚══██╔══╝██╔══██╗╚██╗ ██╔╝\n *    ██████╔╝█████╗  ██║  ███╗██║███████╗   ██║   ██████╔╝ ╚████╔╝\n *    ██╔══██╗██╔══╝  ██║   ██║██║╚════██║   ██║   ██╔══██╗  ╚██╔╝\n *    ██║  ██║███████╗╚██████╔╝██║███████║   ██║   ██║  ██║   ██║\n *    ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝\n *\n */\npragma solidity 0.5.3;\n// IV is value needed to have a vanity address starting with '0x1820'.\n// IV: 53759\n\n/// @dev The interface a contract MUST implement if it is the implementer of\n/// some (other) interface for any address other than itself.\ninterface ERC1820ImplementerInterface {\n    /// @notice Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.\n    /// @param interfaceHash keccak256 hash of the name of the interface\n    /// @param addr Address for which the contract will implement the interface\n    /// @return ERC1820_ACCEPT_MAGIC only if the contract implements 'interfaceHash' for the address 'addr'.\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);\n}\n\n\n/// @title ERC1820 Pseudo-introspection Registry Contract\n/// @author Jordi Baylina and Jacques Dafflon\n/// @notice This contract is the official implementation of the ERC1820 Registry.\n/// @notice For more details, see https://eips.ethereum.org/EIPS/eip-1820\ncontract ERC1820Registry {\n    /// @notice ERC165 Invalid ID.\n    bytes4 constant internal INVALID_ID = 0xffffffff;\n    /// @notice Method ID for the ERC165 supportsInterface method (= `bytes4(keccak256('supportsInterface(bytes4)'))`).\n    bytes4 constant internal ERC165ID = 0x01ffc9a7;\n    /// @notice Magic value which is returned if a contract implements an interface on behalf of some other address.\n    bytes32 constant internal ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\n\n    /// @notice mapping from addresses and interface hashes to their implementers.\n    mapping(address => mapping(bytes32 => address)) internal interfaces;\n    /// @notice mapping from addresses to their manager.\n    mapping(address => address) internal managers;\n    /// @notice flag for each address and erc165 interface to indicate if it is cached.\n    mapping(address => mapping(bytes4 => bool)) internal erc165Cached;\n\n    /// @notice Indicates a contract is the 'implementer' of 'interfaceHash' for 'addr'.\n    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);\n    /// @notice Indicates 'newManager' is the address of the new manager for 'addr'.\n    event ManagerChanged(address indexed addr, address indexed newManager);\n\n    /// @notice Query if an address implements an interface and through which contract.\n    /// @param _addr Address being queried for the implementer of an interface.\n    /// (If '_addr' is the zero address then 'msg.sender' is assumed.)\n    /// @param _interfaceHash Keccak256 hash of the name of the interface as a string.\n    /// E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface.\n    /// @return The address of the contract which implements the interface '_interfaceHash' for '_addr'\n    /// or '0' if '_addr' did not register an implementer for this interface.\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address) {\n        address addr = _addr == address(0) ? msg.sender : _addr;\n        if (isERC165Interface(_interfaceHash)) {\n            bytes4 erc165InterfaceHash = bytes4(_interfaceHash);\n            return implementsERC165Interface(addr, erc165InterfaceHash) ? addr : address(0);\n        }\n        return interfaces[addr][_interfaceHash];\n    }\n\n    /// @notice Sets the contract which implements a specific interface for an address.\n    /// Only the manager defined for that address can set it.\n    /// (Each address is the manager for itself until it sets a new manager.)\n    /// @param _addr Address for which to set the interface.\n    /// (If '_addr' is the zero address then 'msg.sender' is assumed.)\n    /// @param _interfaceHash Keccak256 hash of the name of the interface as a string.\n    /// E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface.\n    /// @param _implementer Contract address implementing '_interfaceHash' for '_addr'.\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {\n        address addr = _addr == address(0) ? msg.sender : _addr;\n        require(getManager(addr) == msg.sender, \"Not the manager\");\n\n        require(!isERC165Interface(_interfaceHash), \"Must not be an ERC165 hash\");\n        if (_implementer != address(0) && _implementer != msg.sender) {\n            require(\n                ERC1820ImplementerInterface(_implementer)\n                    .canImplementInterfaceForAddress(_interfaceHash, addr) == ERC1820_ACCEPT_MAGIC,\n                \"Does not implement the interface\"\n            );\n        }\n        interfaces[addr][_interfaceHash] = _implementer;\n        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);\n    }\n\n    /// @notice Sets '_newManager' as manager for '_addr'.\n    /// The new manager will be able to call 'setInterfaceImplementer' for '_addr'.\n    /// @param _addr Address for which to set the new manager.\n    /// @param _newManager Address of the new manager for 'addr'. (Pass '0x0' to reset the manager to '_addr'.)\n    function setManager(address _addr, address _newManager) external {\n        require(getManager(_addr) == msg.sender, \"Not the manager\");\n        managers[_addr] = _newManager == _addr ? address(0) : _newManager;\n        emit ManagerChanged(_addr, _newManager);\n    }\n\n    /// @notice Get the manager of an address.\n    /// @param _addr Address for which to return the manager.\n    /// @return Address of the manager for a given address.\n    function getManager(address _addr) public view returns(address) {\n        // By default the manager of an address is the same address\n        if (managers[_addr] == address(0)) {\n            return _addr;\n        } else {\n            return managers[_addr];\n        }\n    }\n\n    /// @notice Compute the keccak256 hash of an interface given its name.\n    /// @param _interfaceName Name of the interface.\n    /// @return The keccak256 hash of an interface name.\n    function interfaceHash(string calldata _interfaceName) external pure returns(bytes32) {\n        return keccak256(abi.encodePacked(_interfaceName));\n    }\n\n    /* --- ERC165 Related Functions --- */\n    /* --- Developed in collaboration with William Entriken. --- */\n\n    /// @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n    /// @param _contract Address of the contract for which to update the cache.\n    /// @param _interfaceId ERC165 interface for which to update the cache.\n    function updateERC165Cache(address _contract, bytes4 _interfaceId) external {\n        interfaces[_contract][_interfaceId] = implementsERC165InterfaceNoCache(\n            _contract, _interfaceId) ? _contract : address(0);\n        erc165Cached[_contract][_interfaceId] = true;\n    }\n\n    /// @notice Checks whether a contract implements an ERC165 interface or not.\n    //  If the result is not cached a direct lookup on the contract address is performed.\n    //  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n    //  'updateERC165Cache' with the contract address.\n    /// @param _contract Address of the contract to check.\n    /// @param _interfaceId ERC165 interface to check.\n    /// @return True if '_contract' implements '_interfaceId', false otherwise.\n    function implementsERC165Interface(address _contract, bytes4 _interfaceId) public view returns (bool) {\n        if (!erc165Cached[_contract][_interfaceId]) {\n            return implementsERC165InterfaceNoCache(_contract, _interfaceId);\n        }\n        return interfaces[_contract][_interfaceId] == _contract;\n    }\n\n    /// @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n    /// @param _contract Address of the contract to check.\n    /// @param _interfaceId ERC165 interface to check.\n    /// @return True if '_contract' implements '_interfaceId', false otherwise.\n    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {\n        uint256 success;\n        uint256 result;\n\n        (success, result) = noThrowCall(_contract, ERC165ID);\n        if (success == 0 || result == 0) {\n            return false;\n        }\n\n        (success, result) = noThrowCall(_contract, INVALID_ID);\n        if (success == 0 || result != 0) {\n            return false;\n        }\n\n        (success, result) = noThrowCall(_contract, _interfaceId);\n        if (success == 1 && result == 1) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice Checks whether the hash is a ERC165 interface (ending with 28 zeroes) or not.\n    /// @param _interfaceHash The hash to check.\n    /// @return True if '_interfaceHash' is an ERC165 interface (ending with 28 zeroes), false otherwise.\n    function isERC165Interface(bytes32 _interfaceHash) internal pure returns (bool) {\n        return _interfaceHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0;\n    }\n\n    /// @dev Make a call on a contract without throwing if the function does not exist.\n    function noThrowCall(address _contract, bytes4 _interfaceId)\n        internal view returns (uint256 success, uint256 result)\n    {\n        bytes4 erc165ID = ERC165ID;\n\n        assembly {\n            let x := mload(0x40)               // Find empty storage location using \"free memory pointer\"\n            mstore(x, erc165ID)                // Place signature at beginning of empty storage\n            mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature\n\n            success := staticcall(\n                30000,                         // 30k gas\n                _contract,                     // To addr\n                x,                             // Inputs are stored at location x\n                0x24,                          // Inputs are 36 (4 + 32) bytes long\n                x,                             // Store output over input (saves space)\n                0x20                           // Outputs are 32 bytes long\n            )\n\n            result := mload(x)                 // Load the result\n        }\n    }\n}\n",
            "keccak256": "0x64025ecebddb6e126a5075c1fd6c01de2840492668e2909cef7157040a9d1945"
          }
        },
        "version": 1
      }
```

</details>

### 接口名称

任何接口名称都使用 `keccak256` 哈希并发送到 `getInterfaceImplementer()`。

如果接口是标准的一部分，最佳实践是明确声明接口名称并链接到此发布的 [ERC-1820]，以便其他人不必来这里查找这些规则。

为了方便，注册表提供了一个在链上计算哈希的函数：

``` solidity
function interfaceHash(string _interfaceName) public pure returns(bytes32)
```

计算给定名称的接口的 keccak256 哈希。

> <small>**标识符:** `65ba36c1`</small>  
> <small>**参数**</small>  
> <small>`_interfaceName`: 接口的名称。</small>  
> <small>**返回:** 接口名称的 `keccak256` 哈希。</small>

#### **批准的 ERC**

如果接口是批准的 ERC 的一部分，则必须命名为 `ERC###XXXXX`，其中 `###` 是 ERC 的编号，XXXXX 应该是接口的 CamelCase 名称。
该接口的含义应在指定的 ERC 中定义。

示例：

- `keccak256("ERC20Token")`
- `keccak256("ERC777Token")`
- `keccak256("ERC777TokensSender")`
- `keccak256("ERC777TokensRecipient")`

#### **[ERC-165] 兼容接口**

> 与 [ERC-165] 的兼容性，包括 [ERC165 Cache]，是与 [William Entriken] 共同设计和开发的。

任何最后 28 字节为零 (`0`) 的接口应被视为 [ERC-165] 接口。

**[ERC-165] 查找**

任何人都可以通过调用以下两个函数之一，明确检查合约是否实现了 [ERC-165] 接口：

``` solidity
function implementsERC165Interface(address _contract, bytes4 _interfaceId) public view returns (bool)
```

检查合约是否实现了 [ERC-165] 接口。

如果结果未被缓存，则会直接在合约地址上执行查找。

*注意*: 如果结果未被缓存或缓存值过期，则必须通过调用 `updateERC165Cache` 使用合约地址手动更新缓存。
（有关更多详细信息，请参见 [ERC165 Cache]。）

> <small>**标识符:** `f712f3e8`</small>  
> <small>**参数**</small>  
> <small>`_contract`: 要检查的合约地址。</small>  
> <small>`_interfaceId`: 要检查的 [ERC-165] 接口。</small>  
> <small>**返回:** 如果 `_contract` 实现了 `_interfaceId`，则返回 `true`，否则返回 `false`。</small>

``` solidity
function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool)
```

检查合约是否实现了 [ERC-165] 接口，而不使用或更新缓存。

> <small>**标识符:** `b7056765`</small>  
> <small>**参数**</small>  
> <small>`_contract`: 要检查的合约地址。</small>  
> <small>`_interfaceId`: 要检查的 [ERC-165] 接口。</small>  
> <small>**返回:** 如果 `_contract` 实现了 `_interfaceId`，则返回 `true`，否则返回 `false`。</small>

**[ERC-165] 缓存** <a id="erc165-cache"></a>

是否合约实现了 [ERC-165] 接口可以手动缓存以节省 gas。

如果合约动态更改其接口并依赖于 [ERC-165] 缓存的 [ERC-1820] 注册表，则必须手动更新缓存——没有自动缓存失效或缓存更新。
理想情况下，合约在更改其接口时应自动更新缓存。
但是任何人都可以代表合约更新缓存。

缓存更新必须使用 `updateERC165Cache` 函数完成：

``` solidity
function updateERC165Cache(address _contract, bytes4 _interfaceId) external
```

> <small>**标识符:** `a41e7d51`</small>  
> <small>**参数**</small>  
> <small>`_contract`: 要更新缓存的合约地址。</small>  
> <small>`_interfaceId`: 要更新缓存的 [ERC-165] 接口。</small>

#### **私有用户定义接口**

该方案是可扩展的。
您可以自定义接口名称并提高意识，以便让其他人实现它，然后检查这些实现。
请尽情享受，但请务必不要与上述保留名称冲突。

### 为地址设置接口

任何地址要将合约设置为接口实现，必须调用 [ERC-1820] 注册表的以下函数：

``` solidity
function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external
```

为地址设置实现特定接口的合约。

只有为该地址定义的 `manager` 可以设置它。
（每个地址都是其自己的管理者，详见 [manager] 部分。）

*注意*: 如果 `_addr` 和 `_implementer` 是两个不同的地址，则：

- `_implementer` 必须实现 `ERC1820ImplementerInterface`（详见下文）。
- 在 `_implementer` 上调用 `canImplementInterfaceForAddress`，使用给定的 `_addr` 和 `_interfaceHash` 必须返回 `ERC1820_ACCEPT_MAGIC` 值。

*注意*: `_interfaceHash` 不能是 [ERC-165] 接口——它必须不以 28 个零 (`0`) 结尾。

*注意*: `_addr` 可以是 `0`，则假定为 `msg.sender`。
此默认值简化了通过多签进行的交互，其中签名的交易数据在多签实例的地址无论如何都是常量。

> <small>**标识符:** `29965a1d`</small>  
> <small>**参数**</small>  
> <small>`_addr`: 要设置接口的地址。（如果 `_addr` 是零地址，则假定为 `msg.sender`。）</small>  
> <small>`_interfaceHash`: 接口名称的 keccak256 哈希字符串，例如 `web3.utils.keccak256('ERC777TokensRecipient')` 用于 ERC777TokensRecipient 接口。</small>  
> <small>`_implementer`: 为 `_addr` 实现 `_interfaceHash` 的合约。</small>

### 获取地址的接口实现

任何人都可以查询 [ERC-1820] 注册表，以获取代表某个地址实现接口的合约地址，使用 `getInterfaceImplementer` 函数。

``` solidity
function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address)
```

查询一个地址是否实现了一个接口，以及通过哪个合约。

*注意*: 如果 `_interfaceHash` 的最后 28 字节为零 (`0`)，则前 4 字节被视为 [ERC-165] 接口，注册表将调用转发到 `_addr` 的合约，以查看其是否实现了 [ERC-165] 接口（`_interfaceHash` 的前 4 字节）。
注册表还将缓存 [ERC-165] 查询以减少 gas 消耗。任何人都可以调用 `erc165UpdateCache` 函数以更新合约是否实现接口的信息。

*注意*: `_addr` 可以是 `0`，则假定为 `msg.sender`。
此默认值与 `setInterfaceImplementer` 函数的行为一致，并简化了通过多签进行的交互，其中签名的交易数据在多签实例的地址无论如何都是常量。

> <small>**标识符:** `aabbb8ca`</small>  
> <small>**参数**</small>  
> <small>`_addr`: 查询接口实现者的地址。（如果 `_addr` 是零地址，则假定为 `msg.sender`。）</small>  
> <small>`_interfaceHash`: 接口名称的 keccak256 哈希字符串。例如 `web3.utils.keccak256('ERC777Token')`</small>  
> <small>**返回:** 实现接口 `_interfaceHash` 的合约地址，或如果 `_addr` 没有为此接口注册实现者，则返回 `0`。</small>

### 接口实现 (`ERC1820ImplementerInterface`)

``` solidity
interface ERC1820ImplementerInterface {
    /// @notice Indicates whether the contract implements the interface `interfaceHash` for the address `addr` or not.
    /// @param interfaceHash keccak256 hash of the name of the interface
    /// @param addr Address for which the contract will implement the interface
    /// @return ERC1820_ACCEPT_MAGIC only if the contract implements `interfaceHash` for the address `addr`.
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);
}
```

任何被注册为特定地址接口实现的合约必须实现该接口。
此外，如果它代表不同地址实现接口，则合约必须实现上述的 `ERC1820ImplementerInterface`。

``` solidity
function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32)
```

指示合约是否为给定地址 (`addr`) 实现接口 (`interfaceHash`)。

如果合约为给定地址 (`addr`) 实现接口 (`interfaceHash`)，则在使用 `addr` 和 `interfaceHash` 调用时必须返回 `ERC1820_ACCEPT_MAGIC`。
如果它不为给定地址 (`addr`) 实现接口 (`interfaceHash`)，则不得返回 `ERC1820_ACCEPT_MAGIC`。

> <small>**标识符:** `f0083250`</small>  
> <small>**参数**</small>  
> <small>`interfaceHash`: 实现的接口的哈希</small>  
> <small>`addr`: 接口实现的地址</small>  
> <small>**返回:** 仅当合约为地址 `addr` 实现 `interfaceHash` 时返回 `ERC1820_ACCEPT_MAGIC`。</small>

特殊值 `ERC1820_ACCEPT_MAGIC` 被定义为字符串 `"ERC1820_ACCEPT_MAGIC"` 的 `keccka256` 哈希。

``` solidity
bytes32 constant internal ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked("ERC1820_ACCEPT_MAGIC"));
```

> 返回 `ERC1820_ACCEPT_MAGIC` 而不是布尔值的原因是为了防止合约未能实现 `canImplementInterfaceForAddress` 但实现了一个不会抛出异常的回退函数的情况。在这种情况下，由于 `canImplementInterfaceForAddress` 不存在，因此调用回退函数而不抛出并返回 `1`。因此看起来好像 `canImplementInterfaceForAddress` 返回了 `true`。

### 管理者

地址（普通账户或合约）的管理者是唯一被允许为该地址注册接口实现的实体。
默认情况下，任何地址都是其自己的管理者。

管理者可以通过在注册表合约上调用 `setManager` 将其角色转移给另一个地址，指定要转移管理者的地址和新管理者的地址。

**`setManager` 函数**

``` solidity
function setManager(address _addr, address _newManager) external
```

将 `_newManager` 设置为 `_addr` 的管理者。

新管理者将能够调用 `_addr` 的 `setInterfaceImplementer`。

如果 `_newManager` 是 `0x0`，则管理者将重置为 `_addr` 本身作为管理者。

> <small>**标识符:** `5df8122f`</small>  
> <small>**参数**</small>  
> <small>`_addr`: 要设置新管理者的地址。</small>  
> <small>`_newManager`: `_addr` 的新管理者地址。（传递 `0x0` 将管理者重置为 `_addr`。）</small>

**`getManager` 函数**

``` solidity
function getManager(address _addr) public view returns(address)
```

获取地址的管理者。

> <small>**标识符:** `3d584063`</small>  
> <small>**参数**</small>  
> <small>`_addr`: 要返回管理者的地址。</small>  
> <small>**返回:** 给定地址的管理者地址。</small>

## 理由

该标准为任何类型的地址（外部拥有和合约）提供了一种实现接口并可能将接口的实现委托给代理合约的方法。
将实现委托给代理合约对于外部拥有账户是必要的，并且有助于避免重新部署现有合约，例如多签和 DAO。

注册表还可以充当 [ERC-165] 缓存，以便在查找合约是否实现特定 [ERC-165] 接口时节省 gas。
该缓存故意保持简单，没有自动缓存更新或失效。
任何人都可以通过调用 `updateERC165Cache` 函数轻松安全地更新任何接口和任何合约的缓存。

注册表使用无密钥部署方法进行部署，依赖于一次性部署地址，以确保没有人控制注册表，从而确保信任。

## 向后兼容性

该标准与 [ERC-165] 向后兼容，因为两种方法可以在不相互冲突的情况下实现。

## 测试用例

请查看 [0xjac/ERC1820] 仓库以获取完整的测试套件。

## 实现

实现可在仓库中找到：[0xjac/ERC1820]。

## 版权
版权及相关权利通过 [CC0](../LICENSE.md) 放弃。

[EIP-155]: ./eip-155.md
[ERC-165]: ./eip-165.md
[ERC-672]: https://github.com/ethereum/EIPs/issues/672
[ERC-820]: ./eip-820.md
[ERC-1820]: ./eip-1820.md
[ERC1820 注册智能合约]: https://github.com/0xjac/ERC1820/blob/master/contracts/ERC1820Registry.sol
[erc1820-annoucement]: https://github.com/ethereum/EIPs/issues/820#issuecomment-464109166
[erc820-bug]: https://github.com/ethereum/EIPs/issues/820#issuecomment-452465748
[erc820-fix]: https://github.com/ethereum/EIPs/issues/820#issuecomment-454021564
[manager]: #manager
[lookup]: #get-an-implementation-of-an-interface-for-an-address
[ERC165 Cache]: #erc165-cache
[Nick's article]: https://medium.com/@weka/how-to-send-ether-to-11-440-people-187e332566b7
[0xjac/ERC1820]: https://github.com/0xjac/ERC1820
[Nick]: https://github.com/Arachnid/
[William Entriken]: https://github.com/fulldecent
[ENS]: https://ens.domains/