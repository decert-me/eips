---
eip: 2997
title: IMPERSONATECALL 操作码
author: Sergio Demian Lerner (@SergioDemianLerner)
discussions-to: https://ethresear.ch/t/impersonatecall-opcode/8020
category: Core
type: Standards Track
status: Stagnant
created: 2020-09-24
---

## 摘要

添加一个新的操作码 `IMPERSONATECALL`，其值为 `0xf6`，其思想类似于 `CALL (0xF1)`，但它会伪装发送者，即被调用者看到的发送者与真实调用者不同。伪装的发送者地址是从真实调用者地址和一个盐值派生而来的。

## 动机

该提案使得原生多用户钱包（服务于多个用户的钱包）能够通过基于 EIP-712 的消息进行指令，从而支持元交易。多用户钱包还允许将转账操作聚合为批次，类似于 Rollups，但保持与正常链上交易相同的地址空间，因此发送者的钱包不需要升级以支持向多用户钱包的用户发送以太币或代币。此外，许多时候，赞助公司希望为其所有用户部署非托管智能钱包。赞助商不想提前支付每个用户合约的部署成本。反事实合约创建使这一点成为可能，但它迫使赞助商在用户第一次想要从其账户转出以太币或代币时创建智能钱包（或其代理合约）。该提案避免了这一额外成本，至少为每个用户节省了 42000 gas。

## 规范

`IMPERSONATECALL`: `0xf6`，接受 7 个操作数：

- `gas`: 执行代码所需的 gas 数量；
- `to`: 要执行代码的目标地址；
- `in_offset`: 输入的内存偏移量；
- `in_size`: 输入的字节大小；
- `ret_offset`: 输出的内存偏移量；
- `ret_size`: 输出的临时存储区大小。
- `salt` 是一个 `32` 字节的值（一个栈项）。

### 伪装发送者的计算

伪装的发送者地址计算为 `keccak256( 0xff ++ address ++ salt ++ zeros32)[12:]`。

- `0xff` 是一个字节，
- `address` 始终为 `20` 字节，表示真实调用者合约的地址。
- `salt` 始终为 `32` 字节。

- 字段 zeros32 对应于 32 个零字节。

该方案模拟了 `CREATE2` 地址派生，但在实际中无法与 `CREATE2` 地址空间发生冲突。

### 注意事项
- 该操作码在 gas 消耗方面的行为与 `CALL` 完全相同。
- 在被调用的上下文中，`CALLER (0x33)` 返回伪装的地址。
- 如果调用中的值转移非零，则值是从伪装账户转移的，而不是从真实调用者转移的。这可以用于从伪装账户转移以太币。

## 理由

即使 `IMPERSONATECALL` 需要对 3 个字进行哈希，意味着额外的 180 gas 成本，我们认为考虑哈希的好处并不足以补偿增加实现复杂性。

我们使用 zeros32 字段来基于与 CREATE2 相似大小的预映像进行地址派生，并重用现有的地址派生函数。我们还避免了担心 EOA 派生（65 字节预映像）、CREATE 派生（23 到 27 字节预映像，针对 32 位随机数）和 CREATE2 派生（85 字节预映像）之间的地址冲突。

一个选项是省略 zeros32 字段：IMPERSONATECALL 地址的 Keccak 预映像的结果长度为 53 字节，这不会产生地址冲突。

虽然相同的功能可以在预编译合约中提供，但我们认为使用新的操作码是更清晰的解决方案。

## 澄清

- 该 EIP 使地址冲突成为可能，但在实际中几乎不可能。

- 如果已经存在一个伪装地址的合约，则 `IMPERSONATECALL` 的执行方式相同，现有代码将不会被执行。需要注意的是，`SELFDESTRUCT` (`0xff`) 不能直接与 `IMPERSONATECALL` 一起执行，因为在伪装账户的上下文中没有操作码被执行。

## 向后兼容性

操作码编号 `0xf6` 目前未使用，并导致超出 gas 限制（OOG）异常。Solidity 使用 `INVALID (0xfe)` 操作码（在 EIP-1803 中称为 `ABORT`）来引发 OOG 异常，因此 `0xf6` 操作码不会出现在正常的 Solidity 程序中。程序员已经被建议不要在用 EVM 汇编编写的合约中包含此操作码。因此，它不会带来任何向后兼容性风险。

## 测试用例

我们提供 4 个伪装地址派生的示例：

示例 0

* 地址 `0x0000000000000000000000000000000000000000`
* 盐 `0x0000000000000000000000000000000000000000000000000000000000000000`
* 结果: `0xFFC4F52F884A02BCD5716744CD622127366F2EDF`

示例 1
* 地址 `0xdeadbeef00000000000000000000000000000000`
* 盐 `0x0000000000000000000000000000000000000000000000000000000000000000`
* 结果: `0x85F15E045E1244AC03289B48448249DC0A34AA30`

示例 2
* 地址 `0xdeadbeef00000000000000000000000000000000`
* 盐 `0x000000000000000000000000feed000000000000000000000000000000000000`
* 结果: `0x2DB27D1D6BE32C9ABFA484BA3D591101881D4B9F`

示例 3
* 地址 `0x00000000000000000000000000000000deadbeef`
* 盐 `0x00000000000000000000000000000000000000000000000000000000cafebabe`
* 结果: `0x5004E448F43EFE3C7BF32F94B83B843D03901457`

## 安全考虑

地址派生方案防止与其他已部署合约或外部拥有账户的地址冲突，因为伪装的发送者地址是从真实调用者地址和盐值派生而来的。

## 版权

版权及相关权利通过 [CC0](../LICENSE.md) 放弃。