---
eip: 1087
title: SSTORE 操作的网络 gas 计量
author: Nick Johnson (@arachnid)
discussions-to: https://ethereum-magicians.org/t/eip-net-storage-gas-metering-for-the-evm/383
status: Stagnant
type: Standards Track
category: Core
created: 2018-05-17
---

## 摘要
本 EIP 提出了对 EVM `SSTORE` 操作的 gas 收费方式的更改，以减少在不必要的情况下的过高 gas 成本，并启用合约存储的新用例。

## 动机
目前，`SSTORE` (`0x55`) 操作的收费如下：

 - 将一个槽从 0 设置为非 0 需 20,000 gas
 - 任何其他更改需 5,000 gas
 - 将一个槽从非 0 设置为 0 时可获得 10,000 gas 的退款。退款在交易结束时应用。

在交易中对存储值进行单次更新的情况下，这些 gas 成本被认为合理地反映了操作所消耗的资源。然而，这导致了对多次更新的操作序列的过高 gas 成本。

以下是一些说明问题的示例：

 - 如果一个具有空存储的合约将槽 0 设置为 1，然后再设置为 0，它将被收取 `20000 + 5000 - 10000 = 15000` gas，尽管这一操作序列并不需要任何磁盘写入。
 - 一个具有空存储的合约将槽 0 增加 5 次将被收取 `20000 + 5 * 5000 = 45000` gas，尽管这一操作序列所需的磁盘活动与单次写入相同，后者收取 20000 gas。
 - 从账户 A 到账户 B 的余额转移，然后从 B 到 C 的转移，所有账户的起始和结束余额均为非零，将花费 `5000 * 4 = 20000` gas。

解决此问题还将启用当前成本过高的新用例，其中一系列操作在交易结束时对存储没有净变化。例如，防止重入的互斥锁，或在对同一合约的多个调用之间传递上下文信息。一个这样的例子是 `approveAndCall` 操作，它允许在单个交易中发送和调用合约，而不需要该合约为新的代币标准进行更新。

## 规范
对 EVM 进行以下更改：

 - 为每个交易维护一个“脏映射”，跟踪当前交易中所有合约中已修改的所有存储槽。脏映射的作用域与存储更新相同，这意味着在后续回滚的调用中对脏映射的更改不会被保留。
 - 当存储槽写入其已包含的值时，扣除 200 gas。
 - 当存储槽的值首次更改时，该槽被标记为脏。如果该槽之前设置为 0，则扣除 20000 gas；否则，扣除 5000 gas。
 - 当已在脏映射中的存储槽被写入时，扣除 200 gas。
 - 在交易结束时，对于脏映射中的每个槽：
   - 如果该槽在交易前为 0，现在仍为 0，则退款 19800 gas。
   - 如果该槽在交易前为非零且其值未更改，则退款 4800 gas。
   - 如果该槽在交易前为非零且现在为 0，则退款 15000 gas。

在这些更改之后，仅对存储槽进行单次更改的交易将保留其现有成本。然而，进行多次更改的合约将看到显著降低的成本。重复动机部分的示例：

 - 如果一个具有空存储的合约将槽 0 设置为 1，然后再设置为 0，它将被收取 `20000 + 200 - 19800 = 400` gas，下降至 15000。
 - 一个具有空存储的合约将槽 0 增加 5 次将被收取 `20000 + 5 * 200 = 21000` gas，下降至 45000。
 - 从账户 A 到账户 B 的余额转移，然后从 B 到 C 的转移，所有账户的起始和结束余额均为非零，将花费 `5000 * 3 + 200 - 4800 = 10400` gas，下降至 20000。

## 理由
我们认为所提议的机制是减少存储 gas 成本的最简单方法，尤其是在这些成本未能反映节点实际承担的成本的情况下。考虑并驳回了几种替代设计：

 - 对 `SSTORE` 操作收取固定的 200 gas，并在交易结束时对新值或修改值额外收取 19800 / 4800 更简单，并且消除了对脏映射的需求，但将 gas 消耗的一个重要来源推到了 EVM 栈之外，并在交易结束时应用，这可能会使调试变得复杂，并减少合约限制被调用合约的 gas 消耗的能力，同时引入了 EVM 的新机制。
 - 为存储 gas 退款保持单独的退款计数器将避免退款被限制为消耗 gas 一半的问题（在这里不必要），但会增加跟踪该值的复杂性。
 - 每次将存储槽设置回其初始值时退款将引入新机制（即时退款），并使合约调用其他合约的 gas 记账变得复杂；这也可能允许以负执行成本进行合约调用。

## 向后兼容性
此 EIP 需要硬分叉来实施。

没有合约应因这一更改而增加 gas 成本，许多合约将看到 gas 消耗减少，因此预计不会出现合约层的向后兼容性问题。

## 测试用例

 - 将 x 写入一个包含 0 的存储槽，其中 x != 0（20k gas，无退款）
 - 将 y 写入一个包含 x 的存储槽，其中 x != y 且 x != 0（5k gas，无退款）
 - 将 0 写入一个包含 x 的存储槽，其中 x != 0（5k gas，10k 退款）
 - 将 0 写入一个已经包含零的存储槽（200 gas，无退款）
 - 将 x 写入一个已经包含 x 的存储槽，其中 x != 0（200 gas，无退款）
 - 将 x 写入一个包含 0 的存储槽，然后写入 y，其中 x != y（20200 gas，无退款）
 - 将 x 写入一个包含 0 的存储槽，然后写入 y，其中 x != y != z 且 x != 0（5200 gas，无退款）
 - 将 x 写入一个包含 0 的存储槽，然后写入 0，其中 x != 0（20200 gas，19800 退款）
 - 将 x 写入一个包含 y 的存储槽，然后写入 0，其中 x != y != 0（5200 gas，4800 退款）
 - 将 x 写入一个包含 0 的存储槽，然后回滚写入发生的栈帧（20200 gas，无退款）
 - 将 x 写入一个包含 y 的存储槽，然后回滚写入发生的栈帧（5200 gas，无退款）
 - 在嵌套帧中，将 x 写入一个包含 0 的存储槽，然后返回，并将 0 写入该槽（20200 gas，19800 退款）

## 实施
待定

## 版权
版权及相关权利通过 [CC0](../LICENSE.md) 放弃。