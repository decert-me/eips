---
eip: 1702
title: 通用账户版本控制方案
author: Wei Tang (@sorpaas)
discussions-to: https://github.com/sorpaas/EIPs/issues/2
status: Stagnant
type: Standards Track
category: Core
created: 2017-12-30
---

## 简单总结

为智能合约引入账户版本控制，以便更容易地升级虚拟机或引入新的虚拟机。

## 摘要

这定义了一种在保持现有账户功能的同时进行硬分叉的方法，通过允许多个版本的虚拟机在同一块中执行。这在引入链上 WebAssembly 虚拟机时也有助于定义未来的账户状态结构。

## 动机

通过允许账户版本控制，我们可以为在不同时间创建的合约执行不同的虚拟机。这允许实现破坏性特性，同时确保现有合约按预期工作。

请注意，此规范可能不适用于所有硬分叉。我们过去由于网络攻击进行了紧急硬分叉。是否应保持现有账户兼容性应逐个评估。如果攻击只能针对某些特定合约执行一次，则此处定义的方案可能仍然适用。否则，进行简单的紧急硬分叉可能仍然是个好主意。

## 规范

### 账户状态

重新定义存储在世界状态树中的账户状态，以包含 5 项：`nonce`、`balance`、`storageRoot`、`codeHash` 和 `version`。新添加的字段 `version` 是一个 256 位的 *标量*。我们使用《黄皮书》中对“标量”的定义。请注意，这与 `nonce` 和 `balance` 的类型相同，并且等同于一个没有前导零的 RLP 可变大小字节数组，最大长度为 32。

当 `version` 为零时，账户使用前 4 项进行 RLP 编码。当 `version` 不为零时，账户使用 5 项进行 RLP 编码。

账户版本还可以选择性地定义额外的账户状态 RLP 字段，其含义通过其 `version` 字段指定。在这些情况下，解析策略在“账户状态 RLP 中的附加字段”部分中定义。

### 合约执行

在从状态中获取账户代码时，我们始终一起获取相关的版本字段。我们在下面称之为 *代码的版本*。账户的代码始终在 *代码的版本* 中执行。

特别是，这意味着对于 `DELEGATECALL` 和 `CALLCODE`，执行调用帧的版本与委托/接收合约的版本相同。

### 合约部署

在以太坊中，合约有一种部署方法，可以通过合约创建交易或通过另一个合约。如果我们将这种部署方法视为合约的 *父级*，那么我们发现它们形成了一个合约家族，*根* 是合约创建交易。

我们让一个合约家族始终具有相同的 `version`。也就是说，`CREATE` 和 `CREATE2` 将始终部署具有与 *代码的版本* 相同的 `version` 的合约。

换句话说，`CREATE` 和 `CREATE2` 将使用当前的 *代码的版本* 执行初始化代码，并部署当前 *代码的版本* 的合约。即使待部署的代码为空，这也成立。

### 验证

在合约部署中添加一个新短语 *验证*（通过 `CREATE` / `CREATE2` 操作码或通过合约创建交易）。当 `version` 为 `0` 时，该短语不执行任何操作并始终成功。未来的虚拟机版本可以定义必须通过的额外验证。

如果验证短语失败，则部署不会继续并返回耗尽 gas。

### 合约创建交易

在硬分叉中定义 `LATEST_VERSION` 为最新支持的虚拟机版本。合约创建交易始终在 `LATEST_VERSION` 中执行（这意味着 *代码的版本* 是 `LATEST_VERSION`），并部署 `LATEST_VERSION` 的合约。在执行合约创建交易之前，对合约创建代码运行 *验证*。如果未通过，则返回耗尽 gas。

### 预编译合约和外部拥有地址

预编译合约和外部拥有地址没有 `version`。如果消息调用交易或 `CALL` / `CALLCODE` / `STATICCALL` / `DELEGATECALL` 触及新的外部拥有地址或不存在的预编译合约地址，则始终以 `version` 字段为 `0` 创建。

### 账户状态 RLP 中的附加字段

未来我们可能需要将更多信息关联到账户中，我们已经有一些 EIP 定义了账户状态 RLP 中的新附加字段。在本节中，我们定义了添加附加字段时的解析策略。

* 检查 RLP 列表长度，如果为 4，则将账户版本设置为 `0`，并且不解析任何附加字段。
* 如果 RLP 列表长度大于 4，则将账户版本设置为位置 `4` 的标量（从 `0` 开始计数）。
  * 检查版本规范以确定定义的附加字段数量 `N`，如果 RLP 列表长度不等于 `5 + N`，则返回解析错误。
  * 将 RLP 位置 `5` 到 `4 + N` 解析为附加字段中指定的含义。

## 扩展

关于上述“规范”部分，我们定义了基本账户版本控制层。基本账户版本控制层本身已经很有用，并且可以处理大多数 EVM 改进。下面我们定义了两个可以单独部署的规范，以改善基本层账户版本控制的功能。

请注意，本节仅用于文档目的。当“启用 EIP-1702”时，除非扩展规范也包含在内，否则不应启用这些扩展。

- [44-VERTXN: 合约创建交易的账户版本控制扩展](https://specs.corepaper.org/44-vertxn/)
- [45-VEROP: CREATE 和 CREATE2 的账户版本控制扩展](https://specs.corepaper.org/45-verop/)

## 使用模板

本节定义了其他 EIP 如何使用此账户版本控制规范。请注意，目前我们仅定义基本层的使用模板。

账户版本控制通常直接应用于硬分叉元数据。硬分叉中的 EIP 按虚拟机类型分组，例如 EVM 和 eWASM。对于每个 EIP，我们定义：

* **版本**：一个小于 `2^256` 的非零标量，唯一标识此版本。请注意，它不需要是顺序的。
* **父版本**：所有新特性派生的基础。父版本为 `0` 时，我们定义基础为遗留虚拟机。请注意，一旦定义了非 `0` 的版本，遗留虚拟机的特性集必须被冻结。当定义一个全新的虚拟机（例如 eWASM）时，父版本不适用。
* **特性**：在此版本启用的所有附加特性。

如果元 EIP 包含提供附加账户状态 RLP 字段的 EIP，我们还定义：

* **账户字段**：所有账户字段，直到此元 EIP 的结束，不包括基本的 5 个字段（`nonce`、`balance`、`storageRoot`、`codeHash` 和 `version`）。如果包含的 EIP 特定于修改账户字段且不修改虚拟机执行逻辑，建议我们指定一个额外的版本，其执行逻辑与先前版本相同，但仅更改账户字段。

## 理由
这引入了通过账户状态中的新 RLP 项目进行账户版本控制。上述设计通过使合约*家族*始终具有相同版本来实现账户版本控制。通过这种方式，版本只需在合约创建交易中提供，并且对任何版本的代码格式没有限制。如果我们想支持多个最新的虚拟机（例如，EVM 和 WebAssembly 一起运行），那么这将需要扩展，例如 44-VERTXN 和 45-VEROP。

另外，账户版本控制也可以通过以下方式实现：

* **[26-VER](https://specs.corepaper.org/26-ver/)** 和
  **[40-UNUSED](https://specs.corepaper.org/40-unused/)**：这使得账户的版本控制完全依赖于其代码头前缀。如果仅使用 26-VER，则无法认证任何代码是有效的，因为当前虚拟机允许将代码视为数据。这可以通过 40-UNUSED 修复，但缺点是它可能与向后不兼容。
* **EIP-1891**：我们不是将版本字段写入账户 RLP 状态，而是将其写入一个单独的合约。这可以实现与此 EIP 相同的功能，并可能减少代码复杂性，但缺点是每次代码执行都需要额外的 trie 遍历，这会影响性能。

## 向后兼容性

账户版本控制是完全向后兼容的，并且不会改变当前合约的执行方式。

## 讨论

### 性能

目前几乎所有完整节点实现都使用配置参数来决定使用哪个虚拟机版本。切换虚拟机版本只是一个使用不同配置参数集更改指针的操作。因此，这种方案对性能几乎没有影响。

### WebAssembly

当我们在链上部署 WebAssembly 虚拟机时，这种方案也会很有帮助。在这种情况下，WASM 合约和 EVM 合约可以共存，执行边界和交互模型如上所述清晰定义。

## 测试用例和实现

待添加。

## 参考文献

该规范的来源可以在 [43-VER](https://specs.corepaper.org/43-ver/) 找到。

## 版权

版权及相关权利通过 [CC0](../LICENSE.md) 放弃。