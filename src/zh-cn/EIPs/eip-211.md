---
eip: 211
title: "新操作码：RETURNDATASIZE 和 RETURNDATACOPY"
author: Christian Reitwiessner <chris@ethereum.org>
type: Standards Track
category: Core
status: Final
created: 2017-02-13
---

## 简要总结

一个允许在 EVM 内返回任意长度数据的机制已经被请求很长时间了。现有的提案总是与 gas 收费相关联，存在非常复杂的问题。该提案解决了同样的问题，同时具有非常简单的 gas 收费机制，并且对调用操作码的更改最小。它的工作方式与当前处理 calldata 的方式非常相似；在调用后，返回数据保存在一个虚拟缓冲区中，调用者可以将其（或其部分）复制到内存中。在下一个调用时，缓冲区会被覆盖。该机制是 100% 向后兼容的。

## 摘要

请参见总结。

## 动机

在某些情况下，函数能够返回长度无法在调用前预期的数据是至关重要的。原则上，这可以在不改变 EVM 的情况下解决，例如通过将调用拆分为两个调用，其中第一个用于仅计算大小。然而，所有这些机制在某些情况下都是非常昂贵的。一个非常有用的此类最坏情况的例子是通用转发合约；一个接受调用数据、可能进行一些检查然后将其原样转发到另一个合约的合约。返回数据当然应该以类似于原始调用者的方式进行传输。由于合约是通用的，并且不知道它调用的合约，因此无法在不相应调整被调用合约或尝试对数次调用的情况下确定输出的大小。

建议编译器实现者在调用前如果返回数据的大小未知，则保留一个零长度区域用于返回数据，然后使用 `RETURNDATACOPY` 结合 `RETURNDATASIZE` 实际检索数据。

请注意，该提案还使得提议在故意状态回滚的情况下允许返回数据的 EIP（[EIP-140](./eip-140.md)）变得更加有用。由于失败数据的大小可能大于常规返回数据（甚至未知），因此可以在 CALL 操作码发出失败信号后检索失败数据，即使常规输出区域不足以容纳数据。

## 规范

如果 `block.number >= BYZANTIUM_FORK_BLKNUM`，则添加两个新操作码并修改任何创建新调用帧的操作码（如 `CALL`、`CREATE`、`DELEGATECALL` 等）的语义，称为调用类操作码。假设 EVM（更具体地说：EVM 调用帧）有一个新的可变大小的内部缓冲区，称为返回数据缓冲区。该缓冲区在每个新调用帧中创建为空。执行任何调用类操作码时，缓冲区被清空（其大小设置为零）。执行调用类操作码后，调用的完整返回数据（或失败数据，见 [EIP-140](./eip-140.md)）存储在返回数据缓冲区（调用者的）中，并相应地更改其大小。作为例外，`CREATE` 和 `CREATE2` 被认为在成功情况下返回空缓冲区，在失败情况下返回失败数据。如果执行调用类操作码但并未真正实例化调用帧（例如由于资金不足以进行价值转移或被调用合约不存在），则返回数据缓冲区为空。

作为一种优化，可以在调用帧之间共享返回数据缓冲区，因为在任何时候最多只有一个会是非空的。

`RETURNDATASIZE`: `0x3d`

将返回数据缓冲区的大小推送到栈上。
Gas 成本：2（与 `CALLDATASIZE` 相同）

`RETURNDATACOPY`: `0x3e`

该操作码的语义与 `CALLDATACOPY` 类似，但不是从调用数据中复制数据，而是从返回数据缓冲区中复制数据。此外，超出返回数据缓冲区大小的访问会导致失败；即如果 `start + length` 溢出或导致大于 `RETURNDATASIZE` 的值，则当前调用在缺 gas 的情况下停止。特别是，从缓冲区末尾读取 0 字节将读取 0 字节；从缓冲区外一字节读取 0 字节会导致异常。

Gas 成本：`3 + 3 * ceil(amount / 32)`（与 `CALLDATACOPY` 相同）

## 理由

考虑了其他允许返回动态数据的解决方案，但它们都必须从调用操作码中扣除 gas，因此在实现和规范上都很复杂（[5/8](https://github.com/ethereum/EIPs/issues/8)）。由于该提案与处理 calldata 的方式非常相似，因此很好地融入了这一概念。此外，eWASM 架构已经以完全相同的方式处理返回数据。

请注意，EVM 实现需要在下一个调用或当前调用返回之前保留返回数据。由于该资源已经作为被调用者内存的一部分支付，因此不应成为问题。实现可以选择在下一个调用之前保留被调用者的完整内存，或仅将返回数据复制到特殊内存区域。

在下一个调用类操作码之前保留被调用者的内存不会增加峰值内存使用量；在调用返回后发生的任何内存分配都可以在调用之前移动，而不会改变 gas 成本，但会将此分配添加到峰值分配中。

操作码的数值在与 `CALLDATASIZE` 和 `CALLDATACOPY` 相同的 nibble 块中分配。

## 向后兼容性

该提案引入了两个新操作码，并在此之外保持完全向后兼容。

## 测试用例

## 实现

## 版权
版权及相关权利通过 [CC0](../LICENSE.md) 放弃。