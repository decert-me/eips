---
eip: 2803
title: 富交易
description: 通过允许外部拥有账户直接执行字节码来支持“富交易”。
author: Micah Zoltu (@MicahZoltu)
discussions-to: https://ethereum-magicians.org/t/rich-transactions-via-evm-bytecode-execution-from-externally-owned-accounts/4025
status: Stagnant
type: Standards Track
category: Core
created: 2020-07-18
---

## 摘要
如果交易的 `to` 地址为 `x`，则交易的 `data` 将被视为 EVM 字节码，并将从交易的 `CALLER`（即：交易签名者）的上下文中执行。

## 动机
许多以太坊 DApp 目前要求用户批准多个交易以产生一个效果 - 例如，首先批准一个合约支出代币，然后调用该合约的常见模式。这导致了糟糕的用户体验，并使与 DApp 交互的体验变得复杂。

使外部拥有账户能够直接执行 EVM 字节码允许单个交易执行多个合约调用，从而使 DApp 提供简化的体验，每次交互最多只产生一个交易。

虽然今天原则上可以使用合约钱包实现这一点，但其他用户体验问题，例如需要为发送账户提供 gas 费用、浏览器集成中缺乏对合约钱包的支持以及合约钱包缺乏一致的 API，导致这些钱包的采用率较低。该 EIP 是增强现有 EOA 实用性的方式，秉持“不要让完美成为好的敌人”的精神。

## 规范
在用于预编译的范围内指定一个新的保留地址 `x`。当从外部拥有账户向该地址发送交易时，交易的有效载荷被视为 EVM 字节码，并以交易签名者作为当前账户执行。为清晰起见：
 - `ADDRESS` 操作码返回签署交易的 EOA 的地址。
 - `BALANCE` 操作码返回签署交易的 EOA 的余额。
 - 任何发送值的 `CALL` 操作将其值从签署交易的 EOA 中获取。
 - `CALL` 将 `CALLER` 设置为 EOA（而不是 `x`）。
 - `DELEGATECALL` 保留 EOA 作为拥有账户。
 - `CALLER` 和 `ORIGIN` 操作码都返回签署交易的 EOA 的地址。
 - 预编译地址没有关联的代码。`CODE*` 和 `EXTCODE*` 操作码的行为与任何空地址相同。
 - `CALLDATA*` 操作码按预期在交易有效载荷上操作。
 - `SLOAD` 和 `SSTORE` 在 EOA 的存储上操作。因此，EOA 可以在存储中有数据，在交易之间保持持久性。
 - `SELFDESTRUCT` 操作码不执行任何操作。
 - 所有其他操作码在调用合约地址时按预期行为。
 - 如果附加了任何值，则交易无效。
 - 从合约对预编译地址的调用没有特殊效果，相当于对不存在的预编译或空地址的调用。

## 理由
该 EIP 的意图是使新的预编译在所有可能的方面像来自外部拥有账户的 `DELEGATECALL`。需要进行一些更改以反映执行的代码未存储在链上，并且对于特殊情况如 `SELFDESTRUCT`，以防止引入新的边缘情况，例如能够将 EOA 的 nonce 清零。

使用预编译而不是新的 EIP-2718 交易类型，因为预编译允许我们拥有任何类型的 EIP-2718 交易的富交易。

## 向后兼容性
该 EIP 引入了一项新功能，需要在未来的硬分叉中实现。预计与现有代码没有向后兼容性问题。

假设 EOA 不能原子性地执行多个操作的合约或 DApp 可能会受到此更改的影响，因为这现在使 EOA 能够一起执行多个原子操作。作者认为这不是一个重要的用例，因为这种“保护”已经被矿工轻易击败。

## 版权
通过 [CC0](../LICENSE.md) 放弃版权及相关权利。