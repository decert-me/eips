---
eip: 1051
title: EVM 的溢出检查
author: Nick Johnson <arachnid@notdot.net>
discussions-to: https://ethereum-magicians.org/t/eip-arithmetic-overflow-detection-for-the-evm/261
status: Stagnant
type: Standards Track
category: Core
created: 2018-05-02
---

## 摘要
此 EIP 为 EVM 的算术操作添加了溢出检查，并引入了两个新的操作码，用于检查和清除溢出标志。

## 动机
许多合约的正确运行依赖于检测和防止算术操作的溢出。由于 EVM 在 mod 2^256 整数上运行，并且没有内置的溢出检测或防止机制，因此需要对每个算术操作进行手动检查。

为了促进高效和安全的合约，我们提议引入新的操作码，以便高效检测溢出，这可以定期检查，而不是在每次操作后检查。

## 规范

EVM 状态中添加了两个新标志：溢出 (`ovf`) 和有符号溢出 (`sovf`)。

在以下情况下设置 `ovf` 标志：

 - 当 `ADD` (`0x01`) 操作码将两个输入视为无符号整数时，产生的理想输出超过 2^256 - 1。
 - 当 `SUB` (`0x03`) 操作码将两个输入视为无符号整数时，产生的理想输出小于 0。
 - 当 `MUL` (`0x02`) 操作码将两个输入视为无符号整数时，产生的理想输出超过 2^256 - 1。

在 `ovf` 标志被设置时，`sovf` 标志也会被设置，并且在以下情况下也会被设置：

 - 当 `ADD` 操作码的两个输入具有相同的最高有效位时，输出具有不同的最高有效位（例如，`(+a) + (+b) = (-c)` 或 `(-a) + (-b) = (+c)`）。
 - 当发生 `SUB` 操作码且结果与被减数（第二个参数）具有相同的最高有效位时（例如，`(+a) - (-b) = (-c)` 或 `(-a) - (+b) = (+c)`）。
 - 当 `MUL` 操作码的两个输入均为正数时，输出为负数。
 - 当 `MUL` 操作码的两个输入均为负数时，输出为负数。
 - 当 `MUL` 操作码的一个输入为负数，另一个输入为正数时，输出为正数。

新增操作码 `OFV`，编号为 `0x0c`。该操作码从栈中获取 0 个参数。当执行时，如果 `ovf` 标志被设置，则推送 `1`，否则推送 `0`。然后将 `ovf` 标志设置为 false。

新增操作码 `SOVF`，编号为 `0x0d`。该操作码从栈中获取 0 个参数。当执行时，如果 `sovf` 标志被设置，则推送 `1`，否则推送 `0`。然后将 `sovf` 标志设置为 false。

## 理由
任何实施溢出保护的变更都需要保持现有合约的行为，这排除了对算术操作本身的许多更改。一种选择是提供一个操作码，启用溢出保护，如果发生溢出则引发异常或回滚。然而，这限制了处理溢出的方式。

相反，我们复制了现实世界 CPU 的功能，通常实现“进位”和“溢出”标志。

由于有符号溢出可能不会导致无符号溢出，因此需要为有符号和无符号溢出设置单独的标志。

## 向后兼容性
此 EIP 不引入向后兼容性问题。

## 测试用例
待定

## 实施
待定

## 版权
通过 [CC0](../LICENSE.md) 放弃版权及相关权利。