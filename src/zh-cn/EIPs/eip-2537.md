---
eip: 2537
title: BLS12-381 曲线操作的预编译
description: 将 BLS12-381 曲线的操作作为预编译添加到一组必要的操作中，以高效执行 BLS 签名验证等操作。
author: Alex Vlasov (@shamatar), Kelly Olson (@ineffectualproperty), Alex Stokes (@ralexstokes), Antonio Sanso (@asanso)
discussions-to: https://ethereum-magicians.org/t/eip2537-bls12-precompile-discussion-thread/4187
status: Review
type: Standards Track
category: Core
created: 2020-02-21
---

## 摘要

添加功能以高效执行 BLS12-381 曲线上的操作，包括 BLS 签名验证的操作。

除了曲线算术外，还包括多标量乘法操作，以高效聚合公钥或单个签名者的签名，在 BLS 签名验证期间使用。

## 动机

此预编译的动机是添加一种加密原语，使得在配对友好曲线上的操作可以获得 120+ 位的安全性，而现有的 BN254 预编译仅提供 80 位的安全性。

## 规范

### 常量

| 名称                | 值    | 注释              |
|---------------------|-------|--------------------|
| `FORK_TIMESTAMP`    | *待定* | 主网              |
| BLS12_G1ADD         | 0x0b  | 预编译地址        |
| BLS12_G1MUL         | 0x0c  | 预编译地址        |
| BLS12_G1MSM         | 0x0d  | 预编译地址        |
| BLS12_G2ADD         | 0x0e  | 预编译地址        |
| BLS12_G2MUL         | 0x0f  | 预编译地址        |
| BLS12_G2MSM         | 0x10  | 预编译地址        |
| BLS12_PAIRING_CHECK | 0x11  | 预编译地址        |
| BLS12_MAP_FP_TO_G1  | 0x12  | 预编译地址        |
| BLS12_MAP_FP2_TO_G2 | 0x13  | 预编译地址        |

如果 `block.timestamp >= FORK_TIMESTAMP`，我们将引入 *九* 个独立的预编译以执行以下操作：

- BLS12_G1ADD - 在 G1 中执行点加法（基素数域上的曲线），气体费用为 `500` gas
- BLS12_G1MUL - 在 G1 中执行点乘法（基素数域上的曲线），气体费用为 `12000` gas
- BLS12_G1MSM - 在 G1 中执行多标量乘法（MSM）（基素数域上的曲线），气体费用公式在相应部分定义
- BLS12_G2ADD - 在 G2 中执行点加法（基素数域的二次扩展上的曲线），气体费用为 `800` gas
- BLS12_G2MUL - 在 G2 中执行点乘法（基素数域的二次扩展上的曲线），气体费用为 `45000` gas
- BLS12_G2MSM - 在 G2 中执行多标量乘法（MSM）（基素数域的二次扩展上的曲线），气体费用公式在相应部分定义
- BLS12_PAIRING_CHECK - 在一组 *对* (G1, G2) 点之间执行配对操作，气体费用公式在相应部分定义
- BLS12_MAP_FP_TO_G1 - 将基域元素映射到 G1 点，气体费用为 `5500` gas
- BLS12_MAP_FP2_TO_G2 - 将扩展域元素映射到 G2 点，气体费用为 `75000` gas

映射函数的规范作为单独的 [文档](../assets/eip-2537/field_to_curve.md) 包含。此映射函数不执行将字节字符串映射到域元素的操作（因为可以以多种不同方式实现，并且可以在 EVM 中高效执行），而仅执行域算术以将域元素映射到曲线点。此功能是签名方案所需的。

### 曲线参数

BLS12 曲线由以下参数集完全定义（所有 BLS12 曲线的系数 `A=0`）：

```
Base field modulus = p = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab
Fp - finite field of size p
Curve Fp equation: Y^2 = X^3+B (mod p)
B coefficient = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004
Main subgroup order = q = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
Extension tower
Fp2 construction:
Fp quadratic non-residue = nr2 = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaaa
Fp2 is Fp[X]/(X^2-nr2)
Curve Fp2 equation: Y^2 = X^3 + B*(v+1) where v is the square root of nr2
Fp6/Fp12 construction:
Fp2 cubic non-residue c0 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
Fp2 cubic non-residue c1 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
Twist parameters:
Twist type: M
B coefficient for twist c0 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004
B coefficient for twist c1 = 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004
Generators:
H1:
X = 0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb
Y = 0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1
H2:
X c0 = 0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8
X c1 = 0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e
Y c0 = 0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801
Y c1 = 0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be
Pairing parameters:
|x| (miller loop scalar) = 0xd201000000010000
x is negative = true
```

需要注意的是，基域模数 `p` 等于 `3 mod 4`，这允许高效的平方根提取，尽管如下所述，解压缩的气体费用大于在 `calldata` 中提供解压缩点数据的气体费用。

### 域和群

域 Fp 被定义为大小为 `p` 的有限域，元素表示为 0 到 p-1 之间的整数（包括两端）。

域 Fp2 被定义为 `Fp[X]/(X^2-nr2)`，元素为 `el = c0 + c1 * v`，其中 `v` 是表示为整数对 `(c0,c1)` 的 nr2 的形式平方根。

群 G1 被定义为一组 Fp 对（点）`(x,y)`，使得 `(x,y)` 为 `(0,0)` 或 `x,y` 满足曲线 Fp 方程。

群 G2 被定义为一组 Fp2 对（点）`(x',y')`，使得 `(x,y)` 为 `(0,0)` 或 `(x',y')` 满足曲线 Fp2 方程。

### 基元素的细节和编码

#### 域元素编码：

为了生成操作的输入，首先对基域和扩展域的元素进行编码。

基域元素 (Fp) 被编码为 `64` 字节，通过对相应的（无符号）整数执行大端编码。由于 `p` 的大小，前 `16` 字节始终为零。选择 `64` 字节是为了使其具有 `32` 字节对齐的 ABI（可表示为例如 `bytes32[2]` 或 `uint256[2]`，后者假设大端编码）。相应的整数 **必须** 小于域模数。

对于二次扩展域 (Fp2) 的元素，编码是各个系数编码的字节连接，总编码为 `128` 字节。对于形式为 `el = c0 + c1 * v` 的 Fp2 元素，其中 `v` 是二次非残余的形式平方根，`c0` 和 `c1` 是 Fp 元素，相应的字节编码将是 `encode(c0) || encode(c1)`，其中 `||` 表示字节连接（或者可以使用 `bytes32[4]` 或 `uint256[4]` 作为 Solidity 类型）。

*关于前 `16` 字节为零的说明*：要求编码元素“在域中”，这意味着严格 `< 模数`。在大端编码中，这自动意味着对于长度为 `381` 位的模数，`64` 字节编码中的前 `16` 字节为零，这 **必须** 被检查，即使仅使用输入数据的子切片进行实际解码。

对于无法有效编码为域元素的输入，预编译 *必须* 返回错误。

#### G1/G2 中点的编码：

G1 和 G2 的点被编码为 `x` 和 `y` 坐标各自编码的字节连接。因此，G1 点的总编码长度为 `128` 字节，G2 点的总编码长度为 `256` 字节。

#### 无穷远点的编码：

也称为“零点”。对于 BLS12 曲线，坐标为 `(0, 0)`（在 Fp 或 Fp2 中为零）的点 *不* 在曲线上，因此一系列 `128` 或 `256` 个零字节，天真地解码为 `(0, 0)`，而是按约定用于编码 G1 或 G2 的无穷远点。

#### 乘法操作的标量编码：

乘法操作的标量被编码为 `32` 字节，通过对相应的（无符号）整数执行大端编码。相应的整数 **不** 需要小于或等于主子群阶 `q`。

#### 空输入的行为：

某些操作具有可变长度输入，例如 MSM（接受一对对 `(point, scalar)` 的列表）或配对（接受一对 `(G1, G2)` 点的列表）。虽然从算术角度来看，它们在空输入上的行为是明确的，但此 EIP 不鼓励此类用例，且可变输入长度操作必须在输入为空时返回错误。

### 操作的 ABI

#### G1 加法的 ABI

G1 加法调用期望 `256` 字节作为输入，该输入被解释为两个 G1 点的字节连接（每个 `128` 字节）。输出是加法操作结果的编码 - 单个 G1 点（`128` 字节）。
错误情况：

- 无效的坐标编码
- 输入既不是 G1 椭圆曲线上的点，也不是无穷大点
- 输入长度无效

注意：

G1 加法预编译没有子群检查。

#### G1 乘法的 ABI

G1 乘法调用期望 `160` 字节作为输入，该输入被解释为 G1 点的编码（`128` 字节）和标量值的编码（`32` 字节）的字节连接。输出是乘法操作结果的编码 - 一个单一的 G1 点（`128` 字节）。

错误情况：

- 无效的坐标编码
- 输入既不是 G1 椭圆曲线上的点，也不是无穷大点
- 输入在 G1 椭圆曲线上，但不在正确的子群中
- 输入长度无效

#### G1 MSM 的 ABI

G1 MSM 调用期望 `160*k`（`k` 为 **正** 整数）字节作为输入，该输入被解释为 `k` 个切片的字节连接，每个切片都是 G1 点的编码（`128` 字节）和标量值的编码（`32` 字节）的字节连接。输出是 MSM 操作结果的编码 - 一个单一的 G1 点（`128` 字节）。

错误情况：

- 无效的坐标编码
- 输入既不是 G1 椭圆曲线上的点，也不是无穷大点
- 输入在 G1 椭圆曲线上，但不在正确的子群中
- 输入长度无效

#### G2 加法的 ABI

G2 加法调用期望 `512` 字节作为输入，该输入被解释为两个 G2 点的字节连接（每个 `256` 字节）。输出是加法操作结果的编码 - 一个单一的 G2 点（`256` 字节）。

错误情况：

- 无效的坐标编码
- 输入既不是 G2 椭圆曲线上的点，也不是无穷大点
- 输入长度无效

注意：

G2 加法预编译没有子群检查。

#### G2 乘法的 ABI

G2 乘法调用期望 `288` 字节作为输入，该输入被解释为 G2 点的编码（`256` 字节）和标量值的编码（`32` 字节）的字节连接。输出是乘法操作结果的编码 - 一个单一的 G2 点（`256` 字节）。

错误情况：

- 无效的坐标编码
- 输入既不是 G2 椭圆曲线上的点，也不是无穷大点
- 输入在 G2 椭圆曲线上，但不在正确的子群中
- 输入长度无效

#### G2 MSM 的 ABI

G2 MSM 调用期望 `288*k`（`k` 为 **正** 整数）字节作为输入，该输入被解释为 `k` 个切片的字节连接，每个切片都是 G2 点的编码（`256` 字节）和标量值的编码（`32` 字节）的字节连接。输出是 MSM 操作结果的编码 - 一个单一的 G2 点（`256` 字节）。

错误情况：

- 无效的坐标编码
- 输入既不是 G2 椭圆曲线上的点，也不是无穷大点
- 输入在 G2 椭圆曲线上，但不在正确的子群中
- 输入长度无效

#### 配对检查的 ABI

配对检查调用期望 `384*k`（`k` 为 **正** 整数）字节作为输入，该输入被解释为 `k` 个切片的字节连接。每个切片具有以下结构：

- `128` 字节的 G1 点编码
- `256` 字节的 G2 点编码

每个点预计在阶为 `q` 的子群中。

它检查方程 `e(P1, Q1) * e(P2, Q2) * ... * e(Pk, Qk) == 1` 在配对目标域中，其中 `e` 是配对操作。输出是 `32` 字节，其中前 `31` 字节等于 `0x00`，最后一个字节是 `0x00`（假）或 `0x01`（真）。

错误情况：

- 无效的坐标编码
- 输入既不是其各自椭圆曲线上的点，也不是无穷大点
- 输入在其各自椭圆曲线上，但不在正确的子群中
- 输入长度无效

注意：

如果任何输入是无穷大点，配对结果将为 1。协议可能希望在调用预编译之前检查并拒绝无穷大点。

#### 将 Fp 元素映射到 G1 点的 ABI

域到曲线调用期望 `64` 字节作为输入，该输入被解释为 Fp 的一个元素。此调用的输出是 `128` 字节，并且是编码的 G1 点。

错误情况：

- 输入长度无效
- 输入编码不正确

#### 将 Fp2 元素映射到 G2 点的 ABI

域到曲线调用期望 `128` 字节作为输入，该输入被解释为 Fp2 的一个元素。此调用的输出是 `256` 字节，并且是编码的 G2 点。

错误情况：

- 输入长度无效
- 输入编码不正确

### 错误时的 gas 消耗

根据所有其他预编译的当前状态，如果对本 EIP 中的某个预编译的调用导致错误，则与 `CALL` 或 `STATICCALL` 一起提供的所有 gas 都会被消耗。

### DDoS 保护

此 EIP 的合理实现 *不应* 包含潜在的无限循环（实现所有功能而不使用 `while` 循环是可能的，甚至并不困难），并且 gas 计划准确反映了相应函数的计算所花费的时间（预编译定价反映了在最坏情况下消耗的 gas 量，如果存在这样的情况）。

### Gas 计划

假设一个恒定的 `30 MGas/秒`，建议以下价格。

#### G1 加法

`500` gas

#### G1 乘法

`12000` gas

#### G2 加法

`800` gas

#### G2 乘法

`45000` gas

#### G1/G2 MSM

MSM 预计将通过 Pippenger 算法执行（我们也可以说它 **必须** 通过 Pippenger 算法执行，以获得相对于通过分别乘以每对并添加结果的简单实现的加速）。在这种情况下，为 `k <= 128` 点的 MSM 准备了一张折扣表，对于 `k > 128` 的情况有一个折扣上限 `max_discount`。

为了避免非整数算术，调用成本计算为 `(k * multiplication_cost * discount) / multiplier`，其中 `multiplier = 1000`，`k` 是调用的（标量，点）对的数量，`multiplication_cost` 是 G1/G2 的相应单次乘法调用成本。

折扣表作为一对对的向量 `[k, discount]`：

```
[[1, 1200], [2, 888], [3, 764], [4, 641], [5, 594], [6, 547], [7, 500], [8, 453], [9, 438], [10, 423], [11, 408], [12, 394], [13, 379], [14, 364], [15, 349], [16, 334], [17, 330], [18, 326], [19, 322], [20, 318], [21, 314], [22, 310], [23, 306], [24, 302], [25, 298], [26, 294], [27, 289], [28, 285], [29, 281], [30, 277], [31, 273], [32, 269], [33, 268], [34, 266], [35, 265], [36, 263], [37, 262], [38, 260], [39, 259], [40, 257], [41, 256], [42, 254], [43, 253], [44, 251], [45, 250], [46, 248], [47, 247], [48, 245], [49, 244], [50, 242], [51, 241], [52, 239], [53, 238], [54, 236], [55, 235], [56, 233], [57, 232], [58, 231], [59, 229], [60, 228], [61, 226], [62, 225], [63, 223], [64, 222], [65, 221], [66, 220], [67, 219], [68, 219], [69, 218], [70, 217], [71, 216], [72, 216], [73, 215], [74, 214], [75, 213], [76, 213], [77, 212], [78, 211], [79, 211], [80, 210], [81, 209], [82, 208], [83, 208], [84, 207], [85, 206], [86, 205], [87, 205], [88, 204], [89, 203], [90, 202], [91, 202], [92, 201], [93, 200], [94, 199], [95, 199], [96, 198], [97, 197], [98, 196], [99, 196], [100, 195], [101, 194], [102, 193], [103, 193], [104, 192], [105, 191], [106, 191], [107, 190], [108, 189], [109, 188], [110, 188], [111, 187], [112, 186], [113, 185], [114, 185], [115, 184], [116, 183], [117, 182], [118, 182], [119, 181], [120, 180], [121, 179], [122, 179], [123, 178], [124, 177], [125, 176], [126, 176], [127, 175], [128, 174]]
```

`max_discount = 174`

#### 配对检查操作

配对检查操作的成本为 `43000*k + 65000`，其中 `k` 是对的数量。

#### Fp 到 G1 映射操作

Fp -> G1 映射为 `5500` gas。

#### Fp2 到 G2 映射操作

Fp2 -> G2 映射为 `75000` gas。

#### 可变长度输入的 gas 计划说明

对于 MSM 和配对函数，gas 成本取决于输入长度。当前主要客户端（在撰写时）的 gas 计划实现状态是，gas 成本函数 *不* 执行任何输入长度的验证，并且从不返回错误。因此，我们提供了一系列规则，说明 gas 成本函数 **必须** 实现，以确保客户端之间的一致性和安全性。

##### G1/G2 MSM 的 gas 计划说明

定义一个常量 `LEN_PER_PAIR`，对于 G1 操作等于 `160`，对于 G2 操作等于 `288`。定义一个函数 `discount(k)`，遵循相应部分中的规则，其中 `k` 是对的数量。

以下伪函数反映了 gas 应如何计算：

```
k = floor(len(input) / LEN_PER_PAIR);
if k == 0 {
  return 0;
}
gas_cost = k * multiplication_cost * discount(k) / multiplier;
return gas_cost;
```

我们使用向下取整来获取对的数量。如果输入的长度不能被 `LEN_PER_PAIR` 整除，我们仍然会产生 *某种* 结果，但稍后预编译将返回错误。此外，当 `k = 0` 的情况是安全的：`CALL` 或 `STATICCALL` 的成本是非零的，而形式上零 gas 成本的情况已经在 `Blake2f` 预编译中使用。在任何情况下，主要的预编译例程 **必须** 在这样的输入上产生错误，因为它违反了编码规则。
##### Gas 计划说明

定义常量 `LEN_PER_PAIR = 384`；

以下伪函数反映了 gas 应如何计算：

```
k = floor(len(input) / LEN_PER_PAIR);
gas_cost = 43000*k + 65000;
return gas_cost;
```

我们使用向下取整除法来获取对的数量。如果输入的长度不能被 `LEN_PER_PAIR` 整除，我们仍然会产生 *某种* 结果，但稍后预编译将返回错误（预编译例程 **必须** 在此类输入上产生错误，因为它违反了编码规则）。

## 理由

动机部分涵盖了在 BLS12-381 曲线上进行操作的总体动机。我们还扩展了更具体的细节理由。

### MSM 作为单独调用

显式的单独 MSM 操作允许通过所使用的算法（即 Pippenger 算法）和（通常被遗忘的）以太坊中 `CALL` 操作的高成本来节省执行时间（因此节省 gas），因此如果例如 MSM 的 `100` 个点需要调用乘法预编译 `100` 次和加法 `99` 次（大约可以节省 `138600`）。

## 向后兼容性

没有向后兼容性问题。

### 子群检查

标量乘法、MSM 和配对 **必须** 执行子群检查。实现 **应该** 使用专门文档中详细描述的优化子群检查方法 [document](../assets/eip-2537/fast_subgroup_checks.md)。在任何未通过子群检查的输入上，预编译 **必须** 返回错误。由于内同态加速需要正确子群的输入，实施者 **可以** 使用内同态加速。

### 域到曲线映射

SWU 映射方法的算法和参数集由单独的 [document](../assets/eip-2537/field_to_curve.md) 提供。

## 测试用例

由于测试参数空间较大，我们首先提供各种操作必须满足的属性。我们使用加法符号表示点操作，大写字母（`P`，`Q`）表示点，小写字母（`a`，`b`）表示标量。G1 的生成器标记为 `G`，G2 的生成器标记为 `H`，否则我们假设在正确子群中的随机点。`0` 表示标量零或无穷大点。`1` 表示标量一或乘法单位。`group_order` 是主要子群的阶。`e(P, Q)` 表示配对操作，其中 `P` 在 G1 中，`Q` 在 G2 中。

基本操作（加/乘）的必要属性：

- 交换律：`P + Q = Q + P`
- 单位元：`P + 0 = P`
- 加法逆元：`P + (-P) = 0`
- 加倍 `P + P = 2*P`
- 子群检查：`group_order * P = 0`
- 平凡乘法检查：`1 * P = P`
- 乘以零：`0 * P = 0`
- 乘以未归一化标量 `(scalar + group_order) * P = scalar * P`

配对操作的必要属性：

- 双线性 `e(a*P, b*Q) = e(a*b*P, Q) = e(P, a*b*Q)`
- 非退化性 `e(P, Q) != 1`
- `e(P, 0*Q) = e(0*P, Q) = 1`
- `e(P, -Q) = e(-P, Q)`

测试向量可以在 [test vectors files](../assets/eip-2537/test-vectors.md) 中找到。

### 基准测试用例

用于新实现的快速基准测试的一组测试向量位于单独的 [file](../assets/eip-2537/bench_vectors.md) 中。

## 参考实现

在撰写时，有两个完全符合规范的实现：

- 一个是基于 [EIP-196](./eip-196.md) 代码并与 OpenEthereum 集成的 Rust 语言实现
- 一个是专门为 Geth 实现的，作为当前代码库的一部分

## 安全考虑

严格遵循规范将消除与之前的 BN254 预编译相比的安全影响或共识影响。

一个重要主题是执行操作的“常量时间”属性。我们明确声明该预编译 **不要求** 使用常量时间算法执行所有操作。

## 版权

版权及相关权利通过 [CC0](../LICENSE.md) 放弃。