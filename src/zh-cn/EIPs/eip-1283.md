---
eip: 1283
title: 无脏映射的 SSTORE 净 gas 计量
author: Wei Tang (@sorpaas)
discussions-to: https://github.com/sorpaas/EIPs/issues/1
status: Final
type: Standards Track
category: Core
created: 2018-08-01
---

## 摘要

本 EIP 提出了 `SSTORE` 操作码的净 gas 计量变更，启用
合约存储的新用法，并减少不符合大多数实现工作方式的过高 gas 成本。

这作为 EIP-1087 的替代方案，旨在对使用不同优化
策略进行存储更改缓存的实现更加友好。

## 动机

本 EIP 提出了对 SSTORE 的 gas 计量方法（作为 EIP-1087 和 EIP-1153 的替代方案），使用对大多数实现更普遍可用的信息，并尽可能减少实现结构的变化。

* *存储槽的原始值*。
* *存储槽的当前值*。
* 退款计数器。

受益于本 EIP 的 gas 减少方案的用法包括：

* 在同一调用帧内的后续存储写操作。这
  包括重入锁、同合约多重发送等。
* 在子调用帧和父调用帧之间交换存储信息，其中该信息不需要在事务外持久化。这包括子帧错误代码和消息传递等。

## 规范

术语定义如下：

* *存储槽的原始值*：这是在 *当前事务* 上发生回滚时存储的值。
* *存储槽的当前值*：这是在 SSTORE 操作发生之前存储的值。
* *存储槽的新值*：这是在 SSTORE 操作发生之后存储的值。

用以下逻辑替换 `SSTORE` 操作码的 gas 成本计算（包括退款）：

* 如果 *当前值* 等于 *新值*（这是一个无操作），则扣除 200 gas。
* 如果 *当前值* 不等于 *新值*
  * 如果 *原始值* 等于 *当前值*（此存储槽未被当前执行上下文更改）
    * 如果 *原始值* 为 0，则扣除 20000 gas。
    * 否则，扣除 5000 gas。如果 *新值* 为 0，则向退款计数器添加 15000 gas。
  * 如果 *原始值* 不等于 *当前值*（此存储槽是脏的），则扣除 200 gas。应用以下两个条款。
    * 如果 *原始值* 不为 0
      * 如果 *当前值* 为 0（也意味着 *新值* 不为 0），则从退款计数器中移除 15000 gas。我们可以证明退款计数器永远不会低于 0。
      * 如果 *新值* 为 0（也意味着 *当前值* 不为 0），则向退款计数器添加 15000 gas。
    * 如果 *原始值* 等于 *新值*（此存储槽被重置）
      * 如果 *原始值* 为 0，则向退款计数器添加 19800 gas。
      * 否则，向退款计数器添加 4800 gas。

退款计数器的工作方式与之前相同——它限制为消耗 gas 的一半。在事务级别上，退款计数器永远不会低于零。然而，根据实现细节，有一些重要的注意事项：

* 如果实现使用“事务级别”退款计数器（退款在每个调用帧处进行检查点），则退款计数器继续为无符号。
* 如果实现使用“执行帧级别”退款计数器（在每个调用帧创建新的退款计数器，然后在调用帧结束时合并回父级），则退款计数器需要更改为有符号——在内部调用时，子退款可以低于零。

## 解释

`SSTORE` 的新 gas 成本方案分为三种不同类型：

* **无操作**：虚拟机不需要做任何事情。如果 *当前值* 等于 *新值*，则为这种情况。
* **新鲜**：此存储槽未被更改，或已重置为其原始值。如果 *当前值* 不等于 *新值*，并且 *原始值* 等于 *当前值*，则为这种情况。
* **脏**：此存储槽已被更改。如果 *当前值* 不等于 *新值*，并且 *原始值* 不等于 *当前值*，则为这种情况。

我们可以看到，上述三种类型涵盖了 *原始值*、*当前值* 和 *新值* 的所有可能变体。

**无操作** 是一个微不足道的操作。下面我们只考虑 **新鲜** 和 **脏** 的情况。

在特定存储槽上，所有初始（非 **无操作**）的 `SSTORE` 都以 **新鲜** 开始。之后，如果值已被更改，则将变为 **脏**。从 **新鲜** 到 **脏** 的转换，我们收取与当前方案相同的 gas 成本。**脏** 存储槽可以通过 `SSTORE` 操作码重置回 **新鲜**。这将触发退款。

当存储槽保持在 **脏** 状态时，我们收取 200 gas。在这种情况下，我们还需要跟踪 `R_SCLEAR` 退款——如果我们已经发放了退款但不再适用（*当前值* 为 0），则从退款计数器中移除此退款。如果我们没有发放退款但现在适用（*新值* 为 0），则将此退款添加到退款计数器中。在上述情况下，不可能在未发放退款的情况下移除退款，因为所有存储槽都以 **新鲜** 状态开始。

### 状态转换

下面是一个图表（ [由
@Arachnid](https://github.com/ethereum/EIPs/pull/1283#issuecomment-410229053)）显示 gas 成本的可能状态转换。我们忽略 **无操作** 状态，因为那是微不足道的：

![状态转换](../assets/eip-1283/state.png)

下面是上述图表的表格版本。垂直显示要设置的 *新值*，水平显示 *原始值* 和 *当前值* 的状态。

当 *原始值* 为 0 时：

|    | A (`current=orig=0`) | B (`current!=orig`)      |
|----|----------------------|--------------------------|
| ~0 | B; 20k gas           | B; 200 gas               |
| 0  | A; 200 gas           | A; 200 gas, 19.8k refund |

当 *原始值* 不为 0 时：

|             | X (`current=orig!=0`) | Y (`current!=orig`)     | Z (`current=0`)           |
|-------------|-----------------------|-------------------------|---------------------------|
| `orig`      | X; 200 gas            | X; 200 gas, 4.8k refund | X; 200 gas, -10.2k refund |
| `~orig, ~0` | Y; 5k gas             | Y; 200 gas              | Y; 200 gas, -15k refund   |
| 0           | Z; 5k gas, 15k refund | Z; 200 gas, 15k refund  | Z; 200 gas                |

## 理由

本 EIP 大致实现了瞬态存储所尝试做的事情
（EIP-1087 和 EIP-1153），但没有引入“脏映射”概念或额外存储结构的复杂性。

* 我们不受 EIP-1087 的优化限制。EIP-1087 需要保持存储更改的脏映射，并隐含地假设事务的存储更改在事务结束时提交到存储树。这对某些实现有效，但对其他实现则不然。在 EIP-658 之后，高效的存储缓存实现可能会使用内存中的树（不带 RLP 编码/解码）或其他不可变数据结构来跟踪存储更改，并仅在区块结束时提交更改。对于它们，可以知道存储的原始值和当前值，但无法在不产生额外内存或处理成本的情况下遍历所有存储更改。
* 与当前方案相比，它的 gas 成本从未更高。
* 它涵盖了瞬态存储的所有用法。容易实现 EIP-1087 的客户端也将容易实现此规范。其他一些客户端可能需要稍微额外的重构。不过，在运行时不需要额外的内存或处理成本。
关于 `SSTORE` 的 gas 成本和退款，请参见附录以获取该 EIP 满足的属性证明。

* 对于 *绝对 gas 使用量*（即实际 *gas 使用量* 减去 *退款*），
  该 EIP 在所有情况下等同于 EIP-1087。
* 对于一个特定情况，即存储槽被更改、重置为其原始值，然后再次更改，EIP-1283 将比 EIP-1087 移动更多的 gas 到退款计数器。

检查 EIP-1087 的动机中提供的示例：

* 如果一个具有空存储的合约将槽 0 设置为 1，然后再设置回 0，
  它将被收取 `20000 + 200 - 19800 = 400` gas。
* 一个具有空存储的合约将槽 0 增加 5 次，将被收取 `20000 + 5 * 200 = 21000` gas。
* 从账户 A 到账户 B 的余额转移，然后从 B 到 C 的转移，所有账户的起始和结束余额均为非零，将花费 `5000 * 3 + 200 - 4800 = 10400` gas。

## 向后兼容性

该 EIP 需要硬分叉来实现。预计不会增加 gas 成本，许多合约将看到 gas 减少。

## 测试用例

下面提供 17 个测试用例。 其中 15 个涵盖连续的两个 `SSTORE` 操作，基于 [@chfast](https://github.com/ethereum/tests/issues/483) 的工作。两个额外的案例使用三个 `SSTORE` 操作来测试一个槽被重置然后再次设置的情况。

| 代码                               | 使用的 Gas | 退款 | 原始 | 第 1 次 | 第 2 次 | 第 3 次 |
|------------------------------------|------------|------|------|---------|---------|---------|
| `0x60006000556000600055`           | 412        | 0    | 0    | 0       | 0       |         |
| `0x60006000556001600055`           | 20212      | 0    | 0    | 0       | 1       |         |
| `0x60016000556000600055`           | 20212      | 19800 | 0    | 1       | 0       |         |
| `0x60016000556002600055`           | 20212      | 0    | 0    | 1       | 2       |         |
| `0x60016000556001600055`           | 20212      | 0    | 0    | 1       | 1       |         |
| `0x60006000556000600055`           | 5212       | 15000 | 1    | 0       | 0       |         |
| `0x60006000556001600055`           | 5212       | 4800  | 1    | 0       | 1       |         |
| `0x60006000556002600055`           | 5212       | 0    | 1    | 0       | 2       |         |
| `0x60026000556000600055`           | 5212       | 15000 | 1    | 2       | 0       |         |
| `0x60026000556003600055`           | 5212       | 0    | 1    | 2       | 3       |         |
| `0x60026000556001600055`           | 5212       | 4800  | 1    | 2       | 1       |         |
| `0x60026000556002600055`           | 5212       | 0    | 1    | 2       | 2       |         |
| `0x60016000556000600055`           | 5212       | 15000 | 1    | 1       | 0       |         |
| `0x60016000556002600055`           | 5212       | 0    | 1    | 1       | 2       |         |
| `0x60016000556001600055`           | 412        | 0    | 1    | 1       | 1       |         |
| `0x600160005560006000556001600055` | 40218      | 19800 | 0    | 1       | 0       | 1       |
| `0x600060005560016000556000600055` | 10218      | 19800 | 1    | 0       | 1       | 0       |

## 附录：证明

因为 *存储槽的原始值* 被定义为在 *当前交易* 上发生回退时的值，所以很容易看出调用帧不会干扰 SSTORE gas 计算。因此，尽管下面的证明是在没有调用帧的情况下讨论的，但它适用于所有有调用帧的情况。我们将分别讨论 *原始值* 为零和非零的情况，并使用 *归纳法* 来证明 SSTORE gas 成本的一些属性。

*最终值* 是交易结束时特定存储槽的值。*绝对 gas 使用量* 是 *gas 使用量* 的绝对值减去 *退款*。我们用 `N` 表示对一个存储槽的 SSTORE 操作总数。有关下面讨论的状态，请参见 *解释* 部分中的 *状态转换*。

### 原始值为零

当 *原始值* 为 0 时，我们想证明：

* **情况 I**：如果 *最终值* 仍然为 0，我们希望收取 `200 * N` gas，因为不需要写入磁盘。
* **情况 II**：如果 *最终值* 变为非零值，我们希望收取 `20000 + 200 * (N-1)` gas，因为需要将此槽写入磁盘。

#### 基础情况

我们总是从状态 A 开始。第一次 SSTORE 可以：

* 保持在状态 A：扣除 200 gas。我们满足 *情况 I* 因为 `200 * N == 200 * 1`。
* 转到状态 B：扣除 20000 gas。我们满足 *情况 II* 因为 `20000 + 200 * (N-1) == 20000 + 200 * 0`。

#### 归纳步骤

* 从 A 到 A。之前的 gas 成本是 `200 * (N-1)`。当前 gas 成本是 `200 + 200 * (N-1)`。它满足 *情况 I*。
* 从 A 到 B。之前的 gas 成本是 `200 * (N-1)`。当前 gas 成本是 `20000 + 200 * (N-1)`。它满足 *情况 II*。
* 从 B 到 B。之前的 gas 成本是 `20000 + 200 * (N-2)`。当前 gas 成本是 `200 + 20000 + 200 * (N-2)`。它满足 *情况 II*。
* 从 B 到 A。之前的 gas 成本是 `20000 + 200 * (N-2)`。当前 gas 成本是 `200 - 19800 + 20000 + 200 * (N-2)`。它满足 *情况 I*。

### 原始值不为零

当 *原始值* 不为 0 时，我们想证明：

* **情况 I**：如果 *最终值* 保持不变，我们希望收取 `200 * N` gas，因为不需要写入磁盘。
* **情况 II**：如果 *最终值* 变为零，我们希望收取 `5000 - 15000 + 200 * (N-1)` gas。注意 `15000` 是实际定义中的退款。
* **情况 III**：如果 *最终值* 变为一个改变的非零值，我们希望收取 `5000 + 200 * (N-1)` gas。

#### 基础情况

我们总是从状态 X 开始。第一次 SSTORE 可以：

* 保持在状态 X：扣除 200 gas。我们满足 *情况 I* 因为 `200 * N == 200 * 1`。
* 转到状态 Y：扣除 5000 gas。我们满足 *情况 III* 因为 `5000 + 200 * (N-1) == 5000 + 200 * 0`。
* 转到状态 Z：绝对 gas 使用量为 `5000 - 15000`，其中 15000 是退款。我们满足 *情况 II* 因为 `5000 - 15000 + 200 * (N-1) == 5000 - 15000 + 200 * 0`。

#### 归纳步骤

* 从 X 到 X。之前的 gas 成本是 `200 * (N-1)`。当前 gas 成本是 `200 + 200 * (N-1)`。它满足 *情况 I*。
* 从 X 到 Y。之前的 gas 成本是 `200 * (N-1)`。当前 gas 成本是 `5000 + 200 * (N-1)`。它满足 *情况 III*。
* 从 X 到 Z。之前的 gas 成本是 `200 * (N-1)`。当前绝对 gas 成本是 `5000 - 15000 + 200 * (N-1)`。它满足 *情况 II*。
* 从 Y 到 X。之前的 gas 成本是 `5000 + 200 * (N-2)`。当前绝对 gas 成本是 `200 - 4800 + 5000 + 200 * (N-2)`。它满足 *情况 I*。
* 从 Y 到 Y。之前的 gas 成本是 `5000 + 200 * (N-2)`。当前 gas 成本是 `200 + 5000 + 200 * (N-2)`。它满足 *情况 III*。
* 从 Y 到 Z。之前的 gas 成本是 `5000 + 200 * (N-2)`。当前绝对 gas 成本是 `200 - 15000 + 5000 + 200 * (N-2)`。它满足 *情况 II*。
* 从 Z 到 X。之前的 gas 成本是 `5000 - 15000 + 200 * (N-2)`。当前绝对 gas 成本是 `200 + 10200 + 5000 - 15000 + 200 * (N-2)`。它满足 *情况 I*。
* 从 Z 到 Y。之前的 gas 成本是 `5000 - 15000 + 200 * (N-2)`。当前绝对 gas 成本是 `200 + 15000 + 5000 - 15000 + 200 * (N-2)`。它满足 *情况 III*。
* 从 Z 到 Z。之前的 gas 成本是 `5000 - 15000 + 200 * (N-2)`。当前绝对 gas 成本是 `200 + 5000 - 15000 + 200 * (N-2)`。它满足 *情况 II*。
## 版权

版权及相关权利通过 [CC0](../LICENSE.md) 放弃。