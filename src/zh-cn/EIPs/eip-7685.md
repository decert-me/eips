---
eip: 7685
title: 通用执行层请求
description: 一个用于与共识层共享执行层触发请求的通用总线
author: lightclient (@lightclient)
discussions-to: https://ethereum-magicians.org/t/eip-7685-general-purpose-execution-layer-requests/19668
status: 审核中
type: 标准跟踪
category: 核心
created: 2024-04-14
---

## 摘要

本提案定义了一个用于存储合约触发请求的通用框架。它通过扩展执行头，增加一个字段来存储请求信息。请求随后被暴露给共识层，由其处理每一个请求。

## 动机

智能合约控制的验证者的激增导致对额外的执行层触发行为的需求。通过允许这些系统将管理操作委托给其治理智能合约，它们可以避免中介介入并确保某些操作的发生。这为最终用户创造了一个更安全的系统。通过将每个单独请求的细节从执行层抽象出来，添加新的请求类型变得更简单，并且不需要更新执行区块结构。

## 规范

### 执行层

#### 请求

一个 `requests` 对象由一个 `request_type` 和一个不透明的字节数组 `request_data` 组成。

```
requests = request_type ++ request_data
```

每个请求类型将使用其自己的 `request_data` 格式定义其自己的 `requests` 对象。

#### 区块头

用一个新的 32 字节值 `requests_hash` 扩展头部。

构造如下所示：

```
sha256(sha256(requests_0) ++ sha256(requests_1) ++ ...)
```

或伪代码：

```python
def compute_requests_hash(requests):
    m = sha256()
    for r in requests:
        m.update(sha256(r))
    return m.digest()

block.header.requests_hash = compute_requests_hash(requests)
```

### 共识层

每个提案可以选择如何扩展信标链类型以包含新的执行层请求类型。

## 理由

### 不透明字节数组而非 RLP 数组

通过将 `request_data` 数组的字节从第二个字节开始设为不透明字节，而不是 RLP（或其他编码）列表，我们可以支持未来请求负载的不同编码格式，如 SSZ、LEB128 或固定宽度格式。

### 请求来源和有效性

本 EIP 对请求的来源没有严格要求，也没有规定请求必须何时/如何被验证。这是为了为未来的协议设计者提供最大的灵活性。

作者对请求的来源和有效性的建议是：

* 请求的来源应来自交易的执行。更具体地说，是调用指定系统合约的交易，这些合约将请求存储在账户中。存储将在后续的区块系统调用中检索。或者，如果系统调用不需要本质上关注速率限制，它可以简单依赖于发出事件，随后由系统在区块后解析并转换为请求。
* 请求的有效性通常无法在执行层完全验证。这就是为什么它们仅被称为“请求”；它们本身并不具备单方面催化操作的权威。我们期望系统合约执行执行层能够进行的任何验证，然后将其传递给共识层进行进一步验证。

### 排序

不同类型的排序是按类型升序。这是为了简化验证所有在 `requests_hash` 中提交的请求是否匹配的过程。

另一种选择是按请求在区块内生成的时间排序。由于预计许多请求将在区块末尾通过系统调用累积，因此这将很难强制执行。因此，按类型排序是确保完整性的最简单排序方式。

#### 同类型内

在同一类型内，顺序未定义。这是因为就本 EIP 而言，请求的数据是不透明的。因此，顺序由每个请求类型单独确定。

## 向后兼容性

未发现向后兼容性问题。

## 测试用例

待办事项

## 安全考虑

需要讨论。

## 版权

版权及相关权利通过 [CC0](../LICENSE.md) 放弃。