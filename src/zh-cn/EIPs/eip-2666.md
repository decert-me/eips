---
eip: 2666
title: 预编译和 Keccak256 函数的重新定价
author: Alex Vlasov (@shamatar)
discussions-to: https://ethereum-magicians.org/t/eip2666-global-precompiles-repricing-and-many-more-discussion-thread/4332
status: Stagnant
type: Standards Track
category: Core
created: 2020-05-22
requires: 1352, 2046, 2565
---

## 简单总结

该 EIP 尝试将某些预编译和内置 EVM 函数的价格与其性能、消耗的资源以及 EVM 本身的新变化保持一致。

为以下内容提出了新的价格公式：
- SHA256 预编译 (`0x02`)
- RIPEMD 预编译 (`0x03`)
- KECCAK256 操作码 (`0x20`)

## 摘要

许多预编译和内置函数的成本在当前客户端状态下是无效的。该 EIP 包含了一系列对定价公式的更改，以更好地反映基础计算的结构。

## 动机

EVM 中这些函数的历史定价并未反映基础计算的内部结构（哈希函数的内部结构）。

- EIP-2046 将 `STATICCALL (0xfa)` 的成本更改为预编译，可能需要调整某些预编译的成本，这些预编译可能考虑了旧的高成本（`700` gas）并试图对此进行补偿
- 一些预编译的定价过高，其定价公式未能反映基础函数的结构
- EVM 中的 Keccak256 内置函数（操作码）的定价未能反映基础哈希函数的结构

## 规范

如果 `block_number >= X`，则设置以下预编译和 Keccak256 操作码的 gas 成本：
- SHA256（预编译 `0x02`）：`10 + ((len(input) + 8)/64 + 1) * 9`
- RIPEMD（预编译 `0x03`）：`6 + ((len(input) + 8)/64 + 1) * 12`
- KECCAK256（`0x20`）：`13 + (len(input)/136 + 1)*15`

该 EIP *理想情况下* 要求 `MODEXP` 重新定价 [已实现](./eip-2565.md)，以准确反映没有对旧的 `STATICCALL (0xfa)` 成本（预-2046）的隐式补偿。

## 理由
执行函数的成本必须准确反映在计算上花费的实际 CPU 时间，因此对当前预编译和 Keccak256 函数进行了基准测试，以测量运行时间与输入参数的关系。

### 重新定价方法的详细总结

该 EIP 依赖于两个事实：
- 对哈希函数内部结构的先验知识
- 客户端团队提供的关于随机输入（给定长度的随机字节串）的一些合理输入长度范围的基准测试

### 最流行客户端的基准测试

EIP-2666 所需的基准测试由客户端提供，原始数据汇总在 [这里](https://docs.google.com/spreadsheets/d/1aCQnk7prrp3Mbcf011BE5zZnkbc3Iw7QAixn6mLbKS0/edit?usp=sharing)

- SHA256 预编译

目前它是 `60` gas + 每 `32` 字节字的 `12` gas（字的数量为 `ceil(len(input)/word_len)`，在类似地方也是如此。如果没有 `floor` 或 `ceil` 指定符号，以下所有除法都是整数除法（向下取整除法））。建议的公式是 `A * ((len(input) + 8) / 64 + 1) + B`，系数如下

|   |   | A  | B  |
|---|---|---|---|
| Geth  |   | 5  | 3  |
| OE  |   | 9  | 4  |
| Besu  |   | 5  | 10  |
| Nethermind  |   | 10  | 5  |

EIP-2666 提议 `A = 9`，`B = 10`。该预编译中没有大的一次性成本，因此它是 EIP-2046 - 安全的。

- RIPEMD 预编译

目前它是 `600` gas + 每 `32` 字节字的 `120` gas。建议的公式是 `A * ((len(input) + 8) / 64 + 1) + B`，系数如下

|   |   | A  | B  |
|---|---|---|---|
| Geth  |   | 12  | 6  |
| OE  |   | 8  | 2  |
| Besu  |   | 29  | 16  |
| Nethermind  |   | 10  | 6  |

EIP-2666 提议 `A = 12`，`B = 6`。该预编译中没有大的一次性成本，因此它是 EIP-2046 - 安全的。Besu 预计在年底前会有性能改进。

- Keccak256 性能

目前它是 `30` gas + 每 `32` 字节字的 `6` gas。建议的公式是 `A * (len(input) / 136 + 1) + B`，系数如下

|   |   | A  | B  |
|---|---|---|---|
| Geth  |   | 13  | 13  |
| OE  |   | 15  | 2  |
| Besu  |   | 19  | 28  |
| Nethermind  |   | 16  | 3  |

EIP-2666 提议 `A = 15`，`B = 13`。该预编译中没有大的一次性成本，因此它是 EIP-2046 - 安全的。Besu 预计在年底前会有性能改进。

### 工具和数据

参考材料（来自不同客户端的基准测试）和原始数据可以在 [这里](https://docs.google.com/spreadsheets/d/1aCQnk7prrp3Mbcf011BE5zZnkbc3Iw7QAixn6mLbKS0/edit?usp=sharing) 找到。

有一个可用的存储库，包含基准测试和预编译测试的输入 [在这里](https://github.com/shamatar/bench_precompiles)，客户端团队可以使用它进行所有必要的测量。

原始 Besu [基准测试](https://gist.github.com/shemnon/0ddba91be501fa23291bdec9107fe99a)。

### 关于公式结构的说明

公式中有些项看起来像 `A * 1`，这些项显然不与 `B` 系数合并，以反映空字节数组的哈希仍然需要执行一轮哈希。

## 向后兼容性
预编译的重新定价在过去发生过，可以视为标准程序。许多合约的 gas 成本预计会降低，这可能会破坏基于固定 gas 成本的重入保护措施。在任何情况下，这种保护措施本来就不应被视为良好和最终的。

## 测试用例

让我们考虑一个简单的 Keccak256 哈希 `0`、`64` 和 `160` 字节的例子，这可以作为实现的简单合理性检查。

- 哈希 `0` 字节：
  - 旧价格：`30 + 6 * ceil(0 / 32) = 30` gas
  - 新价格：`15 * (0/136 + 1) + 13 = 28` gas
- 哈希 `64` 字节
  - 旧价格：`30 + 6 * ceil(64 / 32) = 42` gas
  - 新价格：`15 * (64/136 + 1) + 13 = 28` gas
- 哈希 `160` 字节
  - 旧价格：`30 + 6 * ceil(160 / 32) = 60` gas
  - 新价格：`15 * (160/136 + 1) + 13 = 43` gas

## 实施

在撰写时没有参考实现，因为这只需要在主要客户端中简单更改常量。

## 安全考虑

如向后兼容性部分所述，在某些情况下，成本的降低可能会允许例如之前未预期的重入，但我们认为基于固定 gas 成本的重入保护无论如何都是一个有缺陷的设计决策。

## 版权
版权及相关权利通过 [CC0](../LICENSE.md) 放弃。