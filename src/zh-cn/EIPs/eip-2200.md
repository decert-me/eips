---
eip: 2200
title: 网络气体计量的结构化定义
author: Wei Tang (@sorpaas)
discussions-to: https://github.com/sorpaas/EIPs/issues/1
status: Final
type: Standards Track
category: Core
created: 2019-07-18
---

## 简单总结

这是一个实现网络气体计量的 EIP。它是 [EIP-1283] 和 [EIP-1706] 的组合版本，具有结构化定义，以便与其他气体变更（如 [EIP-1884]）互操作。

## 摘要

该 EIP 提供了 `SSTORE` 操作码的网络气体计量变更的结构化定义，使合约存储的新用法成为可能，并减少了与大多数实现方式不匹配的过高气体成本。

这是 [EIP-1283] 和 [EIP-1706] 的结合。

## 动机

该 EIP 提出了在 `SSTORE` 上进行气体计量的方法，使用对大多数实现更普遍可用的信息，并尽可能减少实现结构的变化。

* 存储槽的原始值。
* 存储槽的当前值。
* 退款计数器。

受益于该 EIP 气体减少方案的用法包括：

* 在同一调用帧内的后续存储写操作。这包括重入锁、同合约多重发送等。
* 在子调用帧和父调用帧之间交换存储信息，其中该信息不需要在事务外持久化。这包括子帧错误代码和消息传递等。

EIP-1283 的原始定义造成了对现有合约的新型重入攻击的危险，因为 Solidity 默认为简单转账调用提供了 2300 gas 的“津贴”。如果在低 gasleft 状态下不允许 `SSTORE`，则可以轻松缓解此危险，而不会破坏向后兼容性和 EIP-1283 的原始意图。

该 EIP 还通过参数替换了原始 EIP-1283 的气体值定义，使其更具结构性，并更容易在未来定义变更。

## 规范

定义变量 `SLOAD_GAS`、`SSTORE_SET_GAS`、`SSTORE_RESET_GAS` 和 `SSTORE_CLEARS_SCHEDULE`。这些变量的旧值和新值如下：

* `SLOAD_GAS`：从 `200` 更改为 `800`。
* `SSTORE_SET_GAS`：`20000`，未更改。
* `SSTORE_RESET_GAS`：`5000`，未更改。
* `SSTORE_CLEARS_SCHEDULE`：`15000`，未更改。

使用这些变量更改 EIP-1283 的定义。新的规范，结合 EIP-1283 和 EIP-1706，将如下所示。术语 *原始值*、*当前值* 和 *新值* 在 EIP-1283 中定义。

用以下逻辑替换 `SSTORE` 操作码的气体成本计算（包括退款）：

* 如果 *gasleft* 小于或等于气体津贴，则以“气体不足”异常失败当前调用帧。
* 如果 *当前值* 等于 *新值*（这是一个无操作），则扣除 `SLOAD_GAS`。
* 如果 *当前值* 不等于 *新值*
  * 如果 *原始值* 等于 *当前值*（该存储槽未被当前执行上下文更改）
    * 如果 *原始值* 为 0，则扣除 `SSTORE_SET_GAS`。
    * 否则，扣除 `SSTORE_RESET_GAS`。如果 *新值* 为 0，则将 `SSTORE_CLEARS_SCHEDULE` 的气体添加到退款计数器。
  * 如果 *原始值* 不等于 *当前值*（该存储槽是脏的），则扣除 `SLOAD_GAS`。应用以下两个条款。
    * 如果 *原始值* 不为 0
      * 如果 *当前值* 为 0（也意味着 *新值* 不为 0），则从退款计数器中移除 `SSTORE_CLEARS_SCHEDULE` 的气体。
      * 如果 *新值* 为 0（也意味着 *当前值* 不为 0），则将 `SSTORE_CLEARS_SCHEDULE` 的气体添加到退款计数器。
    * 如果 *原始值* 等于 *新值*（该存储槽被重置）
      * 如果 *原始值* 为 0，则将 `SSTORE_SET_GAS - SLOAD_GAS` 添加到退款计数器。
      * 否则，将 `SSTORE_RESET_GAS - SLOAD_GAS` 的气体添加到退款计数器。

实现还应注意，根据上述定义，如果实现使用调用帧退款计数器，则计数器可能为负。如果实现使用事务级退款计数器，则计数器始终保持正值。

## 理由

该 EIP 大多实现了临时存储所尝试做的事情（[EIP-1087] 和 [EIP-1153]），但没有引入“脏映射”概念或额外存储结构的复杂性。

* 我们不受 EIP-1087 的优化限制。EIP-1087 需要保持存储更改的脏映射，并隐含假设事务的存储更改在事务结束时提交到存储树中。这对某些实现有效，但对其他实现则不然。在 [EIP-658] 之后，高效的存储缓存实现可能会使用内存中的树（不带 RLP 编码/解码）或其他不可变数据结构来跟踪存储更改，并仅在区块结束时提交更改。对于它们，可以知道存储的原始值和当前值，但无法在不产生额外内存或处理成本的情况下遍历所有存储更改。
* 与当前方案相比，它从未花费更多的气体。
* 它涵盖了临时存储的所有用法。容易实现 EIP-1087 的客户端也将容易实现该规范。其他一些客户端可能需要稍微额外的重构。不过，在运行时不需要额外的内存或处理成本。

关于 `SSTORE` 的气体成本和退款，请参见附录以证明该 EIP 满足的属性。

* 对于 *绝对使用的气体*（即，实际 *使用的气体* 减去 *退款*），该 EIP 在所有情况下等同于 EIP-1087。
* 对于一个特定情况，即存储槽被更改、重置为其原始值，然后再次更改，EIP-1283 将比 EIP-1087 将更多的气体移动到退款计数器。

检查 EIP-1087 动机中提供的示例（`SLOAD_GAS` 为 `200`）：

* 如果一个存储为空的合约将槽 0 设置为 1，然后再设置为 0，它将被收取 `20000 + 200 - 19800 = 400` gas。
* 一个存储为空的合约将槽 0 增加 5 次将被收取 `20000 + 5 * 200 = 21000` gas。
* 从账户 A 到账户 B 的余额转移，然后从 B 到 C 的转移，所有账户的起始和结束余额均非零，将花费 `5000 * 3 + 200 - 4800 = 10400` gas。

为了保持现有合约的隐式重入保护，如果剩余气体低于 Solidity 中“转账”/“发送”所给的气体津贴，则不应允许事务修改状态。这些是其他提议的补救措施及其反对意见：

* 放弃 EIP-1283，避免修改 `SSTORE` 成本
  * EIP-1283 是一个重要的更新
  * 它已在测试网络和客户端中被接受和实施。
* 添加一个新的调用上下文，允许 LOG 操作码但不允许状态更改。
  * 在现有的 regular/staticcall 之外添加了另一种调用类型
* 将脏槽的 `SSTORE` 成本提高到 >=2300 gas
  * 使网络气体计量变得不那么有用。
* 减少气体津贴
  * 使津贴几乎无用。
* 将脏槽的写入成本提高到 5000 gas，但将 4800 gas 添加到退款计数器
  * 仍然没有明确不变性。
  * 需要调用者提供更多气体，仅仅是为了获得退款
* 添加合约元数据，指定每个合约的 EVM 版本，并仅将 `SSTORE` 更改应用于使用新版本部署的合约。
## 向后兼容性

此 EIP 需要进行硬分叉以实现。预计不会增加 gas 成本，许多合约将看到 gas 减少。

执行 `SSTORE` 从未可能低于 5000 gas，因此它不会引入与以太坊主网的不兼容性。Gas 估算应考虑此要求。

## 测试用例

| 代码                                 | 使用的 Gas | 退款   | 原始   | 1st | 2nd | 3rd |
|--------------------------------------|------------|--------|--------|-----|-----|-----|
| `0x60006000556000600055`             | 1612       | 0      | 0      | 0   | 0   |     |
| `0x60006000556001600055`             | 20812      | 0      | 0      | 0   | 1   |     |
| `0x60016000556000600055`             | 20812      | 19200  | 0      | 1   | 0   |     |
| `0x60016000556002600055`             | 20812      | 0      | 0      | 1   | 2   |     |
| `0x60016000556001600055`             | 20812      | 0      | 0      | 1   | 1   |     |
| `0x60006000556000600055`             | 5812       | 15000  | 1      | 0   | 0   |     |
| `0x60006000556001600055`             | 5812       | 4200   | 1      | 0   | 1   |     |
| `0x60006000556002600055`             | 5812       | 0      | 1      | 0   | 2   |     |
| `0x60026000556000600055`             | 5812       | 15000  | 1      | 2   | 0   |     |
| `0x60026000556003600055`             | 5812       | 0      | 1      | 2   | 3   |     |
| `0x60026000556001600055`             | 5812       | 4200   | 1      | 2   | 1   |     |
| `0x60026000556002600055`             | 5812       | 0      | 1      | 2   | 2   |     |
| `0x60016000556000600055`             | 5812       | 15000  | 1      | 1   | 0   |     |
| `0x60016000556002600055`             | 5812       | 0      | 1      | 1   | 2   |     |
| `0x60016000556001600055`             | 1612       | 0      | 1      | 1   | 1   |     |
| `0x600160005560006000556001600055`   | 40818      | 19200  | 0      | 1   | 0   | 1   |
| `0x600060005560016000556000600055`   | 10818      | 19200  | 1      | 0   | 1   | 0   |

## 实现

待添加。

## 附录：证明

因为*存储槽的原始值*被定义为在*当前交易*发生回退时的值，所以很容易看出调用帧不会干扰 `SSTORE` gas 计算。因此，尽管下面的证明是在没有调用帧的情况下讨论的，但它适用于所有有调用帧的情况。我们将分别讨论*原始值*为零和非零的情况，并使用*归纳法*证明 `SSTORE` gas 成本的一些属性。

*最终值*是交易结束时特定存储槽的值。*绝对使用的 gas*是*使用的 gas*减去*退款*的绝对值。我们用 `N` 表示对一个存储槽的 `SSTORE` 操作总数。有关下面讨论的状态，请参阅*解释*部分中的*状态转换*。

下面我们在假设所有参数不变的情况下进行证明，意味着 `SLOAD_GAS` 为 `200`。但是，请注意，无论 `SLOAD_GAS` 如何变化，证明仍然适用。

### 原始值为零

当*原始值*为 0 时，我们想证明：

* **情况 I**：如果*最终值*仍然是 0，我们希望收取 `200 * N` gas，因为不需要写入磁盘。
* **情况 II**：如果*最终值*变为非零值，我们希望收取 `20000 + 200 * (N-1)` gas，因为需要将此槽写入磁盘。

#### 基本情况

我们总是从状态 A 开始。第一次 `SSTORE` 可以：

* 保持在状态 A：扣除 200 gas。我们满足*情况 I*因为 `200 * N == 200 * 1`。
* 转到状态 B：扣除 20000 gas。我们满足*情况 II*因为 `20000 + 200 * (N-1) == 20000 + 200 * 0`。

#### 归纳步骤

* 从 A 到 A。之前的 gas 成本是 `200 * (N-1)`。当前 gas 成本是 `200 + 200 * (N-1)`。它满足*情况 I*。
* 从 A 到 B。之前的 gas 成本是 `200 * (N-1)`。当前 gas 成本是 `20000 + 200 * (N-1)`。它满足*情况 II*。
* 从 B 到 B。之前的 gas 成本是 `20000 + 200 * (N-2)`。当前 gas 成本是 `200 + 20000 + 200 * (N-2)`。它满足*情况 II*。
* 从 B 到 A。之前的 gas 成本是 `20000 + 200 * (N-2)`。当前 gas 成本是 `200 - 19800 + 20000 + 200 * (N-2)`。它满足*情况 I*。

### 原始值不为零

当*原始值*不为 0 时，我们想证明：

* **情况 I**：如果*最终值*保持不变，我们希望收取 `200 * N` gas，因为不需要写入磁盘。
* **情况 II**：如果*最终值*变为零，我们希望收取 `5000 - 15000 + 200 * (N-1)` gas。注意 `15000` 是实际定义中的退款。
* **情况 III**：如果*最终值*变为改变的非零值，我们希望收取 `5000 + 200 * (N-1)` gas。

#### 基本情况

我们总是从状态 X 开始。第一次 `SSTORE` 可以：

* 保持在状态 X：扣除 200 gas。我们满足*情况 I*因为 `200 * N == 200 * 1`。
* 转到状态 Y：扣除 5000 gas。我们满足*情况 III*因为 `5000 + 200 * (N-1) == 5000 + 200 * 0`。
* 转到状态 Z：绝对使用的 gas 是 `5000 - 15000`，其中 15000 是退款。我们满足*情况 II*因为 `5000 - 15000 + 200 * (N-1) == 5000 - 15000 + 200 * 0`。

#### 归纳步骤

* 从 X 到 X。之前的 gas 成本是 `200 * (N-1)`。当前 gas 成本是 `200 + 200 * (N-1)`。它满足*情况 I*。
* 从 X 到 Y。之前的 gas 成本是 `200 * (N-1)`。当前 gas 成本是 `5000 + 200 * (N-1)`。它满足*情况 III*。
* 从 X 到 Z。之前的 gas 成本是 `200 * (N-1)`。当前绝对 gas 成本是 `5000 - 15000 + 200 * (N-1)`。它满足*情况 II*。
* 从 Y 到 X。之前的 gas 成本是 `5000 + 200 * (N-2)`。当前绝对 gas 成本是 `200 - 4800 + 5000 + 200 * (N-2)`。它满足*情况 I*。
* 从 Y 到 Y。之前的 gas 成本是 `5000 + 200 * (N-2)`。当前 gas 成本是 `200 + 5000 + 200 * (N-2)`。它满足*情况 III*。
* 从 Y 到 Z。之前的 gas 成本是 `5000 + 200 * (N-2)`。当前绝对 gas 成本是 `200 - 15000 + 5000 + 200 * (N-2)`。它满足*情况 II*。
* 从 Z 到 X。之前的 gas 成本是 `5000 - 15000 + 200 * (N-2)`。当前绝对 gas 成本是 `200 + 10200 + 5000 - 15000 + 200 * (N-2)`。它满足*情况 I*。
* 从 Z 到 Y。之前的 gas 成本是 `5000 - 15000 + 200 * (N-2)`。当前绝对 gas 成本是 `200 + 15000 + 5000 - 15000 + 200 * (N-2)`。它满足*情况 III*。
* 从 Z 到 Z。之前的 gas 成本是 `5000 - 15000 + 200 * (N-2)`。当前绝对 gas 成本是 `200 + 5000 - 15000 + 200 * (N-2)`。它满足*情况 II*。

## 版权

版权及相关权利通过 [CC0](../LICENSE.md) 放弃。

[EIP-1283]: ./eip-1283.md
[EIP-1706]: ./eip-1706.md
[EIP-1884]: ./eip-1884.md
[EIP-1087]: ./eip-1087.md
[EIP-1153]: ./eip-1153.md
[EIP-658]: ./eip-658.md