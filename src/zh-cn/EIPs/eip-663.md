---
eip: 663
title: SWAPN、DUPN 和 EXCHANGE 指令
description: 引入额外的指令以操作堆栈，允许访问更深层的堆栈
author: Alex Beregszaszi (@axic), Charles Cooper (@charles-cooper), Danno Ferrin (@shemnon)
discussions-to: https://ethereum-magicians.org/t/eip-663-unlimited-swap-and-dup-instructions/3346
status: Review
type: Standards Track
category: Core
created: 2017-07-03
requires: 3540, 5450
---

## 摘要

目前，`SWAP*` 和 `DUP*` 指令的堆栈深度限制为 16。引入三条新指令，`SWAPN`、`DUPN` 和 `EXCHANGE`，以解除此限制并允许访问更深层的堆栈。

## 动机

虽然堆栈深度为 1024 项，但仅能轻松访问顶部 16 项。通过手动将更多局部变量保存在内存中或通过编译器中的“堆栈到内存提升”来支持更多局部变量。这可能导致复杂且低效的代码。

此外，在 EVM 上实现更高级的构造（例如函数）将导致输入和输出参数的列表，以及返回的指令偏移量。

这些参数（或堆栈项）的数量很容易超过 16，因此需要编译器额外小心，以确保它们以一种仍然可访问的方式布局。

最后，交换堆栈中除了第 1 项和第 N 项以外的项对于实现堆栈调度算法的编译器非常重要（这是堆栈机器的寄存器分配的类比），这些算法试图在给定变量和使用分析的情况下最小化堆栈流量。

引入 `SWAPN`、`DUPN` 和 `EXCHANGE` 将为编译器提供简化访问深层堆栈项的选项。

## 规范

我们引入三条新指令：

1. `DUPN` (`0xe6`)
2. `SWAPN` (`0xe7`)
3. `EXCHANGE` (`0xe8`)

如果代码是遗留字节码，则这些指令中的任何一条都会导致 *异常停止*。(*注意：这意味着行为没有变化。*)

如果代码是有效的 EOF1，则适用以下规则：

1. 指令后跟一个 8 位立即数值，我们称之为 `imm`，其值可以为 0 到 255。
   1. 在 `DUPN` 和 `SWAPN` 的情况下，我们引入变量 `n`，其值等于 `imm + 1`。
   2. 在 `EXCHANGE` 的情况下，我们引入变量 `n`，其值等于 `imm >> 4 + 1`，以及变量 `m`，其值等于 `imm & 0x0F + 1`（即，`imm` 的前两个 nibble 转换为一索引）。
2. 代码验证扩展为检查没有相对跳转指令（`RJUMP`/`RJUMPI`/`RJUMPV`）指向 `DUPN`、`SWAPN` 或 `EXCHANGE` 的立即数值。
3. [EIP-5450](./eip-5450.md) 的堆栈验证算法扩展：
   1. 在 `DUPN` 之前，如果当前堆栈高度小于 `n`，则代码无效。在 `DUPN` 之后，堆栈高度增加。
   2. 在 `SWAPN` 之前，如果当前堆栈高度小于 `n + 1`，则代码无效。在 `SWAPN` 之后，堆栈高度不变。
   3. 在 `EXCHANGE` 之前，如果当前堆栈高度小于 `n + m + 1`，则代码无效。在 `EXCHANGE` 之后，堆栈高度不变。
4. 执行规则：
   1. `DUPN`：第 `n` 个堆栈项在堆栈顶部被复制。(*注意：我们在这里使用 1 基索引。*)
   2. `SWAPN`：第 `n + 1` 个堆栈项与堆栈顶部的项交换。
   3. `EXCHANGE`：第 `n + 1` 个堆栈项与第 `n + m + 1` 个堆栈项交换。

这三条指令的 gas 成本设定为 3。

## 理由

### 仅限 EOF

由于该指令依赖于立即数参数编码，因此只能在 EOF 中启用。在遗留字节码中，该编码可能会与跳转目的地分析相矛盾。

### 立即数参数的大小

对于 `DUPN` 和 `SWAPN`，考虑了 16 位大小以容纳 1024 项的完整堆栈空间，但：

1. 这将需要额外的限制/检查（`n < 1024`）
2. 256 的深度是对当前 16 的重大改进，而额外字节的开销将使其不太有用

同样，对于 `EXCHANGE`，所提议的方案允许寻址 32 项。

### Gas 成本

这些操作的 gas 成本与现有的 `DUP*` 和 `SWAP*` 指令相同，因为它们只是作为指针交换实现的。

### `EXCHANGE` 与 `SWAPN`

如前所述，`EXCHANGE` 对于实现堆栈调度算法的编译器非常重要。具体来说，在堆栈项计划在堆栈更深处被消耗的情况下（例如，堆栈中的第 3 项需要移动到第 2 个位置以便被下一个操作消耗），目前需要三条指令，`SWAP2 SWAP3 SWAP2`。然而，在 EVM 实现中，实施只是一个指针交换，因此可以在没有额外运行时成本的情况下在单条指令中实现。

## 向后兼容性

这对向后兼容性没有影响，因为操作码之前未被分配，并且该功能仅在 EOF 中启用。

## 测试用例

给定 `stack[]` 是一个基于 0 的数据结构，`n`、`m` 和 `imm` 根据规范定义：

- `DUPN imm` 在 `stack_height < n` 时验证失败。
- `SWAPN imm` 在 `stack_height < n + 1` 时验证失败。
- `EXCHANGE imm` 在 `stack_height < n + m + 1` 时验证失败。
- `DUPN imm` 应增加函数的最大堆栈高度。如果最大堆栈高度超过 1023 的限制，则验证失败。
- `DUPN imm`、`SWAPN imm` 和 `EXCHANGE imm` 在运行时如果可用 gas 少于 3 则失败。
- `DUPN imm` 应复制 `stack[n - 1]` 项并将其推送到堆栈
- `SWAPN imm` 应将 `stack[n]` 与 `stack[stack.top()]` 交换
- `EXCHANGE imm` 应将 `stack[n]` 与 `stack[n + m]` 交换。

## 安全考虑

作者未意识到此处引入任何额外风险。EVM 堆栈固定为 1024 项，大多数实现始终将其保存在内存中。此更改将增加通过单条指令可访问的堆栈项数量。

## 版权

版权及相关权利通过 [CC0](../LICENSE.md) 放弃。