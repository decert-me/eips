---
eip: 1895
title: 支持椭圆曲线循环
author: Alexandre Belling <alexandrebelling8@gmail.com>
discussions-to: https://ethresear.ch/t/reducing-the-verification-cost-of-a-snark-through-hierarchical-aggregation/5128
status: Stagnant
type: Standards Track
category: Core
created: 2018-03-31
---

## 简单总结

EVM 目前支持椭圆曲线操作，针对曲线 *alt-bn128* 提供了预编译 `ecadd`、`ecmul` 和 `ecpairing`。MNT4 和 MNT6 类包含曲线循环。这些循环使得在一个曲线上进行操作时，可以在另一个曲线上进行 SNARK 操作（反之亦然）。该 EIP 建议添加对这些曲线的支持。

## 摘要

通过预编译添加对以下操作的支持：

* MNT4 上的 `ecadd`
* MNT4 上的 `ecmul`
* MNT4 上的 `ecpairing`

## 动机

椭圆曲线是递归 SNARK 的基本构件（即：在 SNARK 内部验证 SNARK），这解决了可扩展零知识的问题。更一般地说，这部分解决了可扩展性问题，因为 SNARK 的验证在被验证电路的大小上是常数时间。

更具体地说，今天如果 EVM 需要处理数千个 SNARK 验证，所需的 gas 大约为 15 亿，这对以太坊来说是不可行的。例如，递归 SNARK 使得将多个证明聚合成一个可以像其他 SNARK 一样进行验证成为可能。这导致验证成本的大幅降低。

然而，使用 *alt-bn128* 是不可能的，据我所知，已知的唯一能够产生循环的配对友好曲线家族是 MNT4 和 MNT6。关于这两个家族之间存在的循环的完整特征描述见 [On cycles of pairing-friendly elliptic curves](https://arxiv.org/pdf/1803.02067.pdf)。

## 规范

### 曲线

所提议的循环已在 [Scalable Zero Knowledge via Cycles of Elliptic Curves](https://eprint.iacr.org/2014/595.pdf) 中介绍。

### MNT4 定义

群 `G_1` 和 `G_2` 是素数阶的循环群：

```.
q = 475922286169261325753349249653048451545124878552823515553267735739164647307408490559963137
```

`G_1` 定义在素数阶的域 `F_p` 上：

```.
p = 475922286169261325753349249653048451545124879242694725395555128576210262817955800483758081
```

生成元 P 为：

```.
P = (
    60760244141852568949126569781626075788424196370144486719385562369396875346601926534016838,
    363732850702582978263902770815145784459747722357071843971107674179038674942891694705904306
)
```

p 和 q 都可以用 298 位表示。

群 G_1 定义在由方程 `Y² = X³ + aX + b` 定义的曲线上，其中：

```.
    a = 2
    b = 423894536526684178289416011533888240029318103673896002803341544124054745019340795360841685
```

扭曲群 G_2 定义在域 `F_p^2 = F_p / <<待完成>>` 上。

扭曲群 G_2 定义在由方程 `Y² = X² + aX + b` 定义的曲线上，其中：

```.
    a = 34 + i * 0
    b = 0 + i * 67372828414711144619833451280373307321534573815811166723479321465776723059456513877937430
```

G_2 的生成元由以下生成：

```.
    P2 = (
        438374926219350099854919100077809681842783509163790991847867546339851681564223481322252708 +
        i * 37620953615500480110935514360923278605464476459712393277679280819942849043649216370485641,
        37437409008528968268352521034936931842973546441370663118543015118291998305624025037512482 +
        i * 424621479598893882672393190337420680597584695892317197646113820787463109735345923009077489
    )
```

### 操作和 gas 成本

将实现以下操作及其 gas 成本：

```.
MNT_X_ADD = <<To be estimated>>
MNT_X_MUL = <<To be estimated>>
MNT_X_PAIRING = <<To be estimated>>
```

其中 `X` 为 4。

### 编码

曲线点 P(X, Y) 在 F_p 上以其压缩形式 C(X, Y) 表示：

```.
    C = X | s
```

其中 `s` 表示 `Y` 如下：

```.
    |  `s'`  | `Y`                      |
    |--------|--------------------------|
    | `0x00` | Point at infinity        |
    | `0x02` | Solution with `y` even   |
    | `0x03` | Solution with `y` odd    |
```

从仿射坐标到压缩形式的操作是微不足道的：

```.
    s = 0x02 | (s & 0x01)
```

在 EVM 中，压缩形式使我们能够用 2 个 uint256 表示曲线点，而不是 3 个。

### 边缘情况

* 对于无穷远点有多种可接受的表示

## 理由

该曲线具有 80 位的安全性（而 MNT6 具有 120 位），这可能不足以满足关键安全级别（例如转移数十亿），但对其他情况来说足够。如果这被证明不足以支持采用，还有另一种选择：Coda 使用的另一个循环，但定义在 753 位大小的域上，这也可能过低（未在 Coda 的出版物中找到对此曲线的引用）。

无论选择哪个循环，群和域元素都用大于 256 位的整数表示（即使对于 80 位的安全性），因此可能还需要添加对更大域大小操作的支持。

我们目前不知道更高效的配对友好循环，也不知道是否存在。通过放宽所有曲线必须是配对友好的约束，可能可以规避这个问题。如果我们有一个只有一个配对友好曲线的循环，我们仍然可以通过在 SNARK 和任何其他通用零知识密码系统之间交替来组合证明。

假设我们找到一个合适的循环，我们不需要为其包含的所有曲线实现支持，只需一个。最佳选择是最快的，因为递归 SNARK 的整体安全性不依赖于验证所用的曲线。

将进行适当的基准测试，以便做出此选择并为操作定价。

## 测试用例

## 参考文献

* *Eli-Ben-Sasson, Alessandro Chiesa, Eran Tromer, Madars Virza, [BCTV14], 2015 年 4 月 28 日, 通过椭圆曲线的循环实现可扩展零知识 : https://eprint.iacr.org/2014/595.pdf*
* *Alessandro Chiesa, Lynn Chua, Matthew Weidner, [CCW18], 2018 年 11 月 5 日, 关于配对友好椭圆曲线的循环 : https://arxiv.org/pdf/1803.02067.pdf*

## 实现

* [go-boojum](https://github.com/AlexandreBelling/go-boojum) : 递归 SNARK 应用的 PoC 演示
* [libff](https://github.com/scipr-lab/libff) : 一个用于有限域和椭圆曲线的 C++ 库
* [coda](https://github.com/CodaProtocol/coda) : 一种具有轻量级、固定大小区块链的新加密货币协议。

## 版权

版权及相关权利通过 [CC0](../LICENSE.md) 放弃。