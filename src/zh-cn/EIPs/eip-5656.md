---
eip: 5656
title: MCOPY - 内存复制指令
description: 一种高效的 EVM 指令，用于复制内存区域
author: Alex Beregszaszi (@axic), Paul Dworzanski (@poemm), Jared Wasinger (@jwasinger), Casey Detrio (@cdetrio), Pawel Bylica (@chfast), Charles Cooper (@charles-cooper)
discussions-to: https://ethereum-magicians.org/t/eip-5656-mcopy-instruction/10890
status: Final
type: Standards Track
category: Core
created: 2021-02-01
---

## 摘要

提供一种高效的 EVM 指令，用于复制内存区域。

## 动机

内存复制是一项基本操作，但在 EVM 上实现它会带来开销。

这一点在早期通过引入“身份”预编译得到了认识和缓解，该预编译通过使用 `CALL` 的输入和输出内存偏移来完成内存复制。其成本为 `15 + 3 * (length / 32)` gas，加上调用开销。身份预编译因 `CALL` 的成本提高到 700 而变得无效，但随后通过 [EIP-2929](./eip-2929.md) 的降低使其稍微经济一些。

精确复制字可以通过 `<offset> MLOAD <offset> MSTORE` 或 `<offset> DUP1 MLOAD DUP2 MSTORE` 来完成，成本至少为每字 12 gas。如果偏移量已知并且复制可以展开，这种方法相当高效。如果在运行时以任意起始偏移量实现复制，除了控制流开销外，偏移量还需要使用 `32 ADD` 进行递增，每字增加至少 6 gas。

复制不精确的字更棘手，因为对于最后一个部分字，源和目标都需要加载、掩码、或运算并再次存储。这种开销是显著的。一个边缘情况是，如果最后的“部分字”是一个字节，它可以通过 `MSTORE8` 高效存储。

作为示例用例，复制 256 字节的成本为：

- 在 EIP-2929 之前，使用身份预编译至少需要 757 gas
- 在 EIP-2929 之后，使用身份预编译至少需要 157 gas
- 使用展开的 `MLOAD`/`MSTORE` 指令至少需要 96 gas
- 使用此 EIP 仅需 27 gas

根据对区块 10537502 到 10538702 的分析，大约 10.5% 的内存复制在有 `MCOPY` 指令的情况下会有更好的性能。

内存复制被 Solidity 和 Vyper 等语言使用，我们预计这一改进将为构建数据结构提供高效的手段，包括高效的切片访问和内存对象的复制。拥有专用的 `MCOPY` 指令还将为未来 `CALL` 指令的 gas 成本变化提供前向保护。

拥有一个特殊的 `MCOPY` 指令使静态分析器和优化器的工作变得更容易，因为一般来说，`CALL` 的影响必须被限制，而 `MCOPY` 指令只会有内存影响。即使为预编译添加了特殊情况，未来的硬分叉也可能改变 `CALL` 的影响，因此使用身份预编译的代码分析仅在某个区块范围内有效。

最后，我们预计内存复制对于各种计算密集型操作（如 EVM384）将极为有用，因为它被认为是一个显著的开销。

## 规范

指令 `MCOPY` 的引入代码为 `0x5E`。

### 输入栈

| 栈   | 值   |
|------|------|
| top - 0 | `dst` |
| top - 1 | `src` |
| top - 2 | `length` |

这种顺序与其他复制指令相匹配，即 `CALLDATACOPY`、`RETURNDATACOPY`。

### gas 成本

根据黄皮书术语，它应被视为 `W_copy` 操作码组的一部分，并遵循黄皮书中 `W_copy` 的 gas 计算。虽然黄皮书中的计算应被视为最终决定，但截至本文撰写时，其 gas 成本为：

```
words_copied = (length + 31) // 32
g_verylow    = 3
g_copy       = 3 * words_copied + memory_expansion_cost
gas_cost     = g_verylow + g_copy
```

### 输出栈

此指令不返回任何栈项。

### 语义

它将 `length` 字节从 `src` 指向的偏移量复制到 `dst` 指向的偏移量的内存中。
复制的过程就像使用了一个中间缓冲区，允许目标和源重叠。

如果 `length > 0` 且 (`src + length` 或 `dst + length`) 超出当前内存长度，则内存将扩展，并相应地收取 gas 成本。

此指令的 gas 成本与其他 `Wcopy` 指令相似，为 `Gverylow + Gcopy * ceil(length / 32)`。

## 理由

精确字内存复制和部分字内存复制的生产实现可以在 Solidity、Vyper 和 Fe 编译器中找到。

随着 [EIP-2929](./eip-2929.md) 的引入，使用身份预编译的调用开销从 700 降至 100 gas。这仍然使得将预编译作为合理替代方案变得困难。

## 向后兼容性

此 EIP 引入了一条之前不存在的新指令。使用此指令的已部署合约在此 EIP 之后可能会改变其行为。

## 测试用例

`MCOPY 0 32 32` - 从偏移量 32 复制 32 字节到偏移量 0。

pre（为可读性包含空格）：

```
0000000000000000000000000000000000000000000000000000000000000000 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f
```

post：

```
000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f 000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f
```

使用的 gas: 6

`MCOPY 0 0 32` - 从偏移量 0 复制 32 字节到偏移量 0。

pre：

```
0101010101010101010101010101010101010101010101010101010101010101
```

post：

```
0101010101010101010101010101010101010101010101010101010101010101
```

使用的 gas: 6

`MCOPY 0 1 8` - 从偏移量 1 复制 8 字节到偏移量 0（重叠）。

pre（字节 8 处的空格）：

```
0001020304050607 080000000000000000000000000000000000000000000000
```

post：

```
0102030405060708 080000000000000000000000000000000000000000000000
```

使用的 gas: 6

`MCOPY 1 0 8` - 从偏移量 0 复制 8 字节到偏移量 1（重叠）。

pre（字节 8 处的空格）：

```
0001020304050607 080000000000000000000000000000000000000000000000
```

post：

```
0000010203040506 070000000000000000000000000000000000000000000000
```

使用的 gas: 6

### 完整测试套件

完整的测试套件可以在执行规范测试中找到：[MCOPY 套件](https://github.com/ethereum/execution-spec-tests/tree/c0065176a79f89d93f4c326186fc257ec5b8d5f1/tests/cancun/eip5656_mcopy) 。

## 安全考虑

客户端应注意其实现不使用中间缓冲区（例如，C 标准库的 `memmove` 函数不使用中间缓冲区），因为这可能成为拒绝服务（DoS）攻击的向量。大多数语言内置/标准库函数用于移动字节在这里具有正确的性能特征。

除此之外，拒绝服务（DoS）和内存耗尽攻击的分析与其他触及内存的操作码相同，因为内存扩展遵循相同的定价规则。

## 版权

版权及相关权利通过 [CC0](../LICENSE.md) 放弃。