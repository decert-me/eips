---
eip: 3102
title: 二进制树结构
author: Guillaume Ballet (@gballet), Vitalik Buterin (@vbuterin)
discussions-to: https://ethresear.ch/t/binary-trie-format/7621
status: Stagnant
type: Standards Track
category: Core
created: 2020-09-01
---

## 简要总结

将存储结构从十叉树更改为二叉树，合并账户和存储树，并使用 blake2b。

## 摘要

本提案提出了一种二进制结构和账户与存储树的默克化规则，这些树合并为一个单一的“状态”树。为了简化设计，RLP 和大多数 MPT 的优化被舍弃。Keccak256 被 blake2b 替代。

## 动机

当前的默克尔帕特里夏树（MPT）设计使用十叉树。十叉默克尔树比其二叉树更浅，这意味着更少的哈希。在以太坊存在的五年中，显然磁盘访问比哈希更成为瓶颈。因此，客户端正在逐渐远离存储所有内部节点的模型，转向由 turbo-geth 首次使用的扁平（键，值）存储模型，其中中间节点仅在需要时重新计算。

有一种推动力使以太坊在无状态的方式下更易于使用。二叉树的证明比十叉树小（约 4 倍），使其成为无状态友好的以太坊的设计选择。

出于同样的原因，账户和存储树被合并，以便对所有更改有一个单一的证明。

MPT 设计也充满了奇怪的大小优化，这些优化的效果有限——代价是复杂性过高。例如，对于 RLP 小于 32 字节的子节点进行嵌套，节省了估计的 1MB 磁盘空间。与此时快速同步所需的 300GB 相比，这微不足道。这些优化是错误的重要来源，因此是共识破坏的风险。
对 RLP 的依赖也因其复杂性而受到批评，而通用编码方案的开销对于默克尔树的刚性结构并不合理。

将存储模型从十叉树切换到二叉树的愿望提供了一个机会，以采用更简单的树结构，将优化从协议层推向客户端实现者层。

## 规范

### 约定

| 代码      | 描述                                      |
| :-:       | -                                                |
| `u256(x)` | 数字 _x_ 的大端，32 字节表示 |
|`||`          | 按字节连接运算符|
| `++`         | 按位连接运算符                                                                                                |
| `0b0101`     | 二进制字符串 `0101`                                                                                                       |
| `hash()`     | 通常的哈希函数                                                                                                     |
| `empty_hash` | 空哈希: `hash("")`                                                                                                     |
| `length(x)`  | 对象 `x` 的字节长度                                                                                                  |
| `d[a..b]`    | 从字节序列 `d` 中提取的大端比特序列，从比特索引 `a` 开始，到包括比特索引 `b`。 |

### 与十叉结构的显著变化

 * 账户和存储树合并，键长度在 32 到 64 字节之间；
 * 不再使用 RLP；
 * 在十叉前缀中使用的“叶子标记”位也被舍弃。叶子被识别为没有子节点的节点；
 * 序列化节点被哈希，无论序列化节点的字节长度有多小。

### 树

#### 结构

树结构由 _节点_ 组成。一个节点 `N ≡ (N_l,N_r,N_p,N_v)` 具有以下 4 个组成部分：

 * `N_l` 是指向节点的 _左子节点_ 的哈希。如果节点没有左子节点，则 `N_l` 是空哈希 `empty_hash`；
 * `N_r` 是指向节点的 _右子节点_ 的哈希。如果节点没有右子节点，则 `N_r` 是空哈希 `empty_hash`；
 * 可选的 `N_p` 是节点的 _前缀_ : 每个进入以 `N` 为根的子树的键都以这个比特串为前缀；
 * `N_v` 是存储在此节点的 _值_。该值 **仅存在于叶子节点**。

两个子节点均为 `empty_hash` 的节点称为 _叶子节点_，其余节点称为 _内部节点_。

#### 访问账户的余额、nonce、代码、存储根和存储槽

假设一个账户 `A ≡ (A_b, A_n, A_c, A_s)` 在地址 `A_a`，以下元素可以在以下地址找到：

 * 账户余额 `A_b` 可以在键 `hash(A_a)[0..253] ++ 0b00` 找到，类型为 `uint256`；
 * 账户 nonce `A_n` 可以在键 `hash(A_a)[0..253] ++ 0b01` 找到，类型为 `uint64`；
 * 代码 `A_c` 是一个任意长度的字节序列，可以在键 `hash(A_a)[0..253] ++ 0b10` 找到；
 * 存储树的根 `A_s` 可以在键 `hash(A_a)[0..253] ++ 0b11` 找到
     * 存储槽编号 `k` 可以在键 `hash(A_a)[0..253] ++ 0b11 ++ hash(k)` 找到。

在 [EIP-2926](./eip-2926.md) 部署后，`A_c` 将代表代码默克化树的根。访问代码块编号 `c` 的键为 `hash(A_a)[0..253] ++ 0b10 ++ u256(c)`。

在不太可能的未来，如果需要在账户级别向树中添加额外项，可以为未来使用保留第三个比特。

### 节点默克化规则

叶子和没有前缀的节点根据以下规则进行哈希：

```
internal_hash = hash(left_child_hash || right_child_hash)
leaf_hash = hash(hash(key) || hash(leaf_value))
```

如果存在前缀，则从根到带前缀节点的路径长度进一步与无前缀规则的输出连接，并再次哈希：

```
internal_hash_with_prefix = hash(u256(path_length_u256 - 1) || internal_hash)
leaf_hash_with_prefix = hash(u256(path_length_u256 - 1) || leaf_hash)
```

## 理由

### blake2b

BLAKE2 提供了更好的性能，这是补偿与节点数量增加约 4 倍相关的性能损失的关键。

BLAKE3 提供了更好的性能。在撰写本文时，没有官方的 golang 版本。这带来了安全风险，因此考虑使用 BLAKE2。

### 合并账户和存储树

客户端的趋势是将键和值存储在“扁平”数据库中。将任何存储槽的键以其所属账户的地址键为前缀，有助于将账户的所有数据在磁盘上分组，并简化见证结构。

### 前缀和扩展节点

提出了一种替代方案，提供了最佳的见证。权衡是必须删除扩展节点。

```
node_hash = hash(left_child_hash || right_child_hash)
leaf_hash = hash(0 || leaf_value)
```

删除扩展节点会导致 40 倍更高的哈希成本（对于仅有 1k 叶子的树，约为 25ms），因此它们被保留。

试图保留扩展节点用于见证而不是默克化规则的尝试可以在 [这里](https://notes.ethereum.org/m5VMkX8FRvi0Q_OOR7TF4A) 找到。

摆脱复杂的方法，如 RLP、十叉前缀和子节点嵌套，已经提供了很大的简化。

### 2x32 字节输入

已请求将每个节点哈希计算保持为一个函数，该函数接受两个 256 位整数作为输入并输出一个 256 位整数。这个特性预计将与电路构造良好配合，因此预计将大大有助于未来的零知识应用。
### 二叉树

二叉树之所以被选择，主要是因为它们减少了见证大小。一般来说，在一个包含 `N` 个元素的树中，每个元素有 `k` 个子节点，分支的平均长度大约为 `32 * (k-1) * log(N) / log(k)` 加上几个百分点的开销。32 是哈希的长度；`k-1` 指的是默克尔证明需要在每一层提供所有 `k-1` 个姐妹节点，而 `log(N) / log(k)` 是树中层数的近似值（例如，一个每个节点有 5 个子节点，总共有 625 个节点的树，其深度为 4，因为 `625 = 5**4`，所以 `log(625) / log(5) = 4`）。

对于任何 `N`，该表达式在 `k = 2` 时最小。以下是假设 `N = 2**24` 时不同 `k` 值的分支长度表：

| `k`（每个节点的子节点数） | 分支长度（块） | 分支长度（字节） |
| - | - | - |
| 2 | 1 * 24 = 24 | 768 |
| 4 | 3 * 12 = 36 | 1152 |
| 8 | 7 * 8 = 56 | 1792 |
| 16 | 15 * 6 = 90 | 2880 |

由于不均匀分布和开销，实际的分支长度会略大于此，但 `k=2` 远远是最好的这一模式依然成立。

以太坊树最初是六叉的，因为这会减少数据库读取的次数（例如，上述示例中的 6 而不是 24）。现在理解到这种推理是有缺陷的，因为节点仍然可以在数据库层面“假装”二叉树是六叉树（甚至是 256 叉树）（例如，见 https://ethresear.ch/t/optimizing-sparse-merkle-trees/3751），从而在哈希结构的角度上获得二叉树的低证明大小，同时在数据库中有更高效的表示。

此外，预计二叉树将在 Eth2 中广泛使用，因此这条路径提高了向前兼容性，并减少了协议的长期总复杂性。

### 路径长度而不是位前缀

为了消除与字节操作相关的复杂性，仅使用扩展的位长度来对带前缀的节点进行默克尔化。

从根节点存储路径长度而不是从父节点存储路径长度具有一个良好的特性，即在删除叶子时不需要对兄弟节点进行哈希。

![兄弟删除示意图](../assets/eip-3102/sibling.svg)

*左侧是带前缀长度的树，右侧是带完整路径长度的树。两者都有值 `10000100` 和 `10000000`。在删除 `10000100` 后，左侧树中的兄弟节点必须更新，而右侧则不需要。*

### 值哈希

除了代码外，树中的所有值都小于 32 字节。EIP-2926 引入了代码块，`CHUNK_SIZE = 32 字节`。因此，可以省略叶子值的哈希。然而，EIP 的作者正在考虑未来增加 `CHUNK_SIZE`，使得 `hash(value)` 成为未来的选择。

## 向后兼容性

为了使区块具有使用不同结构的树根，需要进行硬分叉。

## 测试用例

待定

## 实现

 * 截至 [commit 0db87e187dc0bfb96046a47e3d6768c93a2e3331](https://github.com/gballet/multiproof-rs/commit/6d22b1aef9548581826b3c04b3e00d6cc709388c)，[multiproof-rs](https://github.com/gballet/multiproof-rs) 在 `src/binary_tree.rs` 文件中的 `hash_m5()` 函数中实现了这一默克尔化规则。
 * 该结构的 go-ethereum 实现可在 [此分支](https://github.com/gballet/go-ethereum/tree/rebased-binary-trie-m5-full-path) 中找到。

## 安全考虑

在过渡过程中可能会出现问题。特别是，繁重的转换过程可能会激励客户端等待过渡结束。这可能导致在过渡时网络安全性降低。已提出过渡过程，见 [EIP-2584](./eip-2584.md)。

## 版权

版权及相关权利通过 [CC0](../LICENSE.md) 放弃。