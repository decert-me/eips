---
eip: 5
title: `RETURN` 和 `CALL*` 的 Gas 使用
author: Christian Reitwiessner <c@ethdev.com>
status: Final
type: Standards Track
category: Core
created: 2015-11-22
---

### 摘要

本 EIP 使得调用返回字符串和其他动态大小数组的函数成为可能。
目前，当从以太坊虚拟机内部调用另一个合约/函数时，输出的大小必须提前指定。当然，可以指定更大的大小，但也必须为未写入的内存支付 gas，这使得返回动态大小的数据既昂贵又不灵活，以至于实际上无法使用。

本 EIP 提出的解决方案是在 `CALL` 返回时，仅对实际写入的内存收取 gas。

### 规范

`CALL`、`CALLCODE` 和 `DELEGATECALL`（后文称为 `CALL*`）的 gas 和内存语义如下更改（`CREATE` 不写入内存，因此不受影响）：

假设 `CALL*` 的参数为 `gas, address, value, input_start, input_size, output_start, output_size`，那么在操作码开始时，仅对 `input_start + input_size` 收取扩展内存的 gas，而不对 `output_start + output_size` 收取。

如果被调用的合约返回大小为 `n` 的数据，则调用合约的内存扩展到 `output_start + min(output_size, n)`（并且调用合约为此收取 gas），输出写入区域为 `[output_start, output_start + min(n, output_size))`。

调用合约可能在操作码开始时和结束时耗尽 gas。

在调用后，`MSIZE` 操作码应返回内存实际扩展的大小。

### 动机

一般来说，为调用的输出保留一定的内存区域是良好的实践，因为让子程序写入内存中的任意区域可能是危险的。另一方面，通常很难在执行调用之前知道调用的输出大小：数据可能在另一个合约的存储中，而该存储通常是不可访问的，确定其大小需要对该合约进行另一次调用。

此外，为未实际写入的内存区域收取 gas 是不必要的。

该提案试图解决这两个问题：调用者可以选择在其内存区域的末尾提供一个巨大的内存区域。被调用者可以通过返回来“写入”它，而调用者仅为实际写入的内存区域收取费用。

这使得以非常灵活的方式返回动态数据，如字符串和动态大小数组成为可能。甚至可以确定返回数据的大小：如果调用者使用 `output_start = MSIZE` 和 `output_size = 2**256-1`，则实际写入的内存区域为 `(output_start, MSIZE)`（此处，`MSIZE` 在调用后评估）。这很重要，因为它允许“代理”合约调用其他合约，而它们的接口并不为其所知，并且仅返回其输出，即它们同时转发输入和输出。为此，重要的是调用者 (1) 不需要提前知道输出的大小，(2) 可以在调用后确定输出的大小。

### 理由

这种处理问题的方式对以太坊虚拟机的更改最小。实现类似目标的其他方法将改变操作码本身或其参数的数量。另一种可能性是仅在 `output_size` 等于 `2**256-1` 时更改 gas 机制。由于实现的主要困难在于必须在 `CALL` 周围的代码中两次扩展内存，因此这不会简化。

在早期阶段，曾提议在栈上添加返回数据的大小，但上述 `MSIZE` 机制应该足够，并且向后兼容性更好。

一些评论可以在 https://github.com/ethereum/EIPs/issues/8 找到

### 向后兼容性

该提案改变了合约的语义，因为合约可以访问 gas 计数器和内存大小。

另一方面，由于以下原因，现有合约不太可能受到此更改的影响：

Gas：

虚拟机不会收取比以前更多的 gas。通常，合约的编写方式是，如果它们使用更少的 gas，其语义不会改变。如果使用了更多的 gas，合约可能会在对子调用所需的 gas 进行紧密估算时耗尽 gas。在这种情况下，合约可能只会向其调用者返回更多的 gas。

内存大小：

`MSIZE` 操作码通常用于在先前未使用的位置分配内存。
语义的变化以两种方式影响现有合约：

1. 分配内存的重叠。通过使用 `CALL`，合约可能希望分配某个内存片段，即使被调用的合约并未写入该片段。后续使用 `MSIZE` 分配内存可能与此片段重叠，而该片段现在比更改前小。不过，这种合约存在的可能性不大。

2. 内存地址变化。一般来说，如果使用 `MSIZE` 分配内存，则更改后内存中对象的地址将不同。合约应以某种方式编写，使得内存中的对象是*可重定位*的，即它们在内存中的绝对位置和相对于其他对象的位置无关紧要。当然，这对数组来说并非如此，但它们是在单次分配中分配的，而不是通过中间的 `CALL`。

### 实现

虚拟机实现者应注意，在调用结束之前以及在检查仍然有足够的 gas 可用后，不要扩展内存。该 EIP 的典型用法包括为输出“保留” `2**256-1` 字节的内存。

Python 实现：

  old: http://vitalik.ca/files/old.py
  new: http://vitalik.ca/files/new.py