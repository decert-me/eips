---
eip: 627
title: Whisper 规范
author: Vlad Gluhovsky <gluk256@gmail.com>
type: 标准跟踪
category: 网络
status: 最终
created: 2017-05-05
---

## 摘要

本 EIP 描述了 ÐΞVp2p 传输协议中 Whisper 消息的格式。
本 EIP 应替代 [现有规范](https://github.com/ethereum/wiki/wiki/Whisper-Wire-Protocol)。
有关 Whisper 的更详细文档可以在 [这里](https://github.com/ethereum/go-ethereum/wiki/Whisper) 找到。

## 动机

有必要指定 Whisper 消息的标准，以确保不同 Whisper 客户端的向前兼容性。

## 规范

所有作为 ÐΞVp2p 传输协议数据包发送的 Whisper 消息应为 RLP 编码的数据数组，包含两个对象：整数数据包代码后跟另一个对象（其类型取决于数据包代码）。

如果 Whisper 节点不支持特定的数据包代码，则应忽略该数据包，而不生成任何错误。

### 数据包代码

为 Whisper 协议保留的消息代码：0 - 127。
未知代码的消息必须被忽略，以确保未来版本的向前兼容性。

Whisper 子协议应支持以下数据包代码：

| EIP   | 名称                       | 整数值 |
|-------|----------------------------|-----------|
|       | 状态                     |     0     |
|       | 消息                     |     1     |
|       | PoW 要求                 |     2     |
|       | Bloom 过滤器             |     3     |
|-------|----------------------------|-----------|


以下消息代码是可选的，但保留用于特定目的。

| EIP   | 名称                       | 整数值 |
|-------|----------------------------|-----------|
|       | P2P 请求                  |    126    |
|       | P2P 消息                  |    127    |
|-------|----------------------------|-----------|

### 数据包格式和使用

**状态** [`0`]

此数据包包含两个对象：整数消息代码 (0x00) 后跟一个值列表：整数版本、浮点 PoW 要求和 Bloom 过滤器，按此顺序。Bloom 过滤器参数是可选的；如果缺失或为 nil，则该节点被视为全节点（即接受所有消息）。PoW 和 Bloom 过滤器的格式请见下文（消息代码 2 和 3）。

状态消息应在初始握手后发送，并在任何其他消息之前发送。

**消息** [`1`, `whisper_envelopes`]

此数据包包含两个对象：整数消息代码 (0x01) 后跟一个 Whisper 信封的列表（可能为空）。

此数据包用于发送标准的 Whisper 信封。

**PoW 要求** [`2`, `PoW`]

此数据包包含两个对象：整数消息代码 (0x02) 后跟一个单一的浮点 PoW 值。该值是 64 位浮点数的 IEEE 754 二进制表示。qNAN、sNAN、INF 和 -INF 的值是不允许的。负值也不允许。

此数据包由 Whisper 节点用于动态调整其各自的 PoW 要求。此消息的接收者不应再向发送者发送 PoW 低于此消息中指定的值的消息。

PoW 定义为找到当前 BestBit（哈希中的前导零位数）所需的平均迭代次数，除以消息大小和 TTL：

	PoW = (2**BestBit) / (size * TTL)

PoW 计算：

	fn short_rlp(envelope) = rlp of envelope, excluding env_nonce field.
	fn pow_hash(envelope, env_nonce) = sha3(short_rlp(envelope) ++ env_nonce)
	fn pow(pow_hash, size, ttl) = 2**leading_zeros(pow_hash) / (size * ttl)

其中 size 是完整 RLP 编码信封的大小。

**Bloom 过滤器** [`3`, `bytes`]

此数据包包含两个对象：整数消息代码 (0x03) 后跟一个任意大小的字节数组。

此数据包由 Whisper 节点用于共享其对特定主题消息的兴趣。

Bloom 过滤器用于在不过多妨碍隐私的情况下，向对等方识别多个主题。通过添加位，可以精确控制信息内容（从而提高过滤器的效率）。

Bloom 是通过对多个 Bloom 主题进行按位或操作形成的。Bloom 函数将主题映射到 512 位切片。每个 Bloom 主题最多标记三个位。

投影函数定义为从 4 字节切片 S 到 512 位切片 D 的映射；为方便解释，S 将解引用为字节，而 D 将解引用为位。

	LET D[*] = 0
	FOREACH i IN { 0, 1, 2 } DO
	LET n = S[i]
	IF S[3] & (2 ** i) THEN n += 256
	D[n] = 1
	END FOR


可选

**P2P 请求** [`126`, `whisper_envelope`]

此数据包包含两个对象：整数消息代码 (0x7E) 后跟一个单一的 Whisper 信封。

此数据包用于发送 Dapp 级别的点对点请求，例如 Whisper 邮件客户端请求来自 Whisper 邮件服务器的旧消息。

**P2P 消息** [`127`, `whisper_envelope`]

此数据包包含两个对象：整数消息代码 (0x7F) 后跟一个单一的 Whisper 信封。

此数据包用于发送不应进一步转发的点对点消息。例如，它可能被 Whisper 邮件服务器用于传递旧的（过期的）消息，而这在其他情况下是不允许的。


### Whisper 信封

信封是 RLP 编码的结构，格式如下：

	[ 过期时间, TTL, 主题, 数据, 随机数 ]
	
`过期时间`：4 字节（UNIX 时间，以秒为单位）。

`TTL`：4 字节（生存时间，以秒为单位）。

`主题`：4 字节的任意数据。

`数据`：任意大小的字节数组（包含加密消息）。

`随机数`：8 字节的任意数据（用于 PoW 计算）。

### 消息数据字段的内容（可选）

本节概述了数据字段的可选描述，以设置示例。稍后可以将其移至单独的 EIP。

仅在您想要解密传入消息时相关，但如果您只想发送消息，任何其他格式都是完全有效的，并且必须转发给对等方。

数据字段包含信封的加密消息。在对称加密的情况下，它还包含附加的盐（即 AES 随机数，12 字节）。明文（未加密）有效负载由以下连接字段组成：标志、辅助字段、有效负载、填充和签名（按此顺序）。

	标志：1 字节；前两位包含辅助字段的大小，第三位指示签名是否存在。
	
	辅助字段：最多 4 字节；包含有效负载的大小。

	有效负载：任意大小的字节数组（可以为零）。

	填充：任意大小的字节数组（可以为零）。

	签名：65 字节（如果存在）。

	盐：12 字节（如果存在，针对对称加密）。

无法解密消息数据的用户也无法访问签名。如果提供，签名是使用发起者身份的私钥对未加密数据的 Keccak-256 哈希的 ECDSA 签名。签名按顺序序列化为 SECP-256k1 ECDSA 签名的 `R`、`S` 和 `V` 参数的连接。`R` 和 `S` 都是大端编码的固定宽度 256 位无符号数。`V` 是 8 位大端编码的非标准化数，应为 27 或 28。
填充字段的引入是为了对齐消息大小，因为仅消息大小可能会泄露重要的元信息。填充可以是任意大小。然而，建议在加密前（即明文）的数据字段大小（不包括盐）应为 256 字节的倍数。

### 有效载荷加密

非对称加密使用标准的椭圆曲线集成加密方案，采用 SECP-256k1 公钥。

对称加密使用 AES GCM 算法，随机生成 96 位的 nonce。

## 理由

数据包代码 0x00 和 0x01 在所有 Whisper 版本中已经被使用。

数据包代码 0x02 将是 Whisper 未来发展的必要条件。它将提供实时调整 PoW 要求的可能性。让网络自我管理比硬编码任何特定的最小 PoW 要求值要好。

数据包代码 0x03 将是网络可扩展性的必要条件。在流量过大的情况下，节点将能够请求并接收他们感兴趣的消息。

数据包代码 0x7E 和 0x7F 可能用于实现 Whisper 邮件服务器和客户端。如果没有 P2P 消息，将无法传递旧消息，因为它们将被识别为过期，且对等方将因违反 Whisper 协议而断开连接。当无法花费时间进行 PoW 时，例如如果一个交易所想要提供最新交易的实时信息，它们可能会用于其他目的。

## 向后兼容性

此 EIP 与 Whisper 版本 6 兼容。任何不实现特定数据包代码的客户端应优雅地忽略这些代码的数据包。这将确保向前兼容性。

## 实现

Whisper 的 Golang 实现（v.6）已经使用数据包代码 0x00 - 0x03。Parity 的 v.6 实现也将使用代码 0x00 - 0x03。代码 0x7E 和 0x7F 被保留，但仍未使用，留作 Whisper 邮件服务器的自定义实现。

## 版权

版权及相关权利通过 [CC0](../LICENSE.md) 放弃。